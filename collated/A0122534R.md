# A0122534R
###### gui\application.css
``` css
/* JavaFX CSS - Leave this comment until you have at least create one rule which uses -fx-Property */
.root {
	/*-fx-background-image: url("background.jpg");*/
	-fx-background-size: contain;
	-fx-background-position: left; 
	-fx-background-repeat: no-repeat;
	-fx-font-size: 12pt;
    -fx-font-family: "Sans Serif";
}

.scroll-pane > .viewport {
   -fx-background-color: transparent;
}

.bottombar {
	-fx-background-color: #336699;
	/**/ -fx-opacity: 0.92; /**/
}

.list-cell {
	-fx-border-radius: 5 5 5 5;
  	-fx-background-radius: 10 10 10 10;
    -fx-border-color:pink;
    /*-fx-skin: "com.sun.javafx.scene.control.skin.ListCellSkin";*/
    -fx-background-color: #f2f2f2; /*rgba(167, 152, 83, 0.8); /*-fx-control-inner-background;*/
    -fx-padding: 0.25em; /* 3 */
    -fx-text-fill: -fx-text-inner-color;
    -fx-opacity: 1;
} .list-cell:empty {
    -fx-opacity: 0;
} .list-cell:odd {
    -fx-background-color: #BBBBBB; /*rgba(243, 233, 185, 0.8); /*derive(-fx-control-inner-background,-10%);*/
    -fx-text-fill: white;
} .list-cell:filled:selected:focused, .list-cell:filled:selected {
    -fx-background-color: linear-gradient(#328BDB 0%, #207BCF 25%, #1973C9 75%, #0A65BF 100%);
    -fx-text-fill: red;
} .list-view .scroll-bar:vertical .increment-arrow,
.list-view .scroll-bar:vertical .decrement-arrow,
.list-view .scroll-bar:vertical .increment-button,
.list-view .scroll-bar:vertical .decrement-button {
    -fx-padding:0;
} .list-view .scroll-bar:horizontal .increment-arrow,
.list-view .scroll-bar:horizontal .decrement-arrow,
.list-view .scroll-bar:horizontal .increment-button,
.list-view .scroll-bar:horizontal .decrement-button {
    -fx-padding:0;
}

.transparent {
    -fx-font-family: "Sans Serif";
	-fx-background-color: transparent;
}

.fancytext {
    -fx-font-family: Helvetica;
    -fx-text-fill: white;/**/
    -fx-stroke: black;
    -fx-stroke-width: 4; /**/
}

#taskGrid {
	-fx-background-color: rgba(255, 255, 255, 0.4);
}

#logScroll {
	-fx-background-color: transparent;
}

#logVbox {
	-fx-background-color: rgba(0, 0, 0, 0.5);
}

.button {
	-fx-background-insets: 0,1,4,5;
    -fx-background-radius: 9,8,5,4;
}

.button-overdue {
    -fx-base: red;
}

.button-floating {
    -fx-base: #4B0082;
}

.button-todo {
    -fx-base: green;
}

.button-today {
    -fx-base: #FFD700;
}

.floating {
	-fx-background-color:#4B0082; /* #800000;*/
	-fx-text-fill: white;
	-fx-background-radius: 9,8,5,4;
}

.todo {
	-fx-background-color:#FFD700;
	-fx-background-radius: 9,8,5,4;
}

.deadline {
	-fx-background-color:green;
	-fx-text-fill:white;
	-fx-background-radius: 9,8,5,4;
}

.heading {
    -fx-font-family: Helvetica;
	-fx-color:#4E443C;
	-fx-font-weight: bold; 
}

.label-curved {
	-fx-background-color: white;
	-fx-border-color: #4E443C;
	-fx-border-width: 3;
	-fx-border-radius: 9,8,5,4;
    -fx-background-radius: 13,9,6,5;
}

.vbox-curved {
	-fx-border-color: #4E443C;
	-fx-border-width: 3;
	-fx-border-radius: 9,8,5,4;
    -fx-background-radius: 11,9,6,5;
	-fx-background-insets: 10;
}

.label-tags {
	-fx-background-insets: 0,1,4,5;
	-fx-background-color:pink;
	-fx-background-radius: 9,8,5,4;
	-fx-border-color: red;
	-fx-border-width: 3;
	-fx-border-radius: 9,8,5,4;
}


```
###### gui\CenterPanel.java
``` java
public class CenterPanel {
	protected boolean isChanging = false; // is the list being editted at the moment?
	protected int previouslySelected = 0; // last selected item in the list
	protected List<TaskList> listOfTaskLists = new ArrayList<TaskList>();	
	protected VBox master;
	
	public CenterPanel() {
		master = new VBox();
	}
	
	/**
	 * @return the master/parent node for this object
	 */
	public VBox getNode() { 
		return master;
	}
	
	/**
	 * Adds a TaskList to the MainWindow
	 * @param list TaskList to be added
	 */
	public void addToList(TaskList list) {
		if (list.listSize>0) {// add only if it has more than one item
			listOfTaskLists.add(list);
			list.isPinnedWindow = false;
			closeAllLists();
			if (list.isListOpen) { // if it was open at the start, keep it open
				list.openList();
			}
			list.getNode().prefWidthProperty().bind(master.widthProperty().subtract(8));
			master.getChildren().add(list.getNode());
		}
	}
	
	/**
	 * Remove a node from the list
	 */
	public void removeFromList(TaskList list) {
		listOfTaskLists.remove(list);
		master.getChildren().remove(list);
	}
	
	/**
	 * Remove a node from the list
	 */
	public void removeFromList(int pos) {
		listOfTaskLists.remove(pos);
		master.getChildren().remove(pos);
	}
	
	/**
	 * Remove all nodes from the list
	 */
	public void removeAllFromList() {
		listOfTaskLists.clear();
		master.getChildren().clear();
	}
	
	/**
	 * Recalculates the entire TaskList display size
	 */
	public void recalculate() {
		if (!isChanging) {
			isChanging = true;
			for (TaskList list : listOfTaskLists) {
				list.recalculate();
			}
			isChanging = false;
		}
	}
	
	/**
	 * Closes all lists in the main window
	 */
	protected void closeAllLists() {
		GUIController.closeAllLists();
	}
}
```
###### gui\ConsolePanel.java
``` java
public class ConsolePanel {
	protected final static String CSSTAG = GUIController.CSS_TAG_BOTTOMBAR;
	protected final static String CSSTAG_TEXTBOX = GUIController.CSS_TAG_TEXTBOX;
	protected final static String WELCOME_MESSAGE = "Welcome!";
	
	protected final static int IMAGE_SIZE = 100;
	protected final static int CLOCK_WIDTH = 140;
	protected final static int CLOCK_HEIGHT = 100;
	protected final static int PADDING = 10;
	protected final static Pos ORIENTATION = Pos.CENTER_RIGHT;
	
	protected final static int POS_AVATAR = 0;
	protected final static int POS_TEXTBOX = 1;
	protected final static int POS_CLOCK = 2;
	protected final static double AUDIO_VOLUME = 0.5; // not yet customisable
	
	protected Label console; // contains the output from the application
	protected HBox hbox;
	
	// Avatar
	protected Image avatar;
	protected ImageView avatarView;
	protected Button frame; // frame for avatar
	
	// Audio
	protected Random randomGen;
	protected ArrayList<AudioClip> audioClips;
	protected AudioClip currentlyPlaying = null;
	protected static String[] audioClipNames = {
			"resources/pika_happy.mp3",
			"resources/pika_piiikachu.mp3",
			"resources/pikaaaa.mp3",
			"resources/pikachu_normal.mp3"
		};
	
	// Real time clock
	protected Button clock; // button so that it can be clicked for a more indepth date view later
	protected LocalDateTime time;
	protected DateTimeFormatter formatter;

	public ConsolePanel() {
		initHBox();
		initClock();
		initMessageBox();
		initAvatar(); // loads avatar into hbox by default
		initAudioClips();

		hbox.getChildren().add(console);
		hbox.getChildren().add(clock);
		
		addHandlers();
	}
	
	/**
	 * @return the master/parent node for this object
	 */
	public HBox getNode() {
		return hbox;
	}
	
	/**
	 * Initialises the master node
	 * @param hbox
	 */
	protected void initHBox() {
		hbox = new HBox();
		hbox.setPadding(new Insets(PADDING));
		hbox.setSpacing(PADDING);
		hbox.setAlignment(ORIENTATION);
		hbox.getStyleClass().add(CSSTAG);
	}
	
	/**
	 * Initialises the Clock
	 * @param clock
	 * @param formatter
	 */
	protected void initClock() {
		clock = new Button();
		clock.getStyleClass().add(GUIController.CSS_STYLE_CURVED_LABEL);
		formatter = DateTimeFormatter.ofPattern("E\ndd/MM/yyyy\nHH:mm");
		updateTime();
		clock.setMinHeight(CLOCK_HEIGHT);
		clock.setMinWidth(CLOCK_WIDTH);
		clock.setTextAlignment(TextAlignment.CENTER);
		clock.setAlignment(Pos.CENTER);
		HBox.setHgrow(clock, Priority.SOMETIMES);
	}
	
	/**
	 * Creates the message box for the console output
	 * @param console
	 */
	protected void initMessageBox() {
		console = new Label(WELCOME_MESSAGE);
		console.setWrapText(true);
		console.prefWidthProperty().bind(getNode().widthProperty());
		console.prefHeightProperty().bind(getNode().heightProperty());
		console.setTextFill(Color.WHITE);
		console.setEffect(new DropShadow());
		console.setTextAlignment(TextAlignment.LEFT);
		console.setPadding(new Insets(PADDING));
		HBox.setHgrow(console, Priority.ALWAYS);
	}
	
	/**
	 * Initialises the avatar image
	 * @param avatar
	 * @param avatarView
	 * @param frame
	 */
	protected void initAvatar() {
		avatarView = new ImageView();
		avatarView.setEffect(new DropShadow());
		frame = new Button();
		frame.setGraphic(avatarView);
		loadAvatar(); // loads an image from file into avatarView
	}
	/**
	 * Initialises the audio clips and its random generator
	 * @param randomGen
	 * @param audioClips
	 */
	protected void initAudioClips() {
		// create the audio clips and random generator
		randomGen = new Random();
		randomGen.setSeed(time.getNano()); // set random seed
		loadAudioClips();
	}
	
	/**
	 * Listeners and handlers
	 */
	protected void addHandlers() {
		// constantly update the clock
        final Timeline timeline = new Timeline(new KeyFrame(Duration.seconds(1), new EventHandler<ActionEvent>() {  
        	@Override
        	public void handle(ActionEvent event) {
        		updateTime();
        	}
        }));  
        timeline.setCycleCount(Animation.INDEFINITE);
        timeline.play();
        
        // clicking on avatar results in audio
        frame.setOnAction(new EventHandler<ActionEvent>() {
			@Override
			public void handle(ActionEvent event) {
				if (!audioClips.isEmpty()) { // if there is audio, play one
					if (currentlyPlaying==null||!currentlyPlaying.isPlaying()) { 
						// if it is empty or is not currently playing
						AudioClip randomClip;
						do {
							randomClip = audioClips.get(randomGen.nextInt(audioClips.size()));
						}while(audioClips.size()>1&& // if only one item, just keep it
								currentlyPlaying!=null&& // if it is null, don't bother with more loops
								currentlyPlaying.equals(randomClip) // if it is same, keep looping
								); // while they are the same, keep looping
						currentlyPlaying = randomClip;
						currentlyPlaying.setVolume(AUDIO_VOLUME);
						currentlyPlaying.play();
					}
				}
			}
	    });
	}
	
	/**
	 * Loads avatar
	 * @return true if successful
	 */
	public boolean loadAvatar() {
		InputStream stream;
		try {
			stream = new FileInputStream(new File(GUIController.AVATAR_IMAGENAME));
			if (stream!=null) {
				Image image = new Image(stream,IMAGE_SIZE, IMAGE_SIZE, true,true);
				if (image!=null) {
					avatar = image;
					avatarView.setImage(avatar);
					if (!hbox.getChildren().contains(frame)) { // if it was removed, add it back
						hbox.getChildren().add(0, frame); // at first position 
					}
				}
				return true;
			}
		} catch (Exception e) { 
			// any kind of failure, FileNotFoundException or NullPointerException, do this
			if (avatar==null) {
				hbox.getChildren().remove(frame);
			}
		}
		return false;
	}
	
	/**
	 * Loads all audio clips in voiceClips
	 * @return true if successful
	 */
	public void loadAudioClips() {
		audioClips = new ArrayList<AudioClip>();
		File file;
		for (int i=0;i<audioClipNames.length;i++) {
			try {
				file = new File(audioClipNames[i]);
				if (file.exists()) {
					audioClips.add(new AudioClip(file.toURI().toString()));
				} else {
					throw new FileNotFoundException("AudioClip not found at: " + file.toURI().toString()); 
				}
			} catch (Exception e) { 
				e.printStackTrace();
			}
		}
	}
	
	/**
	 * Gets current time and displays it on Clock label
	 */
	public void updateTime() {
		time = LocalDateTime.now();
		/*
		clock.setText(
			time.getDayOfWeek() + "\n" +
			time.toLocalDate().toString() + "\n" + 
			time.getHour() + ":" + time.getMinute()
		);//*/
		clock.setText(time.format(formatter));
	}
	
	/**
	 * Adds the message to the console output
	 * @param message
	 */
	public void addToConsole(String message) {
		console.setText(message.trim());
	}
}
```
###### gui\GUIController.java
``` java
public class GUIController extends Application {
	/**
	 * Create a child of the TaskList class to use GUIController's class's
	 * functions for openList and closeList
	 */
	protected static class TaskListCustom extends TaskList {
		public TaskListCustom() {
			super();
			rebindMouseAction();
		}

		public TaskListCustom(String _name) {
			super(_name);
			rebindMouseAction();
		}

		public TaskListCustom(int num) {
			super(num);
			rebindMouseAction();
		}

		protected void rebindMouseAction() {
			name.onActionProperty().unbind();
			name.setOnAction(new EventHandler<ActionEvent>() {
				@Override
				public void handle(ActionEvent event) {
					if (isListOpen) {
						GUIController.closeList(listNumber); // new line that is
																// changed from
																// original
					} else {
						GUIController.openList(listNumber);// new line that is
															// changed from
															// original
					}
				}
			});
		}
	}

	/**
	 * Class to handle Global Handlers
	 */
	protected static class GlobalListener implements NativeKeyListener {
		// NativeKeyListeners
		@Override
		public void nativeKeyPressed(NativeKeyEvent e) {
			if (e.getKeyCode() == NativeKeyEvent.VC_SPACE && // if space and
					(e.getModifiers() == NativeKeyEvent.CTRL_L_MASK || e
							.getModifiers() == NativeKeyEvent.CTRL_R_MASK)) { // alt
				Platform.runLater(new Runnable() {
					@Override
					public void run() {
						if (stage != null) { // in case the buttons were
												// triggered during loading
												// screen
							if (stage.isFocused()) {
								stage.setIconified(true); // minimise
							} else {
								stage.setIconified(true);
								// if it was behind another window, this allows
								// it to regain focus when brought up
								stage.setIconified(false);
							}
						}
					}
				});
			}
		}

		// Unused methods
		@Override
		public void nativeKeyReleased(NativeKeyEvent e) {
		}

		@Override
		public void nativeKeyTyped(NativeKeyEvent e) {
		}
	}

	// Logic components
	protected static Logic logic;
	protected static logic.Model model;

	protected final static String APP_TITLE = "OraCle";
	protected final static String FILE_CSS = "application.css";

	protected final static String CSS_TAG_BOTTOMBAR = "bottombar";
	protected final static String CSS_TAG_TEXTBOX = "textbox";

	protected final static String CSS_STYLE_CURVED_VBOX = "vbox-curved";
	protected final static String CSS_STYLE_CURVED_LABEL = "label-curved";
	protected final static String CSS_STYLE_HEADING = "heading";
	protected final static String CSS_STYLE_TRANSPARENT = "transparent";
	protected final static String CSS_STYLE_COLOR = "-fx-background-color: %1$s;";

	// Formats and default messages
	protected final static String SEARCH_LIST_FORMAT = "%1$s (%2$d) - \"%3$s\""; // name,
																					// list
																					// size,
																					// keywords
	protected final static String MSG_SUGGESTED_COMMAND_FORMAT = "Did you mean the \"%1$s\" command?";
	protected final static String MSG_PROMPT = "Type command here";
	protected final static String MSG_WINDOWSWITCH = "Switch"; // name for
																// Switch button
	protected final static String ERR_TASKID = "ERROR: Task ID not found";
	protected final static String EMPTY_STRING = "";
	protected final static String CMD_SEARCH = "search "; // for Ctrl+F and
															// searching

	// TaskList variables
	// static because there should only be one list of TaskLists at any point of
	// time
	protected static ArrayList<TaskList> taskLists = new ArrayList<TaskList>();
	public final static String[] taskListNames = { "Overdue", "Today",
			"Floating", "To-do", "Search list" };
	public final static String[] STYLE_BUTTON_NAMES = { "button-overdue",
			"button-today", "button-floating", "button-todo", "button-search" };
	protected final static int TASKLIST_OVERDUE = 0;
	protected final static int TASKLIST_TODAY = 1;
	protected final static int TASKLIST_FLOATING = 2;
	protected final static int TASKLIST_TODO = 3;
	protected final static int TASKLIST_SEARCH = 4;
	public final static int TASKLIST_INVALID = -1;
	public static int TASKLIST_PINNED = TASKLIST_INVALID;
	public static int TASKLIST_OPENED = TASKLIST_INVALID; // task list last
															// opened

	public static String AVATAR_IMAGENAME;
	public static String ICON_IMAGE = "icon.png";
	public static boolean isMainWindow = true; // true = main pane window, false
												// = logObject

	// Window sizes and ratios
	protected final static int PINNED_WINDOW_RATIO = 3; // 1/ratio, ratio being
														// the number to divide
														// by
	protected final static int TEXTBOX_RATIO = 8; // 1/ratio, ratio being the
													// number to divide by
	protected final static int MINIMUM_WINDOW_WIDTH = 600;
	protected final static int MINIMUM_WINDOW_HEIGHT = 650;
	protected final static int PADDING = 6;

	// for getting previous commands
	protected static ListIterator<Node> commandIterator;
	protected final static boolean PREVIOUS = false;
	protected final static boolean NEXT = true;
	protected final static int NESTED_NODE_NUM = 5; // number of nested nodes
													// possible

	// for activating focus view
	protected static boolean isFocusView = false;

	/**
	 * Displayables
	 */
	// the overall managers/parents
	protected static final Pane window = new VBox();
	protected static Stage stage = null;
	protected static Scene scene = null;

	// the help menu
	protected static final HelpMenu help = new HelpMenu();

	// the log tab
	protected static VBox logObject;
	protected static Log logCommands;
	protected static Log logConsole;

	// pane, the default view with all TaskLists
	protected static BorderPane pane;
	protected static PinnedPanel pinnedPanel;
	protected static CenterPanel centerPanel;
	protected static ConsolePanel consolePanel;

	// the bar under pane/log
	protected static HBox bottomBar;
	protected static TextField userInputField;
	protected static Button windowSwitch;

	public static void main(String[] args) {
		// launch the GUIController with a PreloaderWindow
		LauncherImpl.launchApplication(GUIController.class,
				PreloaderWindow.class, args);
	}

	@Override
	public void init() {
		// initialise data variables
		initCoreComponents(); // if fail, system will exit

		// initialise displayables
		initPane();
		initLogTab();
		initBottomBar();
		initMainWindow();

		// initialise the taskLists after displayables are ready
		initTaskLists();

		initScene();
		addSceneHandlers();
	}

	@Override
	public void start(Stage primaryStage) {
		stage = primaryStage;
		stage.setScene(scene);
		stage.setTitle(APP_TITLE);
		stage.getIcons().add(
				new Image(GUIController.class.getResourceAsStream(ICON_IMAGE)));
		addStageHandlers();
		stage.show();
		stage.setMinWidth(stage.getWidth());
		stage.setMinHeight(stage.getHeight());
	}

	/**
	 * @return the master/parent node for this object
	 */
	public Pane getWindow() {
		return window;
	}

	/**
	 * Initialises the scene so that things can be added to it
	 */
	protected void initScene() {
		scene = new Scene(window, window.getPrefWidth(), window.getPrefHeight());
		scene.getStylesheets().add(
				GUIController.class.getResource(FILE_CSS).toExternalForm());
	}

	/**
	 * The following are initialised:
	 * 
	 * @param logic
	 * @param model
	 * @param AVATAR_IMAGENAME
	 */
	protected void initCoreComponents() {
		try {
			logic = new Logic();
			model = logic.executeCommand(null);
			AVATAR_IMAGENAME = model.getAvatarLocation();
		} catch (Exception e) {
			// if fail to initialise terminate program
			System.err.println("Unable to create logic components");
			e.printStackTrace();
			System.exit(1);
		}
	}

	/**
	 * Initialises the TaskLists and gets the information for them from the
	 * model
	 * 
	 * @taskLists
	 */
	protected void initTaskLists() {
		// Create the list of TaskLists
		for (int i = 0; i < taskListNames.length; i++) {
			TaskList list = new TaskListCustom(i); // use the new child instead
			taskLists.add(list); // use this version to allow to close all other
									// task lists
			list.name.getStyleClass().add(STYLE_BUTTON_NAMES[i]);
		}
		refreshLists(); // initalise all lists

		// pin the overdue tab if not empty
		if (!taskLists.get(TASKLIST_OVERDUE).isListEmpty()) {
			pin(taskLists.get(TASKLIST_OVERDUE));
		}// */
		openList(TASKLIST_TODAY); // open today first
	}

	/**
	 * Initalises the pinned window's frame
	 * 
	 * @param pinnedPanel
	 */
	protected void initPinnedPanel() {
		pinnedPanel = new PinnedPanel();
		pinnedPanel.getNode().prefWidthProperty().bind(pane.widthProperty());
		pinnedPanel.getNode().prefHeightProperty()
				.bind(pane.heightProperty().divide(PINNED_WINDOW_RATIO));
		pinnedPanel.getNode().getStyleClass().add(CSS_STYLE_CURVED_VBOX);
	}

	/**
	 * Initialises the displayables in the center
	 * 
	 * @param centerPanel
	 *            Binds to the next node object below
	 * @param pane
	 */
	protected void initCenter() {
		centerPanel = new CenterPanel();
		centerPanel.getNode().prefWidthProperty().bind(pane.widthProperty());
		centerPanel.getNode().maxWidthProperty().bind(pane.widthProperty());
	}

	/**
	 * Initialises the bottom panel
	 * 
	 * @param consolePanel
	 *            Binds to the next node object below
	 * @param pane
	 */
	protected void initConsolePanel() {
		consolePanel = new ConsolePanel();
		consolePanel.getNode().prefWidthProperty().bind(pane.widthProperty());
		consolePanel.getNode().maxWidthProperty().bind(pane.widthProperty());
		consolePanel.getNode().maxHeightProperty()
				.bind(pane.heightProperty().divide(TEXTBOX_RATIO));
		consolePanel.getNode().prefHeightProperty()
				.bind(pane.heightProperty().divide(TEXTBOX_RATIO));
	}

	/**
	 * Initialises the default Pane, which is where all the TaskLists are
	 * displayed
	 * 
	 * @param pane
	 *            Binds to the next node object below
	 * @param window
	 */
	protected void initPane() {
		pane = new BorderPane();
		initPinnedPanel();
		initCenter();
		initConsolePanel();

		// add the other panels except for pinnedWindow to the pane
		pane.setCenter(centerPanel.getNode());
		pane.setBottom(consolePanel.getNode());

		// Bind to window
		pane.prefWidthProperty().bind(window.widthProperty());
		pane.prefHeightProperty().bind(window.heightProperty());
	}

	/**
	 * Initialises the Log page of the application
	 * 
	 * @param logObject
	 * @param logConsole
	 * @param logCommands
	 */
	protected void initLogTab() {
		logObject = new VBox();
		logConsole = new Log("Console");
		logCommands = new Log("Commands");
		logObject.getChildren().add(logConsole.getNode());
		logObject.getChildren().add(logCommands.getNode());
		logConsole.getNode().prefHeightProperty()
				.bind(logObject.heightProperty().divide(2));
		logConsole.getNode().prefWidthProperty()
				.bind(logObject.widthProperty());
		logCommands.getNode().prefHeightProperty()
				.bind(logObject.heightProperty().divide(2));
		logCommands.getNode().prefWidthProperty()
				.bind(logObject.widthProperty());
		logObject.prefWidthProperty().bind(window.widthProperty());
		logObject.maxWidthProperty().bind(window.widthProperty());
		logObject.prefHeightProperty().bind(window.heightProperty());
		logObject.maxHeightProperty().bind(window.heightProperty());
		VBox.setVgrow(logObject, Priority.ALWAYS);
		VBox.setVgrow(logCommands.getNode(), Priority.ALWAYS);
		VBox.setVgrow(logConsole.getNode(), Priority.ALWAYS);
	}

	/**
	 * Initialises displayables under the ConsolePanel
	 * 
	 * @param userInputField
	 *            Added to bottomBar
	 * @param windowSwitch
	 *            Added to bottomBar
	 * @param bottomBar
	 *            Binds to the next node object below
	 * @param window
	 */
	protected void initBottomBar() {
		bottomBar = new HBox();
		// initialise the input field
		userInputField = new TextField();
		userInputField.setPromptText(MSG_PROMPT);
		HBox.setHgrow(userInputField, Priority.ALWAYS);
		bottomBar.getChildren().add(userInputField);

		// then create the switch button to toggle between log and pane
		windowSwitch = new Button(MSG_WINDOWSWITCH);
		bottomBar.getChildren().add(windowSwitch);

		// bind to main window
		bottomBar.prefWidthProperty().bind(window.widthProperty());
	}

	/**
	 * Initialises the main container for everything
	 * 
	 * @window Adds the following objects below to the window
	 * @pane
	 * @bottomBar
	 */
	protected void initMainWindow() {
		window.setMinWidth(MINIMUM_WINDOW_WIDTH);
		window.setMinHeight(MINIMUM_WINDOW_HEIGHT);
		// add the nodes to window
		window.getChildren().add(pane);
		window.getChildren().add(bottomBar);
	}

	/**
	 * Adds handlers to the scene
	 * 
	 * @scene
	 * 
	 * 
	 */
	protected void addSceneHandlers() {
		// event handler for userTextField
		userInputField
				.setOnAction((ActionEvent event) -> processUserTextField());
		userInputField.setOnKeyPressed(new EventHandler<KeyEvent>() {
			@Override
			public void handle(KeyEvent keyEvent) {
				if (keyEvent.getCode() == KeyCode.UP) { // get last item typed
														// in, unless it is
														// first
					String lastCommand = getCommandLog(PREVIOUS); // get
																	// previous
					if (!lastCommand.isEmpty()) { // if not empty, replace
													// current userTextField
													// data
						userInputField.setText(lastCommand);
						userInputField.end(); // set cursor behind last chara
					}
				}

				if (keyEvent.getCode() == KeyCode.DOWN) { // get next item typed
															// in, unless it is
															// last
					String lastCommand = getCommandLog(NEXT); // get next item
					if (!lastCommand.isEmpty()) { // if not empty, replace
													// current userTextField
													// data
						userInputField.setText(lastCommand);
						userInputField.end(); // set cursor behind last chara
					}
				}
			}
		});

		// event handler for button
		windowSwitch.setOnAction(new EventHandler<ActionEvent>() {
			@Override
			public void handle(ActionEvent event) {
				switchWindow();
			}
		});

		// Scene event handler for shortcuts
		scene.setOnKeyPressed((new EventHandler<KeyEvent>() {
			@Override
			public void handle(KeyEvent keyEvent) {
				switch (ShortcutManager.processKeyEvent(keyEvent)) {
				case FOCUS_MODE:
					showFocusTask(isPinnedFocused(stage.getScene()));
					break;
				case FOCUS_MODE_CLEAR:
					if (TASKLIST_PINNED != TASKLIST_INVALID) { // if there is
																// pinned
																// window, open
																// that
						openList(TASKLIST_PINNED);
						taskLists.get(TASKLIST_PINNED).requestFocus();
					} else {
						unpin(); // else clear the focus task
					}
					break;
				case HELP:
					showHelpMenu();
					break;
				case SEARCH:
					userInputField.requestFocus();
					userInputField.setText(CMD_SEARCH);
					userInputField.end(); // set cursor behind last chara
					break;
				case SWITCH:
					switchWindow();
					break;
				case INPUT_FIELD:
					userInputField.requestFocus();
					userInputField.end(); // set cursor behind last chara
					break;
				case UNDO:
					executeCommand("undo");
					break;
				case UNPIN:
					unpin();
					break;
				default:
					break;
				}
			}
		}));// */
	}

	/**
	 * Add handlers for the stage
	 * 
	 * @param stage
	 * 
	 */
	protected void addStageHandlers() {
		// create global hook
		try {
			// Get the logger for "org.jnativehook" and set the level to off to
			// remove log from it
			Logger logger = Logger.getLogger(GlobalScreen.class.getPackage()
					.getName());
			logger.setLevel(Level.OFF);
			// Activate the global listener and add it
			GlobalScreen.registerNativeHook();
			GlobalScreen.addNativeKeyListener(new GlobalListener());// Clear
																	// previous
																	// logging
																	// configurations.
		} catch (NativeHookException ex) {
			// if there was a problem ignore the native hook and don't support
			// it
		}

		// unhook it when application closing
		stage.setOnCloseRequest(new EventHandler<WindowEvent>() {
			public void handle(WindowEvent we) {
				try {
					GlobalScreen.unregisterNativeHook();
				} catch (NativeHookException e) {
				}
			}
		});

		// Scene resize listener
		ChangeListener<Number> listener = new ChangeListener<Number>() {
			@Override
			public void changed(ObservableValue<? extends Number> observable,
					Number oldValue, Number newValue) {
				recalculatePinned();
				centerPanel.recalculate();
			}
		};
		stage.widthProperty().addListener(listener);
		stage.heightProperty().addListener(listener);
	}

	/**
	 * Activates the help menu
	 */
	protected void showHelpMenu() {
		if (!help.getNode().isShowing()) {
			help.getNode().show(stage);
		}
	}

	/**
	 * Pins the list to the top window
	 * 
	 * @param list
	 *            list to be pinned
	 */
	protected void pin(TaskList list) {
		if (list != null) {
			unpin();
			pinnedPanel.pin(list);
			TASKLIST_PINNED = list.listNumber;
			pane.setTop(pinnedPanel.getNode());
			openList(list); // open the list to see the main list
			refreshLists();
		}
	}

	/**
	 * Pins a focused Task into the window
	 * 
	 * @param Task
	 *            to be pinned
	 */
	protected static void pinFocusTask(Region focusedTask) {
		if (focusedTask != null) {
			unpin();
			pinnedPanel.pin(focusedTask);
			isFocusView = true;
			pane.setTop(pinnedPanel.getNode());
		}
	}

	/**
	 * Unpins object from the pinnedWindow
	 */
	protected static void unpin() {
		pinnedPanel.unpin();
		TASKLIST_PINNED = TASKLIST_INVALID;
		isFocusView = false;
		pane.setTop(null);
		refreshLists(); // re-add the newly freed list into the center panel
	}

	/**
	 * Recalculates the size of the pined window
	 */
	protected void recalculatePinned() {
		pinnedPanel.recalculate();
	}

	/**
	 * Returns the string from the command log.
	 * 
	 * @param next
	 *            if true, get next command. If false, get previous command
	 * @return command last inputted
	 */
	public String getCommandLog(boolean next) {
		Text command = null;
		String output = "";
		if (commandIterator != null) { // if commandIterator empty, do nothing
			if (next == NEXT && commandIterator.hasNext()) {
				command = (Text) commandIterator.next();
			} else if (next == PREVIOUS && commandIterator.hasPrevious()) {
				command = (Text) commandIterator.previous();
			} // if there are no valid commands, do nothing

			if (command != null) {
				output = command.getText().replaceFirst(">", ""); // delete the
																	// > in the
																	// log
			}
		}
		return output;
	}

	/**
	 * Switch between the main view and the log view
	 */
	protected void switchWindow() {
		window.getChildren().clear();
		if (!isMainWindow) {
			window.getChildren().add(pane);
		} else {
			window.getChildren().add(logObject);
		}
		window.getChildren().add(bottomBar);
		isMainWindow = !isMainWindow;
	}

	/**
	 * Takes the data from userInputField and processes it in executeCommand()
	 */
	public void processUserTextField() {
		String temp = userInputField.getText();
		userInputField.clear();
		executeCommand(temp);
	}

	/**
	 * Returns the task number of the item indicated in the Main Window
	 * 
	 * @param locationInCenterPanel
	 * @return the TaskList's number
	 * @throws IndexOutOfBoundsException
	 */
	protected int getTaskListNumberFromLocationInCenterPanel(
			int locationInCenterPanel) throws IndexOutOfBoundsException {
		return centerPanel.listOfTaskLists.get(locationInCenterPanel).listNumber;
	}

	/**
	 * Gets task list number from the input by user
	 * 
	 * @param processedString
	 * @return
	 * @throws Logic.UnrecognisedCommandException
	 */
	protected int getTaskListNumber(String processedString)
			throws Logic.UnrecognisedCommandException {
		try {
			int i = Integer.parseInt(processedString);
			if (i <= TASKLIST_INVALID) {
				// means that it should have been validated by parser. Can
				// return immediately
				return i + taskListNames.length;
			} else { // it must be a number inputted by the user based on the
						// location of items on the screen
				if (TASKLIST_PINNED != TASKLIST_INVALID && i == 0) {
					// if there is a pinned window and is first element
					return TASKLIST_PINNED;
				} else {
					// if no pinned window, order is same as initial
					// if there is pinned panel and not zero, means one of the
					// center panel
					if (TASKLIST_PINNED != TASKLIST_INVALID) {
						i--; // i-1 because exclude pinned
					}
					return getTaskListNumberFromLocationInCenterPanel(i);
				}
			}
		} catch (NumberFormatException e) {
			model.setConsoleMessage("Invalid command");
			throw new Logic.UnrecognisedCommandException(
					"Unable to parse integer");
		} catch (IndexOutOfBoundsException e) {
			model.setConsoleMessage("Unable to find selected tab");
		}
		return TASKLIST_INVALID; // return invalid otherwise
	}

	/**
	 * Performs an action based on the command. GUI only commands are processed
	 * here
	 * 
	 * @param parsedCommand
	 *            Command after being parsed by Parser
	 * @return true if GUI has performed the necessary action, false if it needs
	 *         to be passed to Logic for further action
	 */
	protected boolean performGuiActions(ParsedCommand parsedCommand) {
		CommandType command = parsedCommand.getCommandType();
		try {
			switch (command) {
			case GUI_SHOW: // show a specific task in the pinned window
				return showFocusTask(true);
			case GUI_SWITCH:
				switchWindow();
				return true;
			case GUI_LOG:
				if (isMainWindow) {
					switchWindow();
					return true;
				}
				break;
			case GUI_MAIN:
				if (!isMainWindow) {
					switchWindow();
					return true;
				}
				break;
			case GUI_UNPIN:
				unpin();
				return true;
			case GUI_PIN:
				pin(taskLists
						.get(getTaskListNumber(parsedCommand.getGuiType())));
				return true;
			case GUI_OPEN:
				TaskList list = taskLists.get(getTaskListNumber(parsedCommand
						.getGuiType()));
				openList(list.listNumber);
				list.getNode().getChildren().get(0).requestFocus(); // have the
																	// first
																	// node of
																	// the Vbox
																	// request
																	// focus
				return true;
			case GUI_CLOSE:
				closeList(taskLists.get(getTaskListNumber(parsedCommand
						.getGuiType())));
				return true;
			default:
				break;
			}
		} catch (ArrayIndexOutOfBoundsException e) {
			// do nothing
		} catch (Logic.UnrecognisedCommandException e) {
			for (int i = 0; i < MyParser.COMMAND_CHOICES.length; i++) {
				if (command.equals(MyParser.COMMAND_CHOICES[i].commandType)) {
					model.setConsoleMessage(String.format(
							MSG_SUGGESTED_COMMAND_FORMAT,
							MyParser.COMMAND_CHOICES[i].str[0]));
					break;
				}
			}
			return true; // because it was caught by GUI controller
		} catch (Exception e) {
			e.printStackTrace();
		}
		return false; // if not valid, return false
	}

	/**
	 * Checks for what kind of command it was, so that it can be used to focus
	 * on the correct object
	 * 
	 * @param command
	 *            The first word of the command
	 */
	protected String performPostLogicActions(ParsedCommand parsedCommand) {
		CommandType command = parsedCommand.getCommandType();
		String output = "";
		try {
			switch (command) {
			case ADD: // focus on the newly added task by putting it at the top
				focusOnTaskID(model.getFocusId());
				break;
			case DELETE:
				if (TASKLIST_PINNED != TASKLIST_INVALID) { // open the list to
															// prevent focus on
															// deleted item
					openList(TASKLIST_PINNED);
				} else {
					unpin(); // unpin to prevent focus on deleted item
				}
				break;
			case EDIT: // focus on editted task
				focusOnTaskID(model.getFocusId());
				break;
			case DISPLAY: // focus on task to be displayed
				focusOnTaskID(parsedCommand.getTaskId());
				break;
			case HELP:
				// help menu
				if (!help.getNode().isShowing()) {
					help.getNode().show(stage);
				}
				break;
			case CONFIG_IMG:
				// if it had been a Set function, it might have been an avatar
				// or background, so reload them
				AVATAR_IMAGENAME = model.getAvatarLocation();
				if (!consolePanel.loadAvatar()) {
					output = "Cannot find new avatar specified";
				}
				break;
			case UNDO:
				if (TASKLIST_PINNED != TASKLIST_INVALID) { // same as delete
					openList(TASKLIST_PINNED);
				} else {
					unpin();
				}
				break;
			case SEARCH: // search function
				closeAllLists();
				TaskList search = taskLists.get(TASKLIST_SEARCH);
				if (!search.isListEmpty()) { // if it is not empty
					// deactivate focus view
					if (isFocusView) {
						unpin();
					}
					openList(TASKLIST_SEARCH); // focus on search
					// then modify the Search List name to include the search
					// term
					String keywords = parsedCommand.getKeywords();
					if (!keywords.isEmpty()) {
						search.name.setText(String.format(SEARCH_LIST_FORMAT,
								taskListNames[TASKLIST_SEARCH],
								search.listSize, keywords));
					}
				}
				break;
			default:
				break;
			}
		} catch (ArrayIndexOutOfBoundsException e) {
			// do nothing
		} catch (Exception e) {
			e.printStackTrace();
		}
		return output;
	}// */

	/**
	 * Runs the command input.
	 * 
	 * @param input
	 */
	protected void executeCommand(String input) {
		if (input != null && !input.isEmpty()) {
			model.setConsoleMessage(null); // set empty
			ParsedCommand parsedCommand = MyParser.parseCommand(input.trim());
			if (!performGuiActions(parsedCommand)) {
				try {
					model = logic.executeCommand(parsedCommand);
					// refresh log command, and get new iterator
					logCommands.addToLog(input);
					commandIterator = logCommands
							.getLog()
							.getChildren()
							.listIterator(
									logCommands.getLog().getChildren().size()); // get
																				// last
																				// item

					refreshLists(); // only needed if sent to logic
				} catch (Logic.UnrecognisedCommandException e) {
					// model.setConsoleMessage(output);
				}

				String output = performPostLogicActions(parsedCommand);
				if (!output.isEmpty()) { // override previous error
					model.setConsoleMessage(output);
				}
			}

			// output console message
			outputToScreen();
		}
	}

	/**
	 * Output to console and store consoleMessage
	 */
	protected void outputToScreen() {
		if (model.getConsoleMessage() == null) {
			model.setConsoleMessage(EMPTY_STRING);
		}
		consolePanel.addToConsole(model.getConsoleMessage());
		logConsole.addToLog(model.getConsoleMessage());
	}

	/**
	 * Refreshes all displayed lists
	 */
	protected static void refreshLists() {
		for (TaskList list : taskLists) {
			switch (list.listNumber) {
			case TASKLIST_TODO: // all tasks tab
				taskLists.get(TASKLIST_TODO).addAllTasks(model.getMainList(),
						true);
				;
				break;
			case TASKLIST_SEARCH: // search list
				list.addAllTasks(model.getSearchList(), true);
				break;
			case TASKLIST_OVERDUE: // overdue list
				list.addAllTasks(model.getOverdueList(), true);
				break;
			case TASKLIST_FLOATING: // floating tasks list
				list.addAllTasks(model.getFloatingList(), true);
				break;
			case TASKLIST_TODAY:// today list
				list.addAllTasks(model.getTodayList(), true);
				break;
			default:
				break;
			}
		}

		// Add the lists to the centerPanel
		if (centerPanel != null) {
			int open = TASKLIST_OPENED;
			centerPanel.removeAllFromList();
			for (int i = 0; i < taskLists.size(); i++) {
				if (i != TASKLIST_PINNED) {
					centerPanel.addToList(taskLists.get(i));
				}
			}
			openList(open); // keep the list that was previously opened open
		}
	}

	/**
	 * Opens a specified list and closes all other lists at the same time
	 * 
	 * @param listNumber
	 *            list to open
	 */
	public static void openList(int listNumber) {
		if (listNumber > TASKLIST_INVALID && listNumber < taskListNames.length) { // if
																					// valid
			if (listNumber != TASKLIST_PINNED) {
				// if it is for pinned window, no need to close anything
				// else close everything
				closeAllLists();
				TASKLIST_OPENED = listNumber;
			}
			TaskList list = taskLists.get(listNumber);
			list.openList();
			if (isFocusView && TASKLIST_PINNED == TASKLIST_INVALID) { // if
																		// there
																		// had
																		// been
																		// a
																		// previously
																		// opened
																		// focus
																		// view
				if (!list.hasSelection()) { // if the list has none selected,
											// select first
					list.selectFirstNode();
				}
				pinFocusTask(list.getFocusTask());
			}
		}
	}

	/**
	 * Opens a specified list and closes all other lists at the same time
	 * 
	 * @param list
	 *            list to open
	 */
	public static void openList(TaskList list) {
		openList(list.listNumber);
	}

	/**
	 * Opens a specified list and closes all other lists at the same time
	 * 
	 * @param listNumber
	 *            list to open
	 */
	protected static void closeList(int listNumber) {
		if (listNumber >= 0 && listNumber < taskListNames.length) { // if valid
			taskLists.get(listNumber).closeList();
			if (listNumber != TASKLIST_PINNED) {
				TASKLIST_OPENED = TASKLIST_INVALID;
			}
		}
	}

	/**
	 * Closes this list
	 * 
	 * @param list
	 */
	protected static void closeList(TaskList list) {
		closeList(list.listNumber);
	}

	/**
	 * Closes all lists except the pinned list
	 */
	protected static void closeAllLists() {
		for (TaskList list : taskLists) {
			if (list.listNumber != TASKLIST_PINNED) {
				closeList(list);
			}
		}
	}

	/**
	 * Creates a focusView for the id number selected
	 */
	protected void focusOnTaskID(int id) {
		try {
			Task taskToFocus = Logic.searchList(model.getAllTasks(), id);
			GridPane grid = TaskList.createDetailedDisplay(taskToFocus);
			// Create a scrollPane for the task
			ScrollPane sp = new ScrollPane(grid);
			TaskList.setScrollPane(sp);
			// grid.prefWidthProperty().bind(sp.widthProperty().subtract(2*PADDING));
			// grid.prefHeightProperty().bind(sp.heightProperty().subtract(2*PADDING));
			pinFocusTask(sp);
		} catch (IndexOutOfBoundsException e) {
			// if out of range
			model.setConsoleMessage(ERR_TASKID);
		}
	}

	/**
	 * Checked if the pinned window has focus
	 */
	protected boolean isPinnedFocused(Scene scene) {
		Node focused = scene.getFocusOwner();
		if (focused != null) {
			TaskList list = taskLists.get(TASKLIST_PINNED);
			for (int i = 0; i < NESTED_NODE_NUM; i++) {
				if (focused == list.getNode()) {
					return true;
				}
				focused = focused.getParent();

				if (focused == null) {
					break;
				}
			}
		}
		return false;
	}

	/**
	 * Opens the focus Task view if valid
	 * 
	 * @param focusPinned
	 *            focus on the pinned window if exists?
	 */
	protected boolean showFocusTask(boolean focusPinned) {
		if (TASKLIST_PINNED != TASKLIST_INVALID && focusPinned) {
			// check if the pinned window is the focus of the scene
			TaskList pinned = taskLists.get(TASKLIST_PINNED);
			pinned.focusTask();
			pinned.closeList();
			pinned.getNode().requestFocus();
			return true;
		} else if (TASKLIST_OPENED != TASKLIST_INVALID) {
			pinFocusTask(taskLists.get(TASKLIST_OPENED).getFocusTask());
			return true;
		} else {
			Node focused = stage.getScene().getFocusOwner();
			if (focused != null) {
				for (TaskList list : taskLists) {
					Node node = focused;
					for (int i = 0; i < NESTED_NODE_NUM; i++) {
						if (list.getNode().equals(node)) {
							openList(list);
							list.selectFirstNode();
							pinFocusTask(list.getFocusTask());
							return true;
						}
						node = node.getParent();
					}
				}
			}
		}
		return false;
	}
}
```
###### gui\Log.java
``` java
public class Log {
	protected final static int MAXSIZE = 100;
	// maximum size of the Log

	protected final static int PADDING = 8;

	protected final static ScrollBarPolicy V_POLICY = ScrollBarPolicy.AS_NEEDED;
	protected final static ScrollBarPolicy H_POLICY = ScrollBarPolicy.NEVER;
	protected final static Pos ALIGNMENT = Pos.BOTTOM_LEFT;
	protected final static String ID_VBOX = "logVbox";
	protected final static String ID_SCROLL = "logScroll";

	protected VBox vbox;
	protected ScrollPane sp;
	protected TextFlow textFlow; // the storage for the log
	protected VBox master;
	protected Label name;

	public Log() {
		master = new VBox();
		textFlow = new TextFlow();

		master.setPadding(new Insets(PADDING));
		master.getChildren().add(initContainer());
		initHeader();
	}

	/**
	 * Creates a log with a name
	 * 
	 * @param str
	 *            Name of the tab
	 */
	public Log(String _name) {
		this();
		setName(_name);
	}

	/**
	 * @return the master/parent node for this object
	 */
	public VBox getNode() {
		return master;
	}

	/**
	 * Initialises the vbox and sp container for the Log
	 * 
	 * @param vbox
	 * @param sp
	 * @return the initalised parent node of this container
	 */
	protected ScrollPane initContainer() {
		vbox = new VBox();
		vbox.setAlignment(ALIGNMENT);
		vbox.setId(ID_VBOX);
		vbox.getChildren().add(textFlow);
		sp = new ScrollPane(vbox);
		vbox.prefWidthProperty().bind(sp.widthProperty());
		vbox.prefHeightProperty().bind(sp.heightProperty());

		sp.setFitToHeight(true);
		sp.setVbarPolicy(V_POLICY);
		sp.setHbarPolicy(H_POLICY);
		sp.setId(ID_SCROLL);
		sp.prefWidthProperty().bind(getNode().widthProperty());
		VBox.setVgrow(sp, Priority.ALWAYS);
		return sp;
	}

	/**
	 * Initialises the header for the Log
	 * 
	 * @param name
	 */
	protected void initHeader() {
		name = new Label();
		name.getStyleClass().add(GUIController.CSS_STYLE_CURVED_LABEL);
		name.setAlignment(Pos.CENTER);
		name.prefWidthProperty().bind(getNode().widthProperty());
	}

	/**
	 * Set name of the log tab
	 */
	public void setName(String _name) {
		name.setText(_name);
		if (master.getChildren().size() == 1) {
			master.getChildren().add(0, name);
		}
	}

	/**
	 * Resets the scrollpane to the bottom
	 */
	public void refresh() {
		sp.snapshot(new SnapshotParameters(), new WritableImage(1, 1));
		sp.setVvalue(sp.getVmax()); // scroll to the bottom after refresh
	}

	/**
	 * Adds a string to the log
	 * 
	 * @param input
	 *            String to be added
	 */
	public void addToLog(String input) {
		textFlow.getChildren().add(new Text(">" + input.trim() + "\n"));
		// if size exceed, delete first item
		if (textFlow.getChildren().size() > MAXSIZE) {
			textFlow.getChildren().remove(0);
		}
		refresh();
	}

	/**
	 * Gets the stored log data in the form of an iterator
	 */
	public TextFlow getLog() {
		return textFlow;
	}

}
```
###### gui\PinnedPanel.java
``` java
public class PinnedPanel {
	protected final static int PADDING = GUIController.PADDING;

	protected VBox master;
	protected TaskList pinnedList;

	public PinnedPanel() {
		master = new VBox();
		pinnedList = null;
	}

	/**
	 * @return the master/parent node for this object
	 */
	public VBox getNode() {
		return master;
	}

	/**
	 * Pins the list to the top window
	 * 
	 * @param list
	 *            list to be pinned
	 */
	public void pin(TaskList list) {
		if (list != null) {
			unpin();
			list.isPinnedWindow = true;
			list.selectFirstNode(); // select the first node, since it is moving
									// up now
			list.focusTask(); // create an instance of zoomed in task
			Region node = list.getNode();
			node.prefWidthProperty().unbind();
			node.prefHeightProperty().unbind();
			node.prefWidthProperty().bind(master.widthProperty());
			node.prefHeightProperty().bind(master.heightProperty());
			master.getChildren().add(node);
			pinnedList = list; // store it
		}
	}

	/**
	 * Pins a focused Task into the window
	 * 
	 * @param Task
	 *            to be pinned
	 */
	public void pin(Region focusedTask) {
		if (focusedTask != null) {
			unpin();
			focusedTask.prefWidthProperty().unbind();
			focusedTask.prefHeightProperty().unbind();
			focusedTask.prefWidthProperty().bind(master.widthProperty());
			focusedTask.prefHeightProperty().bind(master.heightProperty());
			focusedTask.setPadding(new Insets(0, PADDING, 0, PADDING));
			master.getChildren().add(focusedTask);
		}
	}

	/**
	 * Unpins object from the pinnedWindow
	 */
	public void unpin() {
		if (pinnedList != null) {
			// focus view deactivate regardless of pinned window or task
			pinnedList.isPinnedWindow = false;
			// force it to close
			pinnedList.closeList();
			Region node = pinnedList.getNode();
			node.prefWidthProperty().unbind();
			node.prefHeightProperty().unbind();
			node.setPrefHeight(Region.USE_COMPUTED_SIZE);
			pinnedList = null;
		}
		master.getChildren().clear();
	}

	/**
	 * Recalculates the size of the pined window
	 */
	protected void recalculate() {
		if (pinnedList != null) {
			pinnedList.recalculate();
		}
	}
}
```
###### gui\PreloaderWindow.java
``` java
public class PreloaderWindow extends Preloader {
	protected final static int PRELOADER_SIZE = 150;
	private Stage preloaderStage;
	private Scene scene;

	@Override
	public void init() {
		ProgressIndicator preloader = new ProgressIndicator();
		preloader.setProgress(ProgressIndicator.INDETERMINATE_PROGRESS);
		preloader.setMinSize(PRELOADER_SIZE, PRELOADER_SIZE);
		scene = new Scene(preloader);
	}

	@Override
	public void start(Stage primaryStage) throws Exception {
		this.preloaderStage = primaryStage;
		primaryStage.setScene(scene);
		primaryStage.initStyle(StageStyle.UNDECORATED);
		primaryStage.show();
	}

	@Override
	public void handleStateChangeNotification(
			StateChangeNotification stateChangeNotification) {
		if (stateChangeNotification.getType() == StateChangeNotification.Type.BEFORE_START) {
			preloaderStage.hide();
		}
	}
}
```
###### gui\ShortcutManager.java
``` java
public class ShortcutManager {
	public static enum CommandType { 
		FOCUS_MODE, 
		FOCUS_MODE_CLEAR, 
		HELP,
		SEARCH,  
		SWITCH,
		INPUT_FIELD, // gives control to the input Field
		UNDO, 
		UNPIN,
		NONE
	};
	
	public static CommandType processKeyEvent(KeyEvent keyEvent) {
		if (isFocusMode(keyEvent)) {
			return CommandType.FOCUS_MODE;
		} else if (isFocusModeClear(keyEvent)) {
			return CommandType.FOCUS_MODE_CLEAR;
		} else if (isHelp(keyEvent)) {
			return CommandType.HELP;
		} else if (isSearch(keyEvent)) {
			return CommandType.SEARCH;
		} else if (isSwitch(keyEvent)) {
			return CommandType.SWITCH;
		} else if (isInputField(keyEvent)) {
			return CommandType.INPUT_FIELD;
		} else if (isUndo(keyEvent)) {
			return CommandType.UNDO;
		} else if (isUnpin(keyEvent)) {
			return CommandType.UNPIN;
		}
		
		return CommandType.NONE;
	}
	
	public static boolean isFocusMode(KeyEvent keyEvent) {
		return (keyEvent.getCode()==KeyCode.BACK_SLASH&&!keyEvent.isShiftDown());
	}
	
	public static boolean isFocusModeClear(KeyEvent keyEvent) {
		return ((keyEvent.getCode()==KeyCode.BACK_SLASH&&keyEvent.isShiftDown())||
		keyEvent.getCode()==KeyCode.BACK_SPACE);
	}

	public static boolean isHelp(KeyEvent keyEvent) {
		return (keyEvent.getCode()==KeyCode.F1);
	}
	
	public static boolean isSearch(KeyEvent keyEvent) {
		 return (keyEvent.getCode()==KeyCode.F&&
					(keyEvent.isControlDown()));
	}

	public static boolean isSwitch(KeyEvent keyEvent) {
		return ((keyEvent.getCode()==KeyCode.T)&&keyEvent.isAltDown());
	}
	
	public static boolean isInputField(KeyEvent keyEvent) {
		return ((keyEvent.getCode()==KeyCode.T)&&keyEvent.isControlDown());
	}
	
	public static boolean isUndo(KeyEvent keyEvent) {
		return (keyEvent.getCode()==KeyCode.Z&&
				(keyEvent.isControlDown()||keyEvent.isAltDown()));
	}
	
	public static boolean isUnpin(KeyEvent keyEvent) {
		return (keyEvent.getCode()==KeyCode.U&&
				(keyEvent.isControlDown()));
	}
}
```
###### gui\TaskList.java
``` java
public class TaskList {
	// details about the TaskList's type
	protected int listNumber = -1;
	protected String listName = "";
	protected int listSize = 0;
	public final int INVALID_SELECTION = -1; // invalid number for selected item in list

	// default messages/formats
	protected final static String MSG_NO_CONTENT = "No Content";
	protected final static String FORMAT_TIME = "HH:mm, dd/MM E";
	protected final static String FORMAT_NAME = "%1$s (%2$d)";
	
	// default alignments and displayable settings
	protected final static ScrollBarPolicy V_POLICY = ScrollBarPolicy.NEVER;
	protected final static ScrollBarPolicy H_POLICY = ScrollBarPolicy.NEVER;
	protected final static Pos ALIGNMENT = Pos.TOP_LEFT;
	protected final static int PADDING = 6;
	
	protected final static String STYLE_FLOATING = "floating";
	protected final static String STYLE_DEADLINE = "deadline";
	protected final static String STYLE_EVENT = "todo";
	protected final static String STYLE_CURVED = "-fx-background-radius: 9,8,5,4;";
	
	// grid locations
	protected final static int COL_HEADER = 0;
	protected final static int COL_CONTENT = 1;
	protected final static int COL_CONTENT_SIZE = 2;
	protected final static int COL_SIZE = 2;
	protected final static int ROW_NAME = 0;
	protected final static int ROW_ID = 1;
	protected final static int ROW_TAGS = 2;
	protected final static int ROW_DATE = 3;
	protected final static int SIDEBAR_COL_ID = 0;
	protected final static int SIDEBAR_COL_NAME = 1;
	protected final static int SIDEBAR_COL_DATE = 2;
	protected final static int SIDEBAR_COL_DONE = 3;
	protected final static int SIDEBAR_COL_SIZE = 4; 
	protected final static VPos GRID_HEADER_VERT_ALIGNMENT = VPos.TOP;
	protected final static int GRID_COL_HEADER_FINAL_LENGTH = 70; // header col's fixed length
	
	// asthetic settings
	protected final static String COLOR_OVERDUE = "-fx-text-fill: rgba(255, 0, 0, 1);";
	protected final static String COLOR_HEADER = "rgba(255, 255, 0, 0.9)";
	protected final static Color COLOR_LABEL = Color.BLACK;
	protected final static double ROW_CELL_HEIGHT = 33.3;
	protected final static double BORDER_HEIGHT = 2.0;
	protected final static double IMAGE_SIZE = 10.0;
	protected final static double DATE_WIDTH = 280.0;
	
	// images for done and not done
	protected static Image[] imageCompletion = null;
	protected final static String DONE = "resources/Check.png";
	protected final static String NOT_DONE = "resources/Delete.png";
	protected final static int DONE_IMAGE_SIZE = 16; 
	
	// displayables
	protected VBox master; // the overall TaskList manager
	protected Button name; // button to press;
	protected ListView<Node> listView; // the list of tasks
	protected ObservableList<Node> items; // the items within the list
	protected List<Task> listOfTasks = new ArrayList<Task>(); // currently displayed tasks
	protected ScrollPane detailedView;
	
	protected static SimpleDateFormat format;
	protected boolean isChanging = false;
	protected boolean isPinnedWindow = false; // by default assume that it is not pinned 
	protected boolean isListOpen = true; // open by default
	
	public TaskList() {
		master = new VBox();
		
		initDoneImages();
		initNameButton();
		initListView();
		initScrollPane();
		
		// add the Nodes to master
		master.getChildren().add(listView);
	    
		// Time
		format = new SimpleDateFormat(FORMAT_TIME);
	    
		addHandlers();
	}
	
	/**
	 * Creates a TaskList with a name
	 * @param _name Name of task list
	 */
	public TaskList(String _name) {
		this();
		setName(_name);
	}
	
	/**
	 * Creates a TaskList with a reference number to GUIController
	 * @param num The number allocated to this task list
	 */
	public TaskList(int num) {
		this();
		if (num>=0) {
			listNumber = num;
			setName(GUIController.taskListNames[num]);
		}
	}
	
	/**
	 * Sets name of the TaskList
	 * @param _name Name of TaskList
	 */
	public void setName(String _name) {
		listName = _name.trim();
		name.setText(listName);
		if (master.getChildren().size()==1) { // add the name if it does not exist
			master.getChildren().add(0,name); // add on top of any other node already in master
		}
	}
	
	/**
	 * @return the master/parent node for this object
	 */
	public VBox getNode() { 
		return master;
	}
	
	/**
	 * Initialises the name Button node and binds it to the parent node of this TaskList
	 * @param name
	 */
	protected void initNameButton() {
		name = new Button();
		name.prefWidthProperty().bind(getNode().widthProperty());
		name.setAlignment(Pos.CENTER);
	}
	
	/**
	 * Initialisation of the image for Done and Not Done if they are not yet initialised
	 * @param imageCompletion
	 */
	protected void initDoneImages() {
		// define the images for done and not done if not defined
		if (imageCompletion==null) {
			imageCompletion = new Image[2];
			imageCompletion[0] = new Image(TaskList.class.getResourceAsStream(NOT_DONE),DONE_IMAGE_SIZE, DONE_IMAGE_SIZE, true, true);
			imageCompletion[1] = new Image(TaskList.class.getResourceAsStream(DONE),DONE_IMAGE_SIZE, DONE_IMAGE_SIZE, true, true);
		}
	}
	
	/**
	 *  Initialises the main list and binds it to the parent node
	 *  @param items
	 *  @param listView
	 */
	protected void initListView() {
		items = FXCollections.observableArrayList();
		listView = new ListView<Node>();
		listView.setPlaceholder(new Label(MSG_NO_CONTENT));
		listView.getStyleClass().add(GUIController.CSS_STYLE_TRANSPARENT);
		listView.prefWidthProperty().bind(getNode().widthProperty());
	}
	
	/**
	 * Initialises the ScrollPane in which focus view is located in
	 * @param detailedView
	 */
	protected void initScrollPane() {
	    detailedView = new ScrollPane();
	    setScrollPane(detailedView);
		detailedView.prefWidthProperty().bind(getNode().widthProperty());
		detailedView.prefWidthProperty().bind(getNode().heightProperty());
	}
	
	/**
	 * Allocates the default detailedView settings to a ScrollPane.
	 * Allows for external use for other ScrollPanes to gain these settings
	 */
	public static void setScrollPane(ScrollPane sp) {
		sp.setFitToWidth(true);
		sp.setVbarPolicy(V_POLICY);
		sp.setHbarPolicy(H_POLICY);
		sp.setPadding(new Insets(0, PADDING, 0, PADDING)); // left and right padding only
		sp.getStyleClass().add(GUIController.CSS_STYLE_TRANSPARENT);
	}
	
	/**
	 * Function to hold all handlers and listeners
	 */
	protected void addHandlers() {
		// When name button is clicked, open/close the list
	    name.setOnAction(new EventHandler<ActionEvent>() {
			@Override
			public void handle(ActionEvent event) {
				if (isListOpen) { 
					closeList();
				} else {
					openList();
				}
			}
	    });
	    
	    // Dynamically change the item size located on name button when list is modified
	    items.addListener(new ListChangeListener<Node>() {
			@Override
			public void onChanged(javafx.collections.ListChangeListener.Change<? extends Node> c) {
				listSize = items.size();
				if (isListEmpty()) {
					name.setText(listName);
				} else {
					name.setText(String.format(FORMAT_NAME, listName, listSize));
				}
			}
		});//*/

		listView.getSelectionModel().selectedItemProperty().addListener(
			new ChangeListener<Node>() {
				public void changed(ObservableValue<? extends Node> ov, Node old_val, Node new_val) {
					if (isListOpen||isPinnedWindow) { 
						// if the list is open or is pinned, generate the focus task in real time
						focusTask(); // generate a focus view
					}
				}
			});
	}
	
	/**
	 * Requests focus so that can scroll the listView
	 */
	public void requestFocus() {
		listView.requestFocus();
	}
	
	/**
	 * Closes the excess list by removing it from the VBox
	 */
	public void closeList() {
		if (!name.getText().isEmpty()) {
			master.getChildren().clear();
			master.getChildren().add(name);
			isListOpen = false;
			if (isPinnedWindow) {
				if (detailedView.getContent()!=null) {
					master.getChildren().add(detailedView);
				}
			}
		}
	}
	
	/**
	 * Opens up the list view
	 */
	public void openList() {
		if (!isListOpen) {
			master.getChildren().clear();
			if (!name.getText().isEmpty()) { // if name is not empty
				master.getChildren().add(name);
			}
			master.getChildren().add(listView);
			isListOpen = true;
		}
	}
	
	/**
	 * @return true if a selection in the listView already exists 
	 */
	public boolean hasSelection() {
		return !listView.getSelectionModel().isEmpty();
	}
	
	/**
	 * Highlights/Selects the first node in the list
	 */
	public void selectFirstNode() {
		selectNode(0);
	}
	
	/**
	 * Highlights/Selects the node in location i in the list
	 * If i > list size, function does nothing
	 */
	public void selectNode(int i) {
		if (items.size()>i) {
			listView.scrollTo(i);
			listView.getSelectionModel().select(i);
		}
	}
	
	/**
	 * Recalculates the entire TaskList display size
	 */
	public void recalculate() {
		if (!isChanging) {
			isChanging = true;
			int selected = listView.getSelectionModel().getSelectedIndex();
			items.clear();
			for (Task task : listOfTasks) {
				items.add(createMinimisedDisplay(task));
			}
			listView.getSelectionModel().select(selected);
			refresh();
			isChanging = false;
		}
	}
	
	/**
	 * Refreshes the entire TaskList display to the latest version
	 */
	public void refresh() {
		listView.setItems(items);
		if (isPinnedWindow) {
			boolean open = isListOpen;
			focusTask();
			if (open) { // if it was supposed to be open, make sure it ends opened
				openList();
			}
		}
	}
	
	/**
	 * Adds a task to the display
	 * @param task Task to be added
	 */
	public void addTask(Task task) {
		addTask(task, false);
	}
	
	/**
	 * Adds a task to the display
	 * @param task Task to be added
	 * @param refresh If true, display refreshes and the newly added item is selected
	 */
	public void addTask(Task task, boolean refresh) {
		if (task!=null) {
			listOfTasks.add(task);
			items.add(createMinimisedDisplay(task));
			// then change focus to task tab
			
			if (refresh) {
				refresh();
				selectNode(items.size()-1);
			}
		}
	}
	
	/**
	 * 
	 */
	/**
	 * Takes in a list and adds them all to the display
	 * @param tasks List of Tasks to be added
	 * @param newList if true, means old data is deleted
	 */
	public void addAllTasks(List<Task> tasks, boolean newList) {
		int selected = listView.getSelectionModel().getSelectedIndex();
		deleteAllTasks();
		addAllTasks(tasks);
		listView.getSelectionModel().clearAndSelect(selected);
	}
	
	/**
	 * Takes in a list and adds them all to the display
	 * @param tasks list of Tasks to be added
	 */
	public void addAllTasks(List<Task> tasks) {
		if (tasks!=null) {			
			for(Task task : tasks) {
				addTask(task, false);
			}
			refresh();
		}
	}
	
	/**
	 * Deletes all items from the display
	 */
	public void deleteAllTasks() {
		items.clear();
		listOfTasks.clear();
		refresh();
	}
	
	/**
	 * Deletes a specific Task from the display
	 * @param task
	 * @return true if successful deletion
	 */
	public boolean deleteTask(Task task) {
		for (int i=0;i<listOfTasks.size();i++) {
			if (listOfTasks.get(i).equals(task)) {
				listOfTasks.remove(i);
				items.remove(i);
				refresh();
				return true;
			}
		}
		return false;
	}
	
	/**
	 * Clears the detailed window
	 */
	public void clearDetailedWindow() {
		listView.getSelectionModel().clearSelection();
		detailedView.setContent(null); // clear the stored view
	}
	
	/**
	 * Creates a new more detailed object of the highlighted task and adds it to detailedView
	 */
	public void focusTask() {
		int selected = listView.getSelectionModel().getSelectedIndex();
		if (selected>INVALID_SELECTION) {
			// create the detailed view
			detailedView.setContent(createDetailedDisplay(listOfTasks.get(selected)));
			//node.prefHeightProperty().bind(detailedView.heightProperty().subtract(2*PADDING));
		}
	}

	/**
	 * Calls focusTask() in this function
	 * @return the window of the FocusTask
	 */
	public ScrollPane getFocusTask() {
		focusTask();
		return detailedView;
	}
	
	/**
	 * Create a focused view that shows all details of the task 
	 * @param task Task to take information from
	 * @return VBox with Name and ID
	 *///*// old version using the arraylist from Logic
	public static GridPane createDetailedDisplay(Task task) {
		// Create an object ot return and set its borders/constraints
		GridPane grid = new GridPane();
	    grid.getColumnConstraints().add(new ColumnConstraints(GRID_COL_HEADER_FINAL_LENGTH)); 
		grid.setPadding(new Insets(0, PADDING, 0, 0)); // set some buffer to the right
		
		// ID content
		Label id = createLabel(Integer.toString(task.getId()));
		id.setPadding(new Insets(0,PADDING,0,PADDING));
		id.getStyleClass().add(getTaskStyle(task.getTaskType())); // set colour based on type
		grid.add(id, SIDEBAR_COL_ID, ROW_NAME);
		
		// Set name
		Label name = createLabel(task.getName());
		name.prefWidthProperty().bind(grid.widthProperty());
		name.setWrapText(true);
		name.setStyle("-fx-font-weight: bold");
		grid.add(name, SIDEBAR_COL_NAME, ROW_NAME, 2, 1);

		// add whether completed
		grid.add(getTaskCompletion(task.getIsCompleted()), SIDEBAR_COL_DONE, ROW_NAME); // only need up to 1 row
		
		// Get the details from task details and display them
		ArrayList<String[]> details = task.getTaskDetails();
		String[] array;
		Label label = null;
		for (int i=1;i<details.size();i++) { // i=1 to skip name element
			array = details.get(i);
			label = createLabel(array[COL_HEADER]);
			grid.add(label, COL_HEADER, i);
			GridPane.setValignment(label, GRID_HEADER_VERT_ALIGNMENT);

			label = createLabel(array[COL_CONTENT]);
			if (label.getText()==null||label.getText().trim().isEmpty()) {
				label.setText("None");
			}
			grid.add(label, COL_CONTENT, i, COL_CONTENT_SIZE, 1);
		}
		
		// lock the maximum height
		grid.maxHeightProperty().bind(name.heightProperty().add(label.heightProperty().multiply(details.size()+10)));
		
		return grid;
	}//*/
	
	/**
	 * 
	 * @param task Task to take information from
	 * @return GridPane with ID, Name, (Date, if available), Done/NotDone
	 */
	protected GridPane createMinimisedDisplay(Task task) {
		GridPane grid = new GridPane();
		grid.prefWidthProperty().bind(listView.widthProperty().subtract(100));
		grid.getColumnConstraints().add(new ColumnConstraints(GRID_COL_HEADER_FINAL_LENGTH));
		
		// ID content
		Label id = createLabel(Integer.toString(task.getId()));
		id.setPadding(new Insets(0,PADDING,0,PADDING));
		id.getStyleClass().add(getTaskStyle(task.getTaskType())); // set colour based on type
		grid.add(id, SIDEBAR_COL_ID, ROW_NAME);
		
		// Wrap the later content in a HBox
		HBox header = new HBox();
		header.prefWidthProperty().bind(grid.widthProperty().
				subtract(GRID_COL_HEADER_FINAL_LENGTH).subtract(IMAGE_SIZE));
		header.setAlignment(Pos.CENTER_LEFT);
		grid.add(header, SIDEBAR_COL_NAME, ROW_NAME, 2, 1); // span 2 col and 1 row
		
		// Set name
		Label label = createLabel(task.getName());
		label.prefWidthProperty().bind(header.widthProperty());
		label.setWrapText(false);
		header.getChildren().add(label);
		HBox.setHgrow(label, Priority.ALWAYS);
		
		// set date if exists
		try {
			try {
				// Try to check for Event first, since Event is Deadline's child
				label = createLabel(format.format(((Event) task).getStart().getTime()));
			} catch (ClassCastException e) {
				// if fail to cast to Event, try DeadlineTask
				label = createLabel(format.format(((DeadlineTask) task).getEnd().getTime()));
			}
			// if any of them are successful, carry on adding to header
			label.setWrapText(false);
			label.setPadding(new Insets(0, 0, 0, PADDING));
			label.setMaxWidth(DATE_WIDTH);
			HBox.setHgrow(label, Priority.SOMETIMES);
			label.prefWidthProperty().bind(header.widthProperty());
			header.getChildren().add(label);
		} catch (ClassCastException e) {
			// else do nothing
		} catch (Exception e) {
			// if it is not a class cast exception, something else went wrong
			e.printStackTrace();
		}
		
		// add whether completed
		grid.add(getTaskCompletion(task.getIsCompleted()), SIDEBAR_COL_DONE, ROW_NAME);
		
		return grid;
	}
	
	/**
	 * Returns the tick or cross depending on whether task is done
	 * @param isCompleted Whether the task is completed or not
	 * @return ImageView of a tick or cross
	 */
	public static ImageView getTaskCompletion(boolean isCompleted) {
		if (isCompleted) {
			return new ImageView(imageCompletion[1]); 
		} else {
			return new ImageView(imageCompletion[0]);
		}
	}
	
	/**
	 * Creates a label that has required settings built in
	 * @return a Label that has wrapText and width properties ready
	 */
	protected Label createLabel() {
		return createLabel("");
	}
	
	/**
	 * Creates a label has required settings built in with string Text inside
	 * @param text Text to be added
	 * @return a Label that has wrapText and width properties ready
	 */
	protected static Label createLabel(String text) {
		Label label = new Label(text);
		label.setWrapText(true);
		label.setTextFill(COLOR_LABEL);
		return label;
	}
	
	/**
	 * Returns true if the list is empty
	 */
	public boolean isListEmpty() {
		return listSize==0;
	}
	
	/**
	 * Return colour of TaskType
	 * @param type
	 * @return colour style string
	 */
	protected static String getTaskStyle(TaskType type) {
		switch(type) {
		case FLOATING_TASK:
			return STYLE_FLOATING;
		case DEADLINE_TASK:
			return STYLE_DEADLINE;
		case EVENT:
			return STYLE_EVENT;
		default:
			return "";
		}
	}
}
```
###### test\GUIShortcutTests.java
``` java
public class GUIShortcutTests {
	boolean isShiftDown = false;
	boolean isControlDown = false;
	boolean isAltDown = false;
	KeyEvent keyEvent = null;

	@Test
	public void focusModeTest01() {
		// BACK_SLASH (\) only
		keyEvent = new KeyEvent(null, null, null, KeyCode.BACK_SLASH,
				isShiftDown, isControlDown, isAltDown, false);
		assertEquals(CommandType.FOCUS_MODE,
				ShortcutManager.processKeyEvent(keyEvent));
	}

	@Test
	public void focusModeTest02() {
		// Ctrl + BACK_SLASH (\) only
		isControlDown = true;
		keyEvent = new KeyEvent(null, null, null, KeyCode.BACK_SLASH,
				isShiftDown, isControlDown, isAltDown, false);
		assertEquals(CommandType.FOCUS_MODE,
				ShortcutManager.processKeyEvent(keyEvent));
	}

	@Test
	public void focusModeClearTest01() {
		// BACK_SPACE only
		keyEvent = new KeyEvent(null, null, null, KeyCode.BACK_SPACE,
				isShiftDown, isControlDown, isAltDown, false);
		assertEquals(CommandType.FOCUS_MODE_CLEAR,
				ShortcutManager.processKeyEvent(keyEvent));
	}

	@Test
	public void focusModeClearTest02() {
		// Shift + BACK_SLASH (\) only
		isShiftDown = true;
		keyEvent = new KeyEvent(null, null, null, KeyCode.BACK_SLASH,
				isShiftDown, isControlDown, isAltDown, false);
		assertEquals(CommandType.FOCUS_MODE_CLEAR,
				ShortcutManager.processKeyEvent(keyEvent));
	}

	@Test
	public void helpTest01() {
		// F1 only
		keyEvent = new KeyEvent(null, null, null, KeyCode.F1, isShiftDown,
				isControlDown, isAltDown, false);
		assertEquals(CommandType.HELP,
				ShortcutManager.processKeyEvent(keyEvent));
	}

	@Test
	public void searchTest01() {
		// Ctrl + F only
		isControlDown = true;
		keyEvent = new KeyEvent(null, null, null, KeyCode.F, isShiftDown,
				isControlDown, isAltDown, false);
		assertEquals(CommandType.SEARCH,
				ShortcutManager.processKeyEvent(keyEvent));
	}

	@Test
	public void switchTest01() {
		// Alt + T only
		isAltDown = true;
		keyEvent = new KeyEvent(null, null, null, KeyCode.T, isShiftDown,
				isControlDown, isAltDown, false);
		assertEquals(CommandType.SWITCH,
				ShortcutManager.processKeyEvent(keyEvent));
	}

	@Test
	public void inputFieldTest01() {
		// Ctrl + T only
		isControlDown = true;
		keyEvent = new KeyEvent(null, null, null, KeyCode.T, isShiftDown,
				isControlDown, isAltDown, false);
		assertEquals(CommandType.INPUT_FIELD,
				ShortcutManager.processKeyEvent(keyEvent));
	}

	@Test
	public void undoTest01() {
		// Ctrl + Z only
		isControlDown = true;
		keyEvent = new KeyEvent(null, null, null, KeyCode.Z, isShiftDown,
				isControlDown, isAltDown, false);
		assertEquals(CommandType.UNDO,
				ShortcutManager.processKeyEvent(keyEvent));
	}

	@Test
	public void unpinTest01() {
		// Ctrl + U only
		isControlDown = true;
		keyEvent = new KeyEvent(null, null, null, KeyCode.U, isShiftDown,
				isControlDown, isAltDown, false);
		assertEquals(CommandType.UNPIN,
				ShortcutManager.processKeyEvent(keyEvent));
	}
}
```
