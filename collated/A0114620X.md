# A0114620X
###### parser\AddParser.java
``` java
package parser;

import java.util.ArrayList;
import java.util.Calendar;

public class AddParser extends InputParser {

	ParsedCommand parse(String[] input) {
		if (isMissingArguments(input)) {
			return createParsedCommandError(ERROR_MISSING_ARGS);
		} else {
			String inputArgs = input[INDEX_FOR_ARGS];
			
			try {
				String parsedTitle = getTitleWithKeywordsFromString(inputArgs);
				Calendar[] parsedTimes = getDatesTimesFromString(inputArgs);
				if (parsedTimes != null && parsedTimes.length > 2) { // date keyword used for date input
					parsedTitle = removeKeywordSection(parsedTitle);
				}
				String parsedDescription = getDescriptionFromString(inputArgs);
				ArrayList<String> parsedTags = getTagsFromString(inputArgs);
				
				ParsedCommand pc = new ParsedCommand.Builder(MyParser.CommandType.ADD)
													.title(parsedTitle)
													.times(parsedTimes)
													.description(parsedDescription)
													.tags(parsedTags)
													.build();
				return pc;
			} catch (InvalidArgumentsForParsedCommandException e) {
				return InputParser.createParsedCommandError(e.getMessage());
			}
		}
	}
	
}
```
###### parser\CloseParser.java
``` java
package parser;

import parser.MyParser.CommandType;

public class CloseParser extends GuiParser {

	ParsedCommand parse(String[] input) {
		return createParsedCommandGuiTabAction(CommandType.GUI_CLOSE, input);
	}

}
```
###### parser\ConfigParser.java
``` java
package parser;

import parser.MyParser.CommandType;
import parser.ParsedCommand.ConfigType;

public class ConfigParser extends InputParser {

	ParsedCommand parse(String[] input) {
		if (isMissingArguments(input)) {
			return createParsedCommandError(ERROR_MISSING_ARGS);
		} else {
			String[] subInput = input[INDEX_FOR_ARGS].split(" ", 2);
			String subCommand = subInput[INDEX_FOR_SUBCMD];
			if (subCommand.equalsIgnoreCase("folder")) {
				return createParsedCommandConfigData(subInput);
			} else {
				return createParsedCommandConfigImg(subInput);
			}
		}
	}

	static ParsedCommand createParsedCommandConfigImg(String[] input) {
		ConfigType configType = determineConfigImgType(input[INDEX_FOR_SUBCMD]);
		if (configType != ConfigType.INVALID) {
			if (isMissingArguments(input)) {
				return createParsedCommandError(ERROR_MISSING_ARGS);
			}
			try {
				String fileName = input[INDEX_FOR_SUBARGS];
				ParsedCommand pc = new ParsedCommand.Builder(CommandType.CONFIG_IMG)
													.configType(configType)
													.configPath(fileName)
													.build();
				return pc;
			} catch (InvalidArgumentsForParsedCommandException e) {
				return createParsedCommandError(e.getMessage());
			}
		} else {
			return InputParser.createParsedCommandError(InputParser.ERROR_INVALID_COMMAND);
		}
	}

	static ParsedCommand createParsedCommandConfigData(String[] input) {
		if (isMissingArguments(input)) { 
			return createParsedCommandError(ERROR_MISSING_ARGS);
		} else {
			try {
				String fileName = input[INDEX_FOR_SUBARGS];
				ParsedCommand pc = new ParsedCommand.Builder(MyParser.CommandType.CONFIG_DATA)
						  			  				.configPath(fileName)
						  			  				.build();
				return pc;
			} catch (InvalidArgumentsForParsedCommandException e){
				return createParsedCommandError(e.getMessage());
			}
		}
	}

	static ParsedCommand.ConfigType determineConfigImgType(String subCommand) {
		if (subCommand.equalsIgnoreCase("background")) {
			return ParsedCommand.ConfigType.BACKGROUND;
		} else if (subCommand.equalsIgnoreCase("avatar")) {
			return ParsedCommand.ConfigType.AVATAR;
		} else {
			return ParsedCommand.ConfigType.INVALID;
		}
	}

}
```
###### parser\DateTimeParser.java
``` java
package parser;

import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public abstract class DateTimeParser {
	private static final String DEFAULT_TWENTYFOUR_HOUR_TIME = "23:59";
	private static final String DEFAULT_TWELVE_HR__TIME = "11:59pm";
	private static final int INDEX_FOR_END = 1;
	private static final int INDEX_FOR_START = 0;
	private static final int INDEX_FOR_TIME_FORMAT = 2;
	private static final int INDEX_FOR_DATE_FORMAT = 2;
	static String DATE_KEYWORD_REGEX = "(?<=\\s|^)(on|by)\\s(?!.*( on | by ))([^\"#]*)";
	private static Pattern DATE_KEYWORD_PATTERN = Pattern.compile(DATE_KEYWORD_REGEX);
	
	private static String TAG_OR_DESCRIPTION_REGEX = "(" + StringParser.TAG_REGEX + "|" + StringParser.DESCRIPTION_REGEX + ")";  	                                        
	private static String CHECK_NON_NATTY_DATE_TIME_REGEX = "(" + FormattedDateTimeParser.FORMATTED_DATE_REGEX + "|" + FlexibleDateTimeParser.FLEXIBLE_DATE_REGEX + "|((?<=\\s|^)(tmr|tomorrow|tomorow)(?=\\s|$)))";
	private static Pattern CHECK_NON_NATTY_DATE_TIME_PATTERN = Pattern.compile(CHECK_NON_NATTY_DATE_TIME_REGEX);
	
	private static String NON_NATTY_DATE_TIME_REGEX = "(" + TimeParser.TIME_REGEX + "|" + FormattedDateTimeParser.FORMATTED_DATE_REGEX + "|" + FlexibleDateTimeParser.FLEXIBLE_DATE_REGEX + "|((?<=\\s|^)(tmr|tomorrow|tomorow)(?=\\s|$)))";
	private static Pattern NON_NATTY_DATE_OR_TIME_PATTERN = Pattern.compile(NON_NATTY_DATE_TIME_REGEX);

	static String DATE_TIME_REGEX = "(" + TimeParser.TIME_REGEX + "|" + FormattedDateTimeParser.FORMATTED_DATE_REGEX + "|" + FlexibleDateTimeParser.FLEXIBLE_DATE_REGEX + "|" + DATE_KEYWORD_REGEX + "|((?<=\\s|^)(tmr|tomorrow|tomorow)(?=\\s|$)))";
	static String NO_KEYWORD_DATE_TIME_REGEX = "(" + TimeParser.TIME_REGEX + "|" + FormattedDateTimeParser.FORMATTED_DATE_REGEX + "|" + FlexibleDateTimeParser.FLEXIBLE_DATE_REGEX + "|((?<=\\s|^)(tmr|tomorrow|tomorow)(?=\\s|$)))";
	
	protected DateTimeParser nextParser;
	
	abstract String getUnparsedInput();
	abstract String[] getParsedTimes();
	abstract String[] getParsedDates();

	abstract protected Calendar[] parse(String input, String[] parsedDates, String[] parsedTimes);

	private static final Logger logger = Logger.getLogger(DateTimeParser.class.getName() );
	
	public static String extractDateTimeSectionFromString(String input) {
		String extract = removeTagsAndDescriptions(input); // for formatted input
		if (hasNonNattyDateTimeSection(extract)) { 
			String nonNattyDateTime = extractNonNattyDateTimeSection(extract);
			logger.log(Level.FINE, "FORMATTED/FLEX: " + nonNattyDateTime);
			return nonNattyDateTime;
		} else {
			String keywordDateSection = extractSectionAfterDateKeyword(extract);
			logger.log(Level.FINE, "KEYWORD:" + keywordDateSection + ",");
			return keywordDateSection;
		}
	}
		
	private static String removeTagsAndDescriptions(String input) {
		return InputParser.removeRegexPatternFromString(input, TAG_OR_DESCRIPTION_REGEX);
	}
	
	private static Boolean hasNonNattyDateTimeSection(String input) {
		Matcher m = CHECK_NON_NATTY_DATE_TIME_PATTERN.matcher(input);
		
		if (m.find()) {
			return true;
		}
		
		return false;
	}
	
	private static String extractNonNattyDateTimeSection(String input) {
		Matcher m = NON_NATTY_DATE_OR_TIME_PATTERN.matcher(input);
		String dateSection = "";

		while (m.find()) {
			dateSection = dateSection + m.group() + " ";
		}
		
		logger.log(Level.FINE, "DATESECTION:" + dateSection.trim() + ".");
		return dateSection.trim();
	}
	
	private static String extractSectionAfterDateKeyword(String input) {
		Matcher m = DATE_KEYWORD_PATTERN.matcher(input);
		String dateSection = "";

		if (m.find()) {
			dateSection = m.group(3);
		}
		return dateSection.trim();
	}
		
	public void setNextParser(DateTimeParser nextParser) {
		this.nextParser = nextParser;
	}
	
	public Calendar[] getDatesTimes(String input, String[] parsedDates, String[] parsedTimes) {
		Calendar[] datesTimes = new Calendar[2];
		datesTimes = parse(input, parsedDates, parsedTimes);
		if (datesTimes == null) { // error
			return null;
		} else if (datesTimes[0] == null) { // not detected
			if (nextParser != null) {
				return nextParser.getDatesTimes(getUnparsedInput(), getParsedDates(), getParsedTimes());
			}
		}
		return datesTimes;
	}
	
		
	public static Calendar[] convertStringToCalendar(String[] dates, String[] times) {
		Calendar[] calTimes = new Calendar[2];
		Calendar startCal = Calendar.getInstance();
		Calendar endCal = Calendar.getInstance();
		String dateFormat = dates[INDEX_FOR_DATE_FORMAT];
		String timeFormat = times[INDEX_FOR_TIME_FORMAT];
		SimpleDateFormat dateTimeFormat = new SimpleDateFormat(dateFormat + " " + timeFormat);
		
		try {
			if (dates[INDEX_FOR_START] == null) { // no date and time
				startCal = null;
				endCal = null;
			} else { // has start date
				dateTimeFormat.setLenient(false);
				if (times[INDEX_FOR_START] == null) { // no start time, assume deadline 2359h
					String startDate = dates[INDEX_FOR_START] + " ";
					startDate = addDefaultTime(timeFormat, startDate);
					startCal.setTime(dateTimeFormat.parse(startDate));
				} else { // has start date and time
					String startDateTime = dates[INDEX_FOR_START] + " " + times[INDEX_FOR_START];
					startCal.setTime(dateTimeFormat.parse(startDateTime));
				}
				
				if (dates[INDEX_FOR_END] != null) { // has end date
					if (times[INDEX_FOR_END] == null) { // no end time, assume deadline 2359h
						String endDate = dates[INDEX_FOR_END] + " ";
						endDate = addDefaultTime(timeFormat, endDate);
						endCal.setTime(dateTimeFormat.parse(endDate));
					} else { // has end date and time
						String endDateTime = dates[INDEX_FOR_END] + " " + times[INDEX_FOR_END];
						endCal.setTime(dateTimeFormat.parse(endDateTime));
					}	
				} else { // no end date
					if (times[INDEX_FOR_END] != null) { // but has end time
						String endDateTime = dates[INDEX_FOR_START] + " " + times[INDEX_FOR_END]; // end date same as start date
						endCal.setTime(dateTimeFormat.parse(endDateTime));
					} else { // no end date and no end time
						endCal = null;
					}
				}
			}
		} catch (java.text.ParseException e) {
			e.printStackTrace();
			return null; // failed to parse
		}
		
		calTimes[0] = startCal;
		calTimes[1] = endCal;

		return calTimes;
	}
	
	private static String addDefaultTime(String timeFormat, String endDate) {
		if (timeFormat.equals(TimeParser.TWELVE_HR_FORMAT)) {
			endDate = endDate + DEFAULT_TWELVE_HR__TIME;
		} else {
			endDate = endDate + DEFAULT_TWENTYFOUR_HOUR_TIME;
		}
		return endDate;
	}
}
```
###### parser\DeleteParser.java
``` java
public class DeleteParser extends InputParser {

	ParsedCommand parse(String[] input) {
		if (isMissingArguments(input)) {
			return createParsedCommandError(ERROR_MISSING_ARGS);
		} else {
			try {
				String inputArgs = input[INDEX_FOR_ARGS].trim();
				int taskId = getTaskIdFromString(inputArgs);
				ParsedCommand pc = new ParsedCommand.Builder(MyParser.CommandType.DELETE)
													.taskId(taskId)
													.build();
				return pc;
			} catch (InvalidArgumentsForParsedCommandException e) {
				return InputParser.createParsedCommandError(e.getMessage());
			}
		}
	}
}
```
###### parser\DoneParser.java
``` java
package parser;

public class DoneParser extends FlagParser {
	ParsedCommand parse(String[] input) {
		return createParsedCommandDone(input);
	}
}
```
###### parser\EditParser.java
``` java
package parser;

import java.util.ArrayList;
import java.util.Calendar;

public class EditParser extends InputParser {

	ParsedCommand parse(String[] input) {
		if (isMissingArguments(input)) {
			return InputParser.createParsedCommandError(ERROR_MISSING_ARGS);
		} else {
			String inputArgs[] = input[INDEX_FOR_ARGS].split(" ", 2);
			if (isMissingArguments(inputArgs)) {
				return InputParser.createParsedCommandError(ERROR_MISSING_FIELDS);
			} else {
				try {
					String task = inputArgs[0];
					String changes = inputArgs[1];
					int parsedTaskId = getTaskIdFromString(task);
					String parsedTitle = getTitleFromString(changes);
					Calendar[] parsedTimes = getDatesTimesFromString(changes);
					String parsedDescription = getDescriptionFromString(changes);
					ArrayList<String> parsedTags = getTagsFromString(changes);
				
					ParsedCommand pc = new ParsedCommand.Builder(MyParser.CommandType.EDIT)
														.taskId(parsedTaskId)
														.title(parsedTitle)
														.times(parsedTimes)
														.description(parsedDescription)
														.tags(parsedTags)
														.build();
					return pc;
				} catch (InvalidArgumentsForParsedCommandException e) {
					return InputParser.createParsedCommandError(e.getMessage());
				}
			}
		}
	}

}
```
###### parser\FlagParser.java
``` java

package parser;

public class FlagParser extends InputParser {

	ParsedCommand parse(String[] input) {
		if (isMissingArguments(input)) {
			return createParsedCommandError(ERROR_MISSING_ARGS);
		} else {
			String[] subInput = input[INDEX_FOR_ARGS].split(" ");
			String subCommand = subInput[INDEX_FOR_SUBCMD];
			if (subCommand.equalsIgnoreCase("todo")) {
				return createParsedCommandTodo(subInput);
			} else if (subCommand.equalsIgnoreCase("done") || subCommand.equalsIgnoreCase("completed")) {
				return createParsedCommandDone(subInput);
			} else {
				return createParsedCommandError(InputParser.ERROR_INVALID_COMMAND);
			}
		}
	}

	private static ParsedCommand createParsedCommandFlagTaskStatus(String[] input, Boolean status) {
		if (isMissingArguments(input)) {
			return InputParser.createParsedCommandError(ERROR_MISSING_ARGS);
		} else {
			String inputArgs = input[INDEX_FOR_ARGS].trim();
			try {
				int taskId = getTaskIdFromString(inputArgs);
				ParsedCommand pc = new ParsedCommand.Builder(MyParser.CommandType.FLAG)
													.taskId(taskId)
													.isCompleted(status)
													.build();
				return pc;
			} catch (InvalidArgumentsForParsedCommandException e) {
				return InputParser.createParsedCommandError(e.getMessage());
			}
		}
	}

	static ParsedCommand createParsedCommandDone(String[] input) {
		return createParsedCommandFlagTaskStatus(input, true);
	}

	static ParsedCommand createParsedCommandTodo(String[] input) {
		return createParsedCommandFlagTaskStatus(input, false);
	}

}
```
###### parser\FlexibleDateTimeParser.java
``` java

package parser;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.time.LocalDate;
import java.time.ZoneId;
import java.util.Calendar;
import java.util.Date;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class FlexibleDateTimeParser extends DateTimeParser {
	private String[] flexibleDates;
	private String[] flexibleTimes;
	private String unparsedInput;
	
	private enum DateFormat {
		DATE_MONTH, MONTH_DATE;
	}
	
	private static final String CURRENT_YEAR = String.valueOf(Calendar.getInstance().get(Calendar.YEAR));
	
	private static final String MONTHS = "(jan(?:uary)?|feb(?:ruary)?|mar(?:ch)?|apr(?:il)?|may|jun(?:e)?|jul(?:y)?|aug(?:ust)?|sep(?:tember)?|oct(?:ober)?|nov(?:ember)?|dec(?:ember)?)";
	private static final String DATES = "(\\d?\\d)(?:st|rd|nd|th)?";
	private static final String YEARS = "(\\d{4})?";
	
	private static final String DATE_MONTH_REGEX = "(?<=\\s|^)" + DATES + "\\s" + MONTHS + ",?\\s?" + YEARS + "(?=\\s|$)";
	private static final String MONTH_DATE_REGEX = "(?<=\\s|^)" + MONTHS + "\\s" + DATES + ",?\\s?" + YEARS + "(?=\\s|$)";
	
	private static final Pattern DMMM = Pattern.compile(DATE_MONTH_REGEX);
	private static final Pattern MMMD = Pattern.compile(MONTH_DATE_REGEX);
	
	private static final String STANDARD_FLEXIBLE_DATE_FORMAT = "d MMM yyyy";
	
	protected static final String FLEXIBLE_DATE_REGEX = "(" + DATE_MONTH_REGEX + "|" + MONTH_DATE_REGEX + ")";
	
	private static final int INDEX_FOR_DATE_ARR = 0;
	private static final int INDEX_FOR_MONTH_ARR = 1;
	private static final int INDEX_FOR_YEAR_ARR = 2;
	
	private static final int DM_INDEX_FOR_DATE = 1;
	private static final int DM_INDEX_FOR_MONTH = 2;
	private static final int DM_INDEX_FOR_YEAR = 3;
	
	private static final int MD_INDEX_FOR_DATE = 2;
	private static final int MD_INDEX_FOR_MONTH = 1;
	private static final int MD_INDEX_FOR_YEAR = 3;
	
	private static final int INDEX_FOR_START = 0;
	private static final int INDEX_FOR_END = 1;
	
	private static final int[] DM_INDICES = {DM_INDEX_FOR_DATE, DM_INDEX_FOR_MONTH, DM_INDEX_FOR_YEAR};
	private static final int[] MD_INDICES = {MD_INDEX_FOR_DATE, MD_INDEX_FOR_MONTH, MD_INDEX_FOR_YEAR};
	
	private static final Logger logger = Logger.getLogger(FlexibleDateTimeParser.class.getName() );
	
	private static String[] getDateMonthFromString(String input) {
		String[][] temp = parseStringToDateArray(input, DateFormat.DATE_MONTH);
		String[] dateArr = convertDateArrayToStdForm(temp);
		setDateFormatToFlexDateFormat(dateArr);
		setUnparsedInput(DateFormat.DATE_MONTH, input, dateArr);
		// System.out.println(dateArr[0]);
		// System.out.println(dateArr[1]);
		logger.log(Level.FINE, "DM start: " + dateArr[0] + " end: " + dateArr[1] + " format: " + dateArr[2] + " unparsed: " + dateArr[3]);
		return dateArr;
	}

	private static String[] getMonthDateFromString(String input) {
		String[][] tempDateArr = parseStringToDateArray(input, DateFormat.MONTH_DATE);
		String[] dateArr = convertDateArrayToStdForm(tempDateArr);
		setDateFormatToFlexDateFormat(dateArr);
		setUnparsedInput(DateFormat.MONTH_DATE, input, dateArr);
		// System.out.println(dateArr[0]);
		// System.out.println(dateArr[1]);
		logger.log(Level.FINE, "MD start: " + dateArr[0] + " end: " + dateArr[1] + " format: " + dateArr[2] + " unparsed: " + dateArr[3]);		
		return dateArr;
	}

	
	private static void updateDateArray(String[][] temp, int i, String date, String month, String year) {
		temp[i][INDEX_FOR_DATE_ARR] = date;
		temp[i][INDEX_FOR_MONTH_ARR] = month.substring(0,3);
		temp[i][INDEX_FOR_YEAR_ARR] = year;
	}

	private static String[] convertDateArrayToStdForm(String[][] temp) {
		String[] dateArr = new String[4];
		if (temp[INDEX_FOR_START][INDEX_FOR_DATE_ARR] == null) { // has no start date
			setStartAndEndDate(dateArr, null, null);
		} else { // flexible date detected
			String startDate = dateArrToStdString(temp, INDEX_FOR_START); // standard flexible date
			String endDate;
			if (temp[INDEX_FOR_END][INDEX_FOR_DATE_ARR] == null) { // no end date detected
				endDate = null;
			} else {
				endDate = dateArrToStdString(temp, INDEX_FOR_END);		
			}
			setStartAndEndDate(dateArr, startDate, endDate);
		}
		return dateArr;
	}

	private static void setStartAndEndDate(String[] dateArr, String startDate, String endDate) {
		dateArr[INDEX_FOR_START] = startDate;
		dateArr[INDEX_FOR_END] = endDate;
	}

	private static String dateArrToStdString(String[][] temp, int dateIndex) {
		return temp[dateIndex][INDEX_FOR_DATE_ARR] + " " + temp[dateIndex][INDEX_FOR_MONTH_ARR] + " " 
				+ temp[dateIndex][INDEX_FOR_YEAR_ARR];
	}
	
	private static void setYears(String[][] temp) {
		if (temp[INDEX_FOR_END][INDEX_FOR_YEAR_ARR] != null) { // has year
			if (temp[INDEX_FOR_START][INDEX_FOR_YEAR_ARR] == null) { // start date has no year
				temp[INDEX_FOR_START][INDEX_FOR_YEAR_ARR] = temp[INDEX_FOR_END][INDEX_FOR_YEAR_ARR]; // set start year = end year
			}
		} else { // end date has no year
			if (temp[INDEX_FOR_START][INDEX_FOR_YEAR_ARR] != null) { // start date has year
				temp[INDEX_FOR_END][INDEX_FOR_YEAR_ARR] = temp[INDEX_FOR_START][INDEX_FOR_YEAR_ARR]; // set end year = start year
			} else {
				setNextValidYear(temp[INDEX_FOR_END]);
				setNextValidYear(temp[INDEX_FOR_START]); 
			}			
		}
	}
		
	private static void setNextValidYear(String[] date) {
		LocalDate today = LocalDate.now();
		String newDateString = CURRENT_YEAR + "-" + date[INDEX_FOR_MONTH_ARR] + "-" + date[INDEX_FOR_DATE_ARR];
		// System.out.println("Before formatting year: " + newDateString + ".");
		SimpleDateFormat format = new SimpleDateFormat("yyyy-MMM-d"); //LocalDate.parse() MMM case sensitive??!
	    try {
			Date tempDate = format.parse(newDateString);
		    LocalDate newDate = tempDate.toInstant().atZone(ZoneId.systemDefault()).toLocalDate();
			if (newDate.isAfter(today)) {
				date[INDEX_FOR_YEAR_ARR] = CURRENT_YEAR;
			} else {
				date[INDEX_FOR_YEAR_ARR] = String.valueOf(today.getYear() + 1);
			}
		} catch (ParseException e){
			date = null;
		}
	}

	private static String[][] parseStringToDateArray(String input, DateFormat df) {
		input = input.toLowerCase();
		String[][] temp = new String[2][3];
		Matcher m;
		int[] dmyIndices;
		
		if (df == DateFormat.MONTH_DATE) {
			m = MMMD.matcher(input);
			dmyIndices = MD_INDICES;
		} else if (df == DateFormat.DATE_MONTH) {
			m = DMMM.matcher(input);
			dmyIndices = DM_INDICES;
		} else {
			return null;
		}
		
		int i = 0;
		while (m.find() & i < 2) {
			String date = m.group(dmyIndices[INDEX_FOR_DATE_ARR]);
			String month = m.group(dmyIndices[INDEX_FOR_MONTH_ARR]);
			String year = m.group(dmyIndices[INDEX_FOR_YEAR_ARR]);
			updateDateArray(temp, i, date, month, year);
			i++;
		}
		setYears(temp);
		return temp;
	}

	// double direction dependency!
	private static String removeDateMonthFromString(String input) {
		return InputParser.removeRegexPatternFromString(input, DATE_MONTH_REGEX);
	}
	
	private static String removeMonthDateFromString(String input) {
		return InputParser.removeRegexPatternFromString(input, MONTH_DATE_REGEX);
	}
	
	private static void setUnparsedInput(DateFormat df, String input, String[] dateArr) {
		if (df == DateFormat.MONTH_DATE) {
			dateArr[3] = removeMonthDateFromString(input);
		} else if (df == DateFormat.DATE_MONTH) {
			dateArr[3] = removeDateMonthFromString(input);
		}
	}
	
	private static void setDateFormatToFlexDateFormat(String[] dateArr) {
		dateArr[2] = STANDARD_FLEXIBLE_DATE_FORMAT;
	}


	@Override
	protected String[] getParsedDates() {
		return flexibleDates;
	}
	
	@Override
	protected String[] getParsedTimes() {
		return flexibleTimes;
	}
	
	@Override
	protected String getUnparsedInput() {
		return unparsedInput;
	}
	
	@Override
	protected Calendar[] parse(String input, String[] parsedDates, String[] parsedTimes) {
		flexibleTimes = parsedTimes; // all time parsing done previously
		flexibleDates = getStandardFlexibleDates(input);
		unparsedInput = flexibleDates[3];
		return convertStringToCalendar(flexibleDates, flexibleTimes);
	}

	public static String[] getStandardFlexibleDates(String input) {
		String[] dates = new String[4];
		dates = getMonthDateFromString(input);
		if (dates[INDEX_FOR_START] == null) { // no MMM d detected
			dates = getDateMonthFromString(input);
		}
		dates[2] = STANDARD_FLEXIBLE_DATE_FORMAT;
		return dates;
	}
	
	
}
```
###### parser\FormattedDateTimeParser.java
``` java

package parser;

import java.text.SimpleDateFormat;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.time.format.DateTimeParseException;
import java.util.Calendar;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class FormattedDateTimeParser extends DateTimeParser{
	
	private static final int INDEX_FOR_START = 0;
	private static final String DELIM = "-/.";
	static final String START = "(?<=^|\\s)";
	static final String END = "(?=\\s|$)";
	static final String DD = "([0-9]?[0-9])";
	static final String MM = "([0-9]?[0-9])";
	static final String DATE_DELIM = "[" + DELIM + "]";
	static final String YY = "(\\d{4}|\\d{2})";
	static final String NO_YEAR_FORMATTED_DATE_REGEX = START + DD + "[-/]" + MM + END;
	static final String FORMATTED_DATE_REGEX = START + DD + DATE_DELIM + MM + DATE_DELIM + YY + END;
	static final String FORMATTED_DATE_FORMAT = "d/M/yy";
	
	private static final int INDEX_FOR_DATE_INPUT = 1;
	private static final int INDEX_FOR_MONTH_INPUT = 2;
	private static final int INDEX_FOR_YEAR_INPUT = 3;
	private static final int INDEX_FOR_DATE_ARR = 0;
	private static final int INDEX_FOR_MONTH_ARR = 1;
	private static final int INDEX_FOR_YEAR_ARR = 2;
	
	private static Pattern ddmmyy = Pattern.compile(FORMATTED_DATE_REGEX);
	private static Pattern ddmm = Pattern.compile(NO_YEAR_FORMATTED_DATE_REGEX);
	
	private String[] formattedTimes;
	private String[] formattedDates;
	private String unparsedInput;

	private static final Logger logger = Logger.getLogger(FormattedDateTimeParser.class.getName() );

	private static String convertDateToStandardFormat(String[] dateArr) {
		String date = dateArr[INDEX_FOR_DATE_ARR];
		if (date == null) {
			return null;
		}
		String month = dateArr[INDEX_FOR_MONTH_ARR];
		String year = dateArr[INDEX_FOR_YEAR_ARR];
		
		return date + "/" + month + "/" + year;
	}
	
	private static String convertYearToStandardFormat(String year) {
		if (year == null) {
			return null;
		} else if (year.length() < 4) {
			year = "20" + year;
		} else {
			return year;
		}
		return year;
	}
	
	public static String[] getStandardFormattedDates(String input) {
		String[][] dates = getStandardFormattedDatesWithYear(input);
		if (dates[INDEX_FOR_START][0] == null) {
			dates = getStandardFormattedDatesNoYear(input);
		}
		return processFormattedDates(input, dates);
	}
	/**
	 * This method looks for dd/mm/yy or dd.mm.yy or dd-mm-yy) substrings of userInput, single digit
	 * inputs allowed for date and month and returns dates formated dd/MM/yy.
	 *
	 * @param userInput
	 *            Unparsed command arguments input by user.
	 * @return String array where ans[0] = first date found (if any) and ans[1]
	 *         = second date found (if any), If no dates are found, ans[0] =
	 *         ans[1] = null and if only one date found, ans[1] = null.
	 */
	public static String[][] getStandardFormattedDatesWithYear(String userInput) {
		return getFormattedDates(userInput, ddmmyy);
	}

	public static String[][] getStandardFormattedDatesNoYear(String userInput) {
		return getFormattedDates(userInput, ddmm);
	}

	private static String[][] getFormattedDates(String userInput, Pattern p) {
		Matcher m = p.matcher(userInput);
		
		int i = 0;
		String[][] tempDates = new String[2][3];
		while (m.find() & i < 2) {
			String[] dateArr = new String[3];
			dateArr[INDEX_FOR_DATE_ARR] = m.group(INDEX_FOR_DATE_INPUT);
			dateArr[INDEX_FOR_MONTH_ARR] = m.group(INDEX_FOR_MONTH_INPUT);
			String yr;
			if (m.groupCount() < 3) {
				yr = null;
			} else {
				yr = convertYearToStandardFormat(m.group(INDEX_FOR_YEAR_INPUT));
			}
			dateArr[INDEX_FOR_YEAR_ARR] = yr;
			tempDates[i] = dateArr;
			i++;
		}
		logDatesRead(tempDates);
		return tempDates;
	}

	private static String[] processFormattedDates(String userInput, String[][] tempDates) {
		String[] ans = new String[4];
		ans = standardizeDatesArray(tempDates);
		ans[2] = FORMATTED_DATE_FORMAT;
		ans[3] = removeFormattedDatesFromString(userInput);
		return ans;
	}
	
	private static void logDatesRead(String[][] tempDates) {
		/*for (int a = 0; a < 2; a++) {
			for (int b = 0; b < 3; b++) {
				System.out.println("TEMP[" + a + "]["+b+"]: " + tempDates[a][b]);
			}
		}*/
	}
	
	private static String[] standardizeDatesArray(String[][] tempDates) {
		String[] ans = new String[4];
		String[] firstDate = tempDates[0];
		String[] secondDate = tempDates[1];
		if (firstDate[INDEX_FOR_DATE_ARR] == null) { // no date detected
			ans[0] = null;
			ans[1] = null;
			return ans;
		} else {
			if (secondDate[INDEX_FOR_DATE_ARR] == null && firstDate[INDEX_FOR_YEAR_ARR] == null) { // only has start date
				setNextValidYear(firstDate);
			} else { // has start and end date
				if (secondDate[INDEX_FOR_YEAR_ARR] != null) { // has end year
					if (firstDate[INDEX_FOR_YEAR_ARR] == null) { // no start year
						firstDate[INDEX_FOR_YEAR_ARR] = secondDate[INDEX_FOR_YEAR_ARR];
					} 
				} else {
					if (firstDate[INDEX_FOR_YEAR_ARR] == null) {
						setNextValidYear(firstDate);
					}
					if (secondDate[INDEX_FOR_DATE_ARR] != null) {
						setNextValidYear(secondDate);
					}
				}
			}
		}
		ans[0] = convertDateToStandardFormat(firstDate);
		ans[1] = convertDateToStandardFormat(secondDate);
		return ans;
	}

	private static void setNextValidYear(String[] date) {
		LocalDate today = LocalDate.now();
		String currYear = String.valueOf(today.getYear());
		String newDateString = currYear + "-" + date[INDEX_FOR_MONTH_ARR] + "-" + date[INDEX_FOR_DATE_ARR];
		DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-M-d");
		try {
			LocalDate newDate = LocalDate.parse(newDateString, formatter);
			if (newDate.isAfter(today)) {
				date[INDEX_FOR_YEAR_ARR] = currYear;
			} else {
				date[INDEX_FOR_YEAR_ARR] = String.valueOf(today.getYear() + 1);
			}
		} catch (DateTimeParseException e){
			date = null;
		}
	}

	private static String removeFormattedDatesFromString(String input) {
		return InputParser.removeRegexPatternFromString(input, FORMATTED_DATE_REGEX);
	}
	
	@Override
	protected String[] getParsedDates() {
		return formattedDates;
	}
	
	@Override
	protected String[] getParsedTimes() {
		return formattedTimes;
	}
	
	@Override
	protected String getUnparsedInput() {
		return unparsedInput;
	}
	
	@Override
	protected Calendar[] parse(String input, String[] parsedDates, String[] parsedTimes) {
		logger.log(Level.FINE, "TO FORM:" + input + ".");
		formattedTimes = TimeParser.getStandardTimesFromString(input); // all time parsing done
		if (invalidTimes(formattedTimes)) {
			return null;
		}
		formattedDates = getStandardFormattedDates(formattedTimes[3]);
		logger.log(Level.FINE, "DATES:" + formattedDates[0] + ".");
		unparsedInput = formattedDates[3];
		logger.log(Level.FINE, "TO FLEX:" + unparsedInput + ".");
		return convertStringToCalendar(formattedDates, formattedTimes);
	}

	private boolean invalidTimes(String[] times) {
		if (times[0] == null) {
			return false;
		}
		String timeFormat = times[2];
		SimpleDateFormat dateTimeFormat = new SimpleDateFormat("dd-mm-yy" + timeFormat);
		try {
			dateTimeFormat.setLenient(false);
			Calendar cal = Calendar.getInstance();
			cal.setTime(dateTimeFormat.parse("1-1-15" + times[0]));
			if (times[1] == null) {
				return false;
			}
			cal.setTime(dateTimeFormat.parse("1-1-15" + times[1]));
		} catch (java.text.ParseException e) {
			e.printStackTrace();
			return true; // failed to parse
		}
		return false;
	}
}
```
###### parser\GuiParser.java
``` java

package parser;

import parser.MyParser.CommandType;

public abstract class GuiParser extends InputParser {

	ParsedCommand createParsedCommandGuiTabAction(CommandType cmd, String[] input) {
		if (isMissingArguments(input)) {
			return createParsedCommandError(ERROR_MISSING_ARGS);
		} else {
			String tab = input[INDEX_FOR_ARGS];
			try {
				return new ParsedCommand.Builder(cmd)
										.guiType(tab)
										.build();
			} catch (InvalidArgumentsForParsedCommandException e) {
				return createParsedCommandError(e.getMessage());
			}
		}
	}
}
```
###### parser\InputParser.java
``` java

package parser;

import java.util.ArrayList;
import java.util.Calendar;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import parser.MyParser.CommandType;
import parser.ParsedCommand.TaskType;

public abstract class InputParser {
	static final String ERROR_INVALID_COMMAND = "Error: Invalid command";
	static final String ERROR_NO_INPUT = "Error: No user input";
	static final String ERROR_MISSING_ARGS = "Error: No arguments entered";
	static final String ERROR_MISSING_FIELDS = "Error: No fields were entered for editing";
	static final int INDEX_FOR_CMD = 0;
	static final int INDEX_FOR_ARGS = 1;
	static final int INDEX_FOR_SUBCMD = 0;
	static final int INDEX_FOR_SUBARGS = 1;
	static final String ERROR = "TEMP";
	static final String ERROR_INVALID_TASKID = "Error: Invalid/Missing taskId";
	
	
	static final String TO_REGEX = "-|to|until|till";
		
	protected static final String TASK_ID_REGEX = "(^[0-9]+(?=\\s|$))";
	protected static final String TAG_REGEX = "(?<=\\s|^)#(\\w+)";
	protected static final String DESCRIPTION_REGEX = "(?<!\\\\)\"(.*)(?<!\\\\)\"(?!.*((?<!\\\\)\"))";
	protected static final String TASK_STATUS_REGEX = "(?<=[^//s])(todo|completed|overdue)(?=\\s|$)";
	protected static final String TASK_TYPE_REGEX = "(?<=\\s|^)(floating(?:task)?|deadline(?:task)?|event(?:task)?)(?:s)?(?=\\s|$)";
	
	
	protected static final String NOT_TITLE_REGEX_KEYWORD_OK = "(" + "( from | fr | at | to | til | until | by | on | - )?" + DateTimeParser.NO_KEYWORD_DATE_TIME_REGEX + "|" + TAG_REGEX + "|" + DESCRIPTION_REGEX  + "|(" + TASK_STATUS_REGEX + ")|((?<=\\s|^)(on )?(tmr|tomorrow|tomorow)(?=\\s|$)))";  	
	protected static final String NOT_TITLE_REGEX = "(" + "( from | fr | at | to | til | until | by | on | - )?" + DateTimeParser.DATE_TIME_REGEX + "|" + TAG_REGEX + "|" + DESCRIPTION_REGEX  + "|(" + TASK_STATUS_REGEX + "))";  	
	
	// private static final Logger logger = Logger.getLogger(StringParser.class.getName() );
	public static final String ERROR_INVALID_TABID = "Error: Invalid tab ID";
	
	protected static final int INDEX_FOR_START = 0;
	protected static final int INDEX_FOR_END = 1;

	abstract ParsedCommand parse(String[] input);
	
	static ParsedCommand createParsedCommandError(String errorMsg) {
		ParsedCommand pc;
		try {
			pc = new ParsedCommand.Builder(MyParser.CommandType.ERROR)
						 		  .errorMessage(errorMsg)
						 		  .build();
			return pc;
		} catch (InvalidArgumentsForParsedCommandException e) {
			return createParsedCommandError(e.getMessage());
		}
	}

	static ParsedCommand createParsedCommand(CommandType cmd) {
		try {
			return new ParsedCommand.Builder(cmd).build();
		} catch (InvalidArgumentsForParsedCommandException e) {
			return InputParser.createParsedCommandError(e.getMessage());
		}
	}
	
    
	// Methods to extract fields from string
	
	static String getTitleWithKeywordsFromString(String inputArgs) {
		inputArgs = removeRegexPatternFromString(inputArgs, NOT_TITLE_REGEX_KEYWORD_OK);
		return inputArgs.trim();
	}
	
	static String getTitleFromString(String inputArgs) {
		inputArgs = removeRegexPatternFromString(inputArgs, NOT_TITLE_REGEX);
		return inputArgs.trim();
	}
	
	static String getDescriptionFromString(String inputArgs) {
		Pattern descriptionPattern = Pattern.compile(DESCRIPTION_REGEX);
		Matcher m = descriptionPattern.matcher(inputArgs);
		String description = null;
		
		if (m.find()) {
			description = m.group(1);
		}
		
		return description;
	}

	static int getTaskIdFromString(String inputArgs) {
		Pattern taskIdPattern = Pattern.compile(TASK_ID_REGEX);
		Matcher m = taskIdPattern.matcher(inputArgs);
		int taskId = -1;

		if (m.find()) {
			taskId = Integer.parseInt(m.group());
		}

		return taskId;
	}

	static ArrayList<String> getTagsFromString(String inputArgs) {
		Pattern tagsPattern = Pattern.compile(TAG_REGEX);
		Matcher m = tagsPattern.matcher(inputArgs);
		ArrayList<String> tags = new ArrayList<String>();

		while (m.find()) {
			String tag = m.group(1);
			tags.add(tag);
		}

		return tags;
	}

	static Boolean getTaskStatusFromString(String inputArgs) {
		Pattern taskStatusPattern = Pattern.compile(TASK_STATUS_REGEX);
		Matcher m = taskStatusPattern.matcher(inputArgs);
		String status = "";

		if (m.find()) {
			status = m.group();
		}

		return determineTaskStatus(status);
	}

	static TaskType getTaskTypeFromString(String inputArgs) {
		Pattern taskTypePattern = Pattern.compile(TASK_TYPE_REGEX);
		Matcher m = taskTypePattern.matcher(inputArgs);
		String type = "";

		if (m.find()) {
			type = m.group(1);
		}
		
		return taskTypeToEnum(type);
	}

	
	private static Boolean determineTaskStatus(String status) {
		if (status.equalsIgnoreCase("todo")) {
			return false;
		} else if (status.equalsIgnoreCase("completed")) {
			return true;
		} else {
			return null;
		}
	}

	
	private static TaskType taskTypeToEnum(String type) {
		if (type.equals("floating")) {
			return TaskType.FLOATING_TASK;
		} else if (type.equals("deadline")) {
			return TaskType.DEADLINE_TASK;
		} else if (type.equals("event")) {
			return TaskType.EVENT;
		} else {
			return null;
		}
	}
	
	
	static String removeKeywordSection(String input) {
		input = removeRegexPatternFromString(input, DateTimeParser.DATE_KEYWORD_REGEX);
		return input;
	}
	
	public static String removeRegexPatternFromString(String input, String regex) {
		if (input == null) {
			return null;
		}
		input = input.replaceAll(regex, "");
		return input.trim();
	}
	
	static boolean isMissingArguments(String[] input) {
		return input.length < 2;
	}
	

	// Date time parsing using chain of responsibility pattern
	
	static Calendar[] getDatesTimesFromString(String input) {
		DateTimeParser dateTimeParserChain = getChainOfParsers();
		String[] emptyArr = new String[4];
		String dateSection = DateTimeParser.extractDateTimeSectionFromString(input);
		Calendar[] datesTimes = dateTimeParserChain.getDatesTimes(dateSection, emptyArr, emptyArr);
		return datesTimes;
	}
	
	private static DateTimeParser getChainOfParsers() {
		DateTimeParser formattedParser = new FormattedDateTimeParser();
		DateTimeParser flexibleParser = new FlexibleDateTimeParser();
		DateTimeParser nattyParser = new NattyDateTimeParser();
		
		formattedParser.setNextParser(flexibleParser);
		flexibleParser.setNextParser(nattyParser);
		return formattedParser;
	}
}
```
###### parser\InputParserTest.java
``` java

package parser;

import static org.junit.Assert.*;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.util.ArrayList;
import java.util.Date;

import org.junit.Test;

import parser.MyParser.CommandType;
import parser.ParsedCommand.TaskType;

public class InputParserTest {
	
	public static Date parseStringToDate(String input) {
		Date date = new Date();
			SimpleDateFormat format = new SimpleDateFormat(
					"EEE MMM dd HH:mm:ss zzz yyyy");
			try {
				date = format.parse(input);
			} catch (ParseException e) {
				return null;
			}
			return date;
	}
	
	@Test
	public void testParse() {
		
	}

	@Test
	public void testCreateParsedCommandError() {
		ParsedCommand pc = InputParser.createParsedCommandError("ERROR");
		assertEquals(MyParser.CommandType.ERROR, pc.getCommandType());
		assertEquals("ERROR", pc.getErrorMessage());
		
		pc = InputParser.createParsedCommandError(null);
		assertEquals(MyParser.CommandType.ERROR, pc.getCommandType());
		assertEquals("Error: Missing error message", pc.getErrorMessage());
		
		pc = InputParser.createParsedCommandError("");
		assertEquals(MyParser.CommandType.ERROR, pc.getCommandType());
		assertEquals("Error: Missing error message", pc.getErrorMessage());
	}

	@Test
	public void testCreateParsedCommand() {
		ParsedCommand pc = InputParser.createParsedCommand(CommandType.UNDO);
		assertEquals(CommandType.UNDO, pc.getCommandType());
		
		pc = InputParser.createParsedCommand(CommandType.ADD);
		assertEquals(MyParser.CommandType.ERROR, pc.getCommandType());
		assertEquals("Error: Missing task title", pc.getErrorMessage());
		
		pc = InputParser.createParsedCommand(null);
		assertEquals(MyParser.CommandType.ERROR, pc.getCommandType());
		assertEquals("Error: Missing command type for building ParsedCommand", pc.getErrorMessage());
		
	}

	@Test
	public void testIsMissingArguments() {
		assertEquals(true, InputParser.isMissingArguments(new String[] {""}));
		assertEquals(false, InputParser.isMissingArguments(new String[] {"", ""}));
		assertEquals(false, InputParser.isMissingArguments(new String[] {null, null, ""}));
	}
	
	@Test
	public void testGetTitleFromString() {
		assertEquals("hello this is my task", InputParser.getTitleWithKeywordsFromString(" hello this is my task 12:00 \"description\" #tags #tag1"));
		assertEquals("13:30hello this is my task", InputParser.getTitleWithKeywordsFromString("13:30hello this is my task"));
		assertEquals("hello this is   my task", InputParser.getTitleWithKeywordsFromString(" hello this is 12/12/12 5pm my task"));
		assertEquals("hello  task", InputParser.getTitleWithKeywordsFromString(" hello \"this is my\" task 12:00"));
		assertEquals("Meet John about proposal", InputParser.getTitleWithKeywordsFromString("12.2-13 Meet John about proposal #cs2103 12:00h"));
		assertEquals("Meet John about proposal", InputParser.getTitleWithKeywordsFromString("#cs2101 Meet John about proposal on 23 jan #cs2103 12:00 12/2/13"));
		assertEquals("Meet John about proposal", InputParser.getTitleWithKeywordsFromString(" 12:00 12/2/13 Meet John about proposal #cs2103 todo"));
		assertEquals("", InputParser.getTitleWithKeywordsFromString("23/1/15 2pm \"description\" #tag1 #tag2"));
		assertEquals("Meet John about proposal", InputParser.getTitleWithKeywordsFromString("#cs2101 Meet John about proposal 12:00 to 1:30pm 12/2/13"));
		assertEquals("Meet John about proposal", InputParser.getTitleWithKeywordsFromString("#cs2101 Meet John about proposal #cs2103 12:00 until 15:30 12/2/13"));
		assertEquals("Meet John about proposal", InputParser.getTitleWithKeywordsFromString("#cs2101 Meet John about proposal 23 jan #cs2103 from 12:00 to 12/2/13"));
		assertEquals("Meet John about proposal", InputParser.getTitleWithKeywordsFromString("#cs2101 Meet John about proposal 23 jan #cs2103 at 12:00 to 12/2/13"));	
		assertEquals("watch", InputParser.getTitleWithKeywordsFromString("watch tmr"));
		assertEquals("do proj on cats", InputParser.getTitleWithKeywordsFromString("do proj on cats"));
	}

	@Test
	public void testGetDatesTimesFromString() {
		// Check supported formats
		
		// Check support for no date & time
		assertEquals(null, InputParser.getDatesTimesFromString("Meet John about proposal 1200 #cs2103 #cs2101")[0]);
		assertEquals(null, InputParser.getDatesTimesFromString("Meet John about proposal 1200 #cs2103 #cs2101")[1]);
		
		// Check support for flexible start date no time
		assertEquals(parseStringToDate("Fri Apr 1 23:59:00 SGT 2016"), InputParser.getDatesTimesFromString("Add meeting with john on 1st April")[0].getTime());
		assertEquals(null, InputParser.getDatesTimesFromString("Add meeting with john on 1st April")[1]);

		// Check support for natty start date no time, keyword
		LocalDateTime dt = LocalDateTime.now();
		dt = LocalDateTime.from(dt.plusDays(1));
		dt = dt.withHour(23).withMinute(59).withSecond(0);
		assertEquals(Date.from(dt.atZone(ZoneId.systemDefault()).toInstant()).toString(), InputParser.getDatesTimesFromString("finish homework by tmr")[0].getTime().toString());
		assertEquals(null, InputParser.getDatesTimesFromString("finish homework by tmr")[1]);
		
		// Check support for formatted input (has start and end time) out of order
		assertEquals(StringParser.parseStringToDate("Tue Feb 12 12:00:00 SGT 2013"),
				InputParser.getDatesTimesFromString("12/2/13 Meet John about proposal #cs2103 12:00-13:30")[0].getTime());
		assertEquals(StringParser.parseStringToDate("Tue Feb 12 13:30:00 SGT 2013"), 
				InputParser.getDatesTimesFromString("12/2/13 Meet John about proposal #cs2103 12:00h -13:30 H")[1].getTime());		
		
		// Check support for flexible start date and time, keyword
		assertEquals(StringParser.parseStringToDate("Tue Feb 12 12:00:00 SGT 2013"),
				InputParser.getDatesTimesFromString("Meet John about proposal on feb 12 2013 12:00 #cs2103 #cs2101")[0].getTime());
		assertEquals(null, InputParser.getDatesTimesFromString("Meet John about proposal on feb 12 2013 12:00 #cs2103 #cs2101")[1]);
		
		// Check support for flexible start date and time, no keyword
		assertEquals(StringParser.parseStringToDate("Tue Feb 12 12:00:00 SGT 2013"),
				InputParser.getDatesTimesFromString("Meet John about proposal feb 12 2013 12:00 #cs2103 #cs2101")[0].getTime());
		assertEquals(null, InputParser.getDatesTimesFromString("Meet John about proposal feb 12 2013 12:00 #cs2103 #cs2101")[1]);
		
		// NO SUPPORT FOR NATTY EVENT!
		// Check support for Natty input start date & time
		dt = LocalDateTime.now();
		dt = LocalDateTime.from(dt.plusDays(1));
		dt = dt.withHour(14).withMinute(0).withSecond(0);
		assertEquals(Date.from(dt.atZone(ZoneId.systemDefault()).toInstant()).toString(), InputParser.getDatesTimesFromString("Meet John about proposal by tmr 2pm #cs2103 #cs2101")[0].getTime().toString());
		assertEquals(null, InputParser.getDatesTimesFromString("Meet John about proposal by tmr 2pm #cs2101")[1]);
				
		// Check invalid time for Natty input
		assertArrayEquals(null, InputParser.getDatesTimesFromString("Meet John about proposal by tmr 32pm #cs2101"));
				
		// Check support for flexible invalid date
		assertArrayEquals(null, InputParser.getDatesTimesFromString("Add meeting with john on 31st April"));

		// Check support for formatted input invalid time
		assertArrayEquals(null, InputParser.getDatesTimesFromString("12/2/13 Meet John about proposal #cs2103 52:00-13:30"));		
				
		// Auto-add date should be upcoming date, not current year
		// Check invalid date detection
		// Natty cannot handle events!!!
		
		// Remove from/to etc from title for no keyword
		// Consider support for if only time indicated, assume is today
				
	}

	@Test
	public void testGetDescriptionFromString() {
		assertEquals("and this my description", InputParser.getDescriptionFromString("this is my task \"and this my description\" blah blah 23/3/12"));
		assertEquals("my desc\" #cs2101 \"lalala", InputParser.getDescriptionFromString("Meet John about proposal @1200 #cs2103 \"my desc\" #cs2101 \"lalala\""));
		assertEquals(null, InputParser.getDescriptionFromString("Meet John about proposal @1200 #cs2103 #cs2101"));
	}

	@Test
	public void testGetTaskIdFromString() {
		// Check getTaskId returns integer at front of line
		assertEquals(4242, InputParser.getTaskIdFromString("4242 Meet John about proposal @1200 #cs2103 \"my desc\" #cs2101"));
		
		// Check invalid/missing taskId returns -1
		assertEquals(-1, InputParser.getTaskIdFromString("Meet Task John about proposal @1200 #cs2103 #cs2101"));
		assertEquals(-1, InputParser.getTaskIdFromString("this is my 23 task \"and this my description\" blah blah 23/3/12"));
	}

	@Test
	public void testGetTagsFromString() {
		assertEquals("cs2103", InputParser.getTagsFromString("Meet Task John about proposal #cs2103 @1200 #cs2101").get(0));
		assertEquals("cs2101", InputParser.getTagsFromString("Meet Task John about proposal #cs2103 @1200 #cs2101").get(1));
		assertEquals(new ArrayList<String>(), InputParser.getTagsFromString("Meet Task John about proposal @1200"));
	}
	
	@Test
	public void testGetTaskStatusFromString() {
		assertEquals(false, InputParser.getTaskStatusFromString("Meet Task John about proposal #cs2103 @1200 #cs2101 todo"));
		assertEquals(false, InputParser.getTaskStatusFromString("meeting 23/11/15 #tag todo"));
	}
	
	@Test
	public void testGetTaskTypeFromString() {
		assertEquals(TaskType.FLOATING_TASK, InputParser.getTaskTypeFromString("floating task"));
		assertEquals(TaskType.FLOATING_TASK, InputParser.getTaskTypeFromString("floating tasks"));
		assertEquals(TaskType.FLOATING_TASK, InputParser.getTaskTypeFromString("lalala floating task lalala"));
		assertEquals(null, InputParser.getTaskTypeFromString("lalafloating task lalala"));

		assertEquals(TaskType.DEADLINE_TASK, InputParser.getTaskTypeFromString("deadline task"));
		assertEquals(TaskType.DEADLINE_TASK, InputParser.getTaskTypeFromString("deadline tasks"));
		assertEquals(TaskType.DEADLINE_TASK, InputParser.getTaskTypeFromString("deadlines"));
		assertEquals(TaskType.DEADLINE_TASK, InputParser.getTaskTypeFromString("deadline"));
		assertEquals(TaskType.DEADLINE_TASK, InputParser.getTaskTypeFromString("lalala deadline task lalala"));
		assertEquals(null, InputParser.getTaskTypeFromString("lalaladeadline task lalala"));
		assertEquals(TaskType.DEADLINE_TASK, InputParser.getTaskTypeFromString("lalala deadlines lalala"));
		assertEquals(null, InputParser.getTaskTypeFromString("lalaladeadline lalala"));
		assertEquals(null, InputParser.getTaskTypeFromString("deadlineself"));

		assertEquals(TaskType.EVENT, InputParser.getTaskTypeFromString("event"));
		assertEquals(TaskType.EVENT, InputParser.getTaskTypeFromString("events"));
		assertEquals(TaskType.EVENT, InputParser.getTaskTypeFromString("lalala event lalala"));
		assertEquals(TaskType.EVENT, InputParser.getTaskTypeFromString("lalala events lalala"));
		assertEquals(null, InputParser.getTaskTypeFromString("lalaevent lalala"));
		assertEquals(null, InputParser.getTaskTypeFromString("eventsal"));

	}

}
```
###### parser\MyParser.java
``` java

package parser;

import java.util.HashMap;

public class MyParser {

	public enum CommandType {
		ADD, DELETE, EDIT, DISPLAY, ERROR, UNDO, FLAG, DONE, TODO, HELP, INVALID, CONFIG_DATA, CONFIG_IMG, 
		EXIT, CONFIG, SEARCH, SHOW, 
		GUI_OPEN, GUI_CLOSE, GUI_PIN, GUI_UNPIN, GUI_SHOW, GUI_SWITCH, GUI_LOG, GUI_MAIN, GUI_OPEN_ALL, GUI_CLOSE_ALL;
	}
	
	private static final int INDEX_FOR_CMD = 0;

	private static HashMap<String, MyParser.CommandType> _commandChoicesHashMap;
	public static final Pair[] COMMAND_CHOICES = {
		new Pair(MyParser.CommandType.ADD, new String[] {"add", "insert", "+"}),
		new Pair(MyParser.CommandType.DELETE, new String[] {"delete", "del", "remove", "cancel", "x"}),
		new Pair(MyParser.CommandType.EDIT, new String[] {"edit", "change", "update", "e;"}),
		new Pair(MyParser.CommandType.SHOW, new String[] {"show", "search", "find", "s;"}),
		new Pair(MyParser.CommandType.EXIT, new String[] {"exit", "e;"}),
		new Pair(MyParser.CommandType.UNDO, new String[] {"undo"}),
		new Pair(MyParser.CommandType.DONE, new String[] {"done", "finished", "completed", "v"}),
		new Pair(MyParser.CommandType.FLAG, new String[] {"flag", "mark", "f;"}),
		new Pair(MyParser.CommandType.TODO, new String[] {"todo", "do"}),
		new Pair(MyParser.CommandType.CONFIG, new String[] {"set"}),
		new Pair(MyParser.CommandType.HELP, new String[] {"help", "?", "h;"}),
		new Pair(MyParser.CommandType.GUI_OPEN, new String[] {"open"}),
		new Pair(MyParser.CommandType.GUI_CLOSE, new String[] {"close"}),
		new Pair(MyParser.CommandType.GUI_PIN, new String[] {"pin"}),
		new Pair(MyParser.CommandType.GUI_SWITCH, new String[] {"switch"}),
		new Pair(MyParser.CommandType.GUI_LOG, new String[] {"log"}),
		new Pair(MyParser.CommandType.GUI_MAIN, new String[] {"main"}),
		new Pair(MyParser.CommandType.GUI_UNPIN, new String[] {"unpin"})
	};

	static {
		setupCommandChoicesHashMap();		
	}
	
	
	/**
	 * Parses user input into ParsedCommand attributes.
	 * @param userInput Entire string input by user.
	 * @return ParsedCommand object, with type error if userInput is invalid.
	 */
	public static ParsedCommand parseCommand(String userInput) {
		if (userInput == null || userInput.trim().length() == 0) {
			return InputParser.createParsedCommandError(InputParser.ERROR_NO_INPUT);
		} else {
			userInput = userInput.trim().replaceAll("\\s+", " ");
			String input[] = userInput.trim().split(" ", 2);
			String userCommand = input[INDEX_FOR_CMD];
			CommandType command = getStandardCommandType(userCommand.toLowerCase());
			
			InputParser ip;
			
			switch (command) {
				case ADD:
					ip = new AddParser();
					return ip.parse(input);
					
				case DELETE:
					ip = new DeleteParser();
					return ip.parse(input);
					
				case EDIT:
					ip = new EditParser();
					return ip.parse(input);
					
				case SHOW: 
					ip = new ShowParser();
					return ip.parse(input);
					
				case FLAG:
					ip = new FlagParser();
					return ip.parse(input);
					
				case DONE:
					ip = new DoneParser();
					return ip.parse(input);
	
				case TODO:
					ip = new TodoParser();
					return ip.parse(input);
					
				case UNDO:
					return InputParser.createParsedCommand(MyParser.CommandType.UNDO);
	
				case GUI_OPEN:
					ip = new OpenParser();
					return ip.parse(input);
					
				case GUI_CLOSE:
					ip = new CloseParser();
					return ip.parse(input);
					
				case GUI_PIN:
					ip = new PinParser();
					return ip.parse(input);
					
				case GUI_SWITCH:
					return InputParser.createParsedCommand(CommandType.GUI_SWITCH);
					
				case GUI_LOG:
					return InputParser.createParsedCommand(CommandType.GUI_LOG);
					
				case GUI_MAIN:
					return InputParser.createParsedCommand(CommandType.GUI_MAIN);
				
				case GUI_UNPIN:
					return InputParser.createParsedCommand(CommandType.GUI_UNPIN);
					
				case CONFIG:
					ip = new ConfigParser();
					return ip.parse(input);
					
				case HELP:
					return InputParser.createParsedCommand(CommandType.HELP);
				
				case EXIT:
					return InputParser.createParsedCommand(CommandType.EXIT);
	
				case INVALID:
					return InputParser.createParsedCommandError(InputParser.ERROR_INVALID_COMMAND);
			
				default:
					// is never visited
					throw new Error("ERROR");
			}
		}
	}


	private static void setupCommandChoicesHashMap() {
		_commandChoicesHashMap = new HashMap<String, CommandType>();
		for (int i = 0; i < COMMAND_CHOICES.length; i++) {
		    String[] cmdChoiceList = COMMAND_CHOICES[i].str;
		    CommandType cmd = COMMAND_CHOICES[i].commandType;
		    for (int j = 0; j < cmdChoiceList.length; j++) {
		    	_commandChoicesHashMap.put(cmdChoiceList[j], cmd);
		    }
		}
	}


	private static CommandType getStandardCommandType(String input) {
		CommandType cmd = _commandChoicesHashMap.get(input);
		if (cmd != null) {
			return cmd;
		} else {
			return CommandType.INVALID;
		}
	}

	public static class Pair {
		public String[] str;
		public CommandType commandType;
		public Pair(CommandType commandType, String[] stringChoices) {
			this.str = stringChoices;
			this.commandType = commandType;
		}
	}
}
```
###### parser\NattyDateTimeParser.java
``` java

package parser;

import java.util.Calendar;
import java.util.Date;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import com.joestelmach.natty.DateGroup;
import com.joestelmach.natty.Parser;

public class NattyDateTimeParser extends DateTimeParser{
	//private static Pattern parantheses = Pattern.compile("([(]([a-zA-Z0-9.\\s]+)[)])");

	private String unparsedInput;
	private String[] nattyTimes;
	private String[] nattyDates;
	private static final String DAYS = "(mon(day)?|tue?(sday)?|tues|wed(nesday)?|thur(sday)?|thu|thurs|fri(day)?|sat(urday)?|sun(day)?|tmr|tomorrow|tomorow|today|tdy|ytd|yesterday)s?";
	private static final String RELATIVE_WORDS = "(next|nxt|prev|previous|last|coming|upcoming|before|after)";
	private static final String DURATION = "(day(s?)|month(s?)|year(s?)|yrs)";
	private static final String NUMBERS = "(\\d+)(?=\\s" + "(DURATION" + "|" + DAYS + ")" + ")";
	private static final String TO_ALTERNATIVES = "(?<=\\s|^)(until|til|till|-)(?=\\s|$)";
	
	private static final String NATTY_REGEX = "(?<=\\s|^)(" + DAYS + "|" + RELATIVE_WORDS + "|" + DURATION + "|" + NUMBERS + "|to)(?=\\s|$)";
	private static final Pattern NATTY_DATES = Pattern.compile(NATTY_REGEX);
	
	private static final Logger logger = Logger.getLogger(NattyDateTimeParser.class.getName() );
	
	public static String standardiseNattyInput(String input) {
		input = input.replaceAll(TO_ALTERNATIVES, "to");
		input = input.toLowerCase();
		Matcher m = NATTY_DATES.matcher(input);
		String stdForm = "";
		while (m.find()) {
			stdForm = stdForm + m.group() + " ";
		}
		System.out.println(stdForm);
		return stdForm;
	}
	
	public static Calendar[] parseDateTimeWithNatty(String input) {
		
		Calendar[] parsedDates = new Calendar[3];
		Parser parser = new Parser();
		List<DateGroup> groups = parser.parse(input); // returns empty list if parse fails
		
		if (groups.isEmpty()) { // failed to parse
			return parsedDates; // assume no dates. should never see this? 
		}
		
		List<Date> dates = groups.get(0).getDates();
		parsedDates[0] = convertDateToCalendar(dates.get(0));
		if (dates.size() < 2) {
			parsedDates[1] = null; // no end time
		} else {
			parsedDates[1] = convertDateToCalendar(dates.get(1));
		}
		return parsedDates;
	}

    private static Calendar convertDateToCalendar(Date date){ 
    	  Calendar cal = Calendar.getInstance();
    	  cal.setTime(date);
    	  return cal;
    }

    private static boolean canParseWithNatty(String input) {
    	Parser parser = new Parser();
		// System.out.println(input);
		List<DateGroup> groups = parser.parse(input); // returns empty list if parse fails
		if (groups.isEmpty()) {
			logger.log(Level.FINE, "Parse " + input + " with Natty fail");
			return false;
		} else {
			logger.log(Level.FINE, "Parse " + input + " with Natty success");
			return true;
		}
	}
    
    @Override
    protected Calendar[] parse(String input, String[] parsedDates, String[] parsedTimes) {
    	assert(parsedDates != null);
    	assert(parsedTimes != null);
    	logger.log(Level.FINE, "INPUT TO NATTY: " + input);
    	// Times parsed by now, only dates left
    	input = standardiseNattyInput(input);
    	if (canParseWithNatty(input)) { // can parse without time, ie has date
    		String[] startAndEndDates = input.split(" to | until | til | till | - ");
    		String dateWithTime;
    		if (startAndEndDates.length < 2) { // only has 1 Natty date
    			if (parsedTimes[0] == null) {
    	    		parsedTimes[0] = "23:59";
    	    		if (parsedTimes[1] == null) {
    	    			parsedTimes[1] = "";
    	    		}
    	    	} else if (parsedTimes[1] == null) {
    	    		parsedTimes[1] = "";
    	    	}
    			dateWithTime = input + " " + parsedTimes[0] + " to " + parsedTimes[1];    			
    		} else {
    			if (parsedTimes[0] == null) {
    	    		parsedTimes[0] = "23:59";
    	    		if (parsedTimes[1] == null) {
    	    			parsedTimes[1] = "23:59";
    	    		}
    	    	} else if (parsedTimes[1] == null) {
    	    		parsedTimes[1] = "23:59";
    	    	}
    			dateWithTime = startAndEndDates[0] + " " + parsedTimes[0] + " to " + startAndEndDates[1] + " " + parsedTimes[1];  
    		}
    		logger.log(Level.FINE, "Parse with Natty: " + dateWithTime);
    		return parseDateTimeWithNatty(dateWithTime);
    	} else { // invalid input - assume no date/time ie is floating
    		Calendar[] times = new Calendar[2];
    		times[0] = null;
    		times[1] = null;
    		return times;
    	}
    }

	@Override
	protected String getUnparsedInput() {
		return unparsedInput;
	}

	@Override
	protected String[] getParsedTimes() {
		return nattyTimes;
	}

	@Override
	protected String[] getParsedDates() {
		return nattyDates;
	}

}
```
###### parser\OpenParser.java
``` java

package parser;

import parser.MyParser.CommandType;

public class OpenParser extends GuiParser {

	ParsedCommand parse(String[] input) {
		return createParsedCommandGuiTabAction(CommandType.GUI_OPEN, input);
	}
	
}
```
###### parser\ParsedCommand.java
``` java

package parser;

import java.util.ArrayList;
import java.util.Calendar;

import gui.GUIController;

public class ParsedCommand {
	public enum ConfigType {
		BACKGROUND, AVATAR, INVALID;
	}
	
	public enum TaskType {
		FLOATING_TASK, DEADLINE_TASK, EVENT;
	}

	private MyParser.CommandType cmdType;
	private String title;
	private String errorMessage;
	private String searchKeywords;
	private String path;
	private Calendar firstDate;
	private Calendar secondDate;
	private String description;
	private ArrayList<String> tags;
	private int taskId;
	private String guiType;
	private TaskType taskType;
	private Boolean isCompleted;
	private ConfigType configType;
	
	private static final String ERROR_INVALID_DATE = "Error: Invalid date(s) input";

	// private static final Logger logger = Logger.getLogger(ParsedCommand.class.getName() );
	private static final String ERROR_MISSING_TITLE = "Error: Missing task title";
	
	private static final int INDEX_FOR_START = 0;
	private static final int INDEX_FOR_END = 1;

	
	public static final String ERROR_INVALID_TASK_STATUS = null;
	public static final String ERROR_INVALID_CONFIG_TYPE = null;
	public static final String ERROR_INVALID_PATH = null;
	public static final String ERROR_INVALID_GUI_TAB_ID = null;
	
	
    /**
     * This method creates a ParsedCommand object (constructor).
     * 
     * @param cmdType Type of command or error.
     * @param title Title of task or error message (for error objects).
     * @param start Start date and time of task.
     * @param end End date and time of task.
     * @param description Description of task.
     * @param tags ArrayList of tags in task, tags must be alphanumeric with no whitespace.
     * @param taskId TaskId of task for edit, delete.
     * @param taskType Type of task, 1 for task, 2 for deadline task, 3 for event.
     */
	public ParsedCommand(Builder builder) {
		this.cmdType = builder.cmdType;
		this.title = builder.title;
		this.errorMessage = builder.errorMessage;
		this.searchKeywords = builder.searchKeywords;
		this.path = builder.path;
		this.firstDate = builder.firstDate;
		this.secondDate = builder.secondDate;
		this.description = builder.description;
		this.tags = builder.tags;
		this.taskId = builder.taskId;
		this.guiType = builder.guiType;
		this.taskType = builder.taskType;
		this.isCompleted = builder.isCompleted;
		this.configType = builder.configType;
	}

	/**
	 * Returns command type of command, including error CommandType.
	 * @return command type.
	 */
	public MyParser.CommandType getCommandType() {
		return this.cmdType;
	}
	
	/**
	 * Returns title of task, empty string if not found, null if not applicable.
	 * @return title.
	 */
	public String getTitle() {
		return this.title;
	}
	
	/**
	 * Returns first date and time of task in Calendar format, null if not applicable.
	 * @return first date/time.
	 */
	public Calendar getFirstDate() {
		return this.firstDate;
	}
	
	/**
	 * Returns second date and time of task in Calendar format, null if not applicable.
	 * @return second date/time.
	 */
	public Calendar getSecondDate() {
		return this.secondDate;
	}
	
	/**
	 * Returns description of task, empty string if not found, null if not applicable.
	 * @return task description.
	 */
	public String getDescription() {
		return this.description;
	}
	
	/**
	 * Returns ArrayList of tags, empty ArrayList if not applicable.
	 * @return tags.
	 */
	public ArrayList<String> getTags() {
		return this.tags;
	}
	
	/**
	 * Returns error message if ParsedCommand is of type Error, null if not applicable.
	 * @return error message.
	 */
	public String getErrorMessage() {
		return this.errorMessage;
	}
	
	/**
	 * Returns taskId of task, -1 if not applicable.
	 * @return task ID.
	 */
	public int getTaskId() {
		return this.taskId;
	}
	
	/**
	 * Returns gui tab's index, empty string if not found, null if not applicable.
	 * @return gui tab index.
	 */
	public String getGuiType() {
		return this.guiType;
	}
	
	/**
	 * Returns TaskType.EVENT, TaskType.DEADLINE_TASK, TaskType.FLOATING_TASK or null.
	 * @return task type.
	 */
	public TaskType getTaskType() {
		return this.taskType;
	}
	
	/**
	 * Sets taskType of ParsedCommand object to argument.
	 * @param taskType
	 */
	public void setTaskType(TaskType taskType) {
		this.taskType = taskType;
	}
	
	/**
	 * Returns configuration type i.e. background or avatar for CONFIG_IMG, returns null if not applicable.
	 * @return
	 * @throws InvalidMethodForTaskTypeException
	 */
	public ConfigType getConfigType() {
		return this.configType;
	}
	
	/**
	 * Returns path for customisation for set file/background/avatar, returns null if not applicable.
	 * @return
	 * @throws InvalidMethodForTaskTypeException
	 */
	public String getConfigPath() {
		return this.path;
	}
	
	/**
	 * Returns true if completed, false if todo, null if irrelevant.
	 * @return
	 */
	public Boolean isCompleted() {
		return this.isCompleted;
	}
	
	/**
	 * Returns search keywords for show command, empty string if not found, returns null if not applicable.
	 * @return
	 */
	public String getKeywords() {
		return this.searchKeywords;
	}
	
	static class Builder {
		private static final String ERROR_MISSING_ERROR_MESSAGE = "Error: Missing error message";

		private MyParser.CommandType cmdType;
		
		private String title = null;
		private String searchKeywords = null;
		private String errorMessage = null;
		private String path = null;
		private Calendar firstDate = null;
		private Calendar secondDate = null;
		private String description = null;
		private ArrayList<String> tags = new ArrayList<String>();
		private int taskId = -1;
		private String guiType = null;
		private TaskType taskType = null;
		private Boolean isCompleted = null;
		private ConfigType configType = null;
		
		static final String ESC_CHAR_REGEX = "(?<!\\\\)(\\\\)";
		

		public Builder(MyParser.CommandType cmdType) {
			this.cmdType = cmdType;
		}
		
		public Builder title(String title) {
			this.title = removeEscapeChars(title);
			return this;
		}
		
		public Builder description(String description) {
			this.description = description;
			return this;
		}
		
		public Builder times(Calendar[] times) throws InvalidArgumentsForParsedCommandException {
			if (times == null) {
				throw new InvalidArgumentsForParsedCommandException(ERROR_INVALID_DATE);
			}
			this.firstDate = times[INDEX_FOR_START];
			this.secondDate = times[INDEX_FOR_END];
			return this;
		}
		
		public Builder tags(ArrayList<String> tags) {
			this.tags = tags;
			return this;
		}
		
		public Builder taskId(int taskId) throws InvalidArgumentsForParsedCommandException {
			if (taskId < 0) {
				throw new InvalidArgumentsForParsedCommandException(InputParser.ERROR_INVALID_TASKID);
			}
			this.taskId = taskId;
			return this;
		}
		
		public Builder guiType(String gui) {
			this.guiType = gui;
			return this;
		}
		
		public Builder errorMessage(String msg) {
			this.errorMessage = msg;
			return this;
		}
		
		public Builder configType(ConfigType configType) {
			this.configType = configType;
			return this;
		}
		
		public Builder configPath(String path) throws InvalidArgumentsForParsedCommandException {
			if (path.equals("")) {
				throw new InvalidArgumentsForParsedCommandException(InputParser.ERROR_MISSING_ARGS);
			}
			this.path = path;
			return this;
		}
		
		public Builder isCompleted(Boolean status) {
			this.isCompleted = status;
			return this;
		}
		
		public Builder searchKeywords(String keywords) {
			this.searchKeywords = removeEscapeChars(keywords);
			return this;
		}
		
		public Builder taskType(TaskType type) {
			this.taskType = type;
			return this;
		}
		
		public ParsedCommand build() throws InvalidArgumentsForParsedCommandException {
			MyParser.CommandType command = this.cmdType;
			if (command == null) {
				throw new InvalidArgumentsForParsedCommandException("Error: Missing command type for building ParsedCommand");
			} else if (command == MyParser.CommandType.ADD) {
				validateTitle();
				setTaskType();
			} else if (command == MyParser.CommandType.EDIT || command == MyParser.CommandType.FLAG || command == MyParser.CommandType.DELETE) {
				validateTaskId();
				if (command == MyParser.CommandType.FLAG) {
					validateTaskStatus();
				}
			} else if (command == MyParser.CommandType.CONFIG_IMG) {
				validateConfigType();
				validatePath();
			} else if (command == MyParser.CommandType.GUI_OPEN || command == MyParser.CommandType.GUI_CLOSE 
					|| command == MyParser.CommandType.GUI_PIN) {
				validateGuiType();
			} else if (command == MyParser.CommandType.ERROR) {
				validateErrorMsg();
			}
			return new ParsedCommand(this);
		}

		private void validateErrorMsg() throws InvalidArgumentsForParsedCommandException {
			if (this.errorMessage == null || this.errorMessage.isEmpty()) {
				throw new InvalidArgumentsForParsedCommandException(ERROR_MISSING_ERROR_MESSAGE);
			}
		}

		private void validateTaskId() throws InvalidArgumentsForParsedCommandException {
			if (this.taskId < 0) {
				throw new InvalidArgumentsForParsedCommandException(InputParser.ERROR_INVALID_TASKID);
			}
		}
		
		private void validateGuiType() throws InvalidArgumentsForParsedCommandException {
			try {
				int tabNumber = Integer.parseInt(guiType);
				if (tabNumber < GUIController.taskListNames.length && tabNumber >= 0) {
					return;
				}
			} catch (NumberFormatException e) {
				// do nothing
			}
			
			for (int i = 0; i < GUIController.taskListNames.length; i++) {
				if (guiType.equalsIgnoreCase(GUIController.taskListNames[i])) {
					guiType = Integer.toString(i);
					return;
				}
			}
			throw new InvalidArgumentsForParsedCommandException(InputParser.ERROR_INVALID_TABID);
		}

		private void validateTitle() throws InvalidArgumentsForParsedCommandException {
			if (this.title == null || this.title.equals("")) {
				throw new InvalidArgumentsForParsedCommandException(ERROR_MISSING_TITLE);
			}
		}
		
		private void validateTaskStatus() throws InvalidArgumentsForParsedCommandException {
			if (this.isCompleted == null) {
				throw new InvalidArgumentsForParsedCommandException(ERROR_INVALID_TASK_STATUS);
			}
		}
		
		private void validateConfigType() throws InvalidArgumentsForParsedCommandException {
			if (this.configType == ConfigType.INVALID || this.configType == null) {
				throw new InvalidArgumentsForParsedCommandException(ERROR_INVALID_CONFIG_TYPE);
			}
		}
		
		private void validatePath() throws InvalidArgumentsForParsedCommandException {
			if (this.path == null || this.path.isEmpty()){
				throw new InvalidArgumentsForParsedCommandException(ERROR_INVALID_PATH);
			}
		}

		private void setTaskType() {
			this.taskType = determineTaskType(this.firstDate, this.secondDate);
		}
		
		private static String removeEscapeChars(String input) {
			if (input == null) {
				return null;
			} else {
				return input.replaceAll(ESC_CHAR_REGEX, "");
			}
		}
		
		private static TaskType determineTaskType(Calendar start, Calendar end) {
			TaskType taskType;
			if (end == null) {
				if (start == null) {
					taskType = TaskType.FLOATING_TASK;
				} else {
					taskType = TaskType.DEADLINE_TASK;
				}
			} else {
				taskType = TaskType.EVENT;
			}
			return taskType;
		}
	}
}
```
###### parser\PinParser.java
``` java

package parser;

import parser.MyParser.CommandType;

public class PinParser extends GuiParser {

	ParsedCommand parse(String[] input) {
		return createParsedCommandGuiTabAction(CommandType.GUI_PIN, input);			
	}
	
}
```
###### parser\ShowParser.java
``` java

package parser;

import java.util.ArrayList;
import java.util.Calendar;
import parser.MyParser.CommandType;
import parser.ParsedCommand.TaskType;

public class ShowParser extends InputParser {
	private static final String NOT_KEYWORDS_REGEX = NOT_TITLE_REGEX + "|" + TASK_TYPE_REGEX;
	
	ParsedCommand parse(String[] input) {
		if (isMissingArguments(input)) {
			return createParsedCommand(CommandType.GUI_SHOW);
		} else {
			String inputArgs = input[INDEX_FOR_ARGS];
			int taskId = getTaskIdFromString(inputArgs);
			if (hasTaskId(taskId)) { // show task details
				return createParsedCommandDisplay(taskId);
			} else { // search	
				return createParsedCommandSearch(inputArgs);
			}
		}
	}

	private static ParsedCommand createParsedCommandSearch(String inputArgs) {
		ParsedCommand pc;
		try {
			String parsedKeywords = getSearchKeywordsFromString(inputArgs);
			Calendar[] parsedTimes = getDatesTimesFromString(inputArgs);
			parsedTimes = convertToSearchTimes(parsedTimes, inputArgs);
			ArrayList<String> parsedTags = getTagsFromString(inputArgs);
			Boolean parsedStatus = getTaskStatusFromString(inputArgs);
			TaskType taskType = getTaskTypeFromString(inputArgs);
			
			pc = new ParsedCommand.Builder(CommandType.SEARCH)
								  .searchKeywords(parsedKeywords)
								  .times(parsedTimes)
								  .tags(parsedTags)
								  .isCompleted(parsedStatus)
								  .taskType(taskType)
								  .build();
			return pc;
		} catch (InvalidArgumentsForParsedCommandException e) {
			return InputParser.createParsedCommandError(e.getMessage());
		}
	}

	private static Calendar[] convertToSearchTimes(Calendar[] parsedTimes, String input) {
		if (parsedTimes == null) {
			return null;
		}
		if (parsedTimes[INDEX_FOR_START] != null && parsedTimes[INDEX_FOR_END] == null) {
			if (TimeParser.hasTime(input)) { // user input start date and time only
				Calendar endTime = (Calendar) parsedTimes[INDEX_FOR_START].clone();
				endTime.set(Calendar.HOUR_OF_DAY, 23);
				endTime.set(Calendar.MINUTE, 59);
				parsedTimes[INDEX_FOR_END] = endTime;
			} else { // user input start date only
				Calendar startTime = (Calendar) parsedTimes[INDEX_FOR_START].clone();
				startTime.set(Calendar.HOUR_OF_DAY, 0);
				startTime.set(Calendar.MINUTE,  0);
				parsedTimes[INDEX_FOR_END] = parsedTimes[INDEX_FOR_START];
				parsedTimes[INDEX_FOR_START] = startTime;
			}
		}
		return parsedTimes;
	}
	
	private static ParsedCommand createParsedCommandDisplay(int taskId) {
		ParsedCommand pc;
		try {
			pc = new ParsedCommand.Builder(CommandType.DISPLAY)
	  							  .taskId(taskId)
	  							  .build();
			return pc;
		} catch (InvalidArgumentsForParsedCommandException e) {
			return InputParser.createParsedCommandError(e.getMessage());
		}
	}
	
	private static String getSearchKeywordsFromString(String input) {
		return removeRegexPatternFromString(input, NOT_KEYWORDS_REGEX);
	}
	
	private static boolean hasTaskId(int taskId) {
		return taskId >= 0;
	}

}
```
###### parser\ShowParserTest.java
``` java

package parser;

import static org.junit.Assert.*;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;

import org.junit.Test;

import parser.MyParser.CommandType;

public class ShowParserTest {
	public static Date parseStringToDate(String input) {
		Date date = new Date();
			SimpleDateFormat format = new SimpleDateFormat(
					"EEE MMM dd HH:mm:ss zzz yyyy");
			try {
				date = format.parse(input);
			} catch (ParseException e) {
				return null;
			}
			return date;
	}
	
	@Test
	public void testParse() {
		fail("Not yet implemented");
	}

	@Test
	public void testContainsOnlyTaskId() {
		fail("Not yet implemented");
	}

	@Test
	public void testCreateParsedCommandShowSearch() {
		ArrayList<String> tags = new ArrayList<String>();
		tags.add("tag");
		ParsedCommand pc = ShowParser.createParsedCommandSearch(" my search keywords from 1/4/16 3pm to 5pm #tag \"description\"");
		assertEquals(CommandType.SEARCH, pc.getCommandType());
		assertEquals("my search keywords", pc.getKeywords());
		assertEquals(parseStringToDate("Fri Apr 1 15:00:00 SGT 2016"), pc.getFirstDate().getTime());
		assertEquals(parseStringToDate("Fri Apr 1 17:00:00 SGT 2016"), pc.getSecondDate().getTime());
		assertEquals(tags, pc.getTags());		

		pc = ShowParser.createParsedCommandSearch(" my search keywords #tag \"description\"");
		assertEquals(CommandType.SEARCH, pc.getCommandType());
		assertEquals("my search keywords", pc.getKeywords());
		assertEquals(null, pc.getFirstDate());
		assertEquals(null, pc.getSecondDate());
		assertEquals(tags, pc.getTags());		

		pc = ShowParser.createParsedCommandSearch(" my search keywords on apr 1 #tag \"description\"");
		assertEquals(CommandType.SEARCH, pc.getCommandType());
		assertEquals("my search keywords", pc.getKeywords());
		assertEquals(parseStringToDate("Fri Apr 1 00:00:00 SGT 2016"), pc.getFirstDate().getTime());
		assertEquals(parseStringToDate("Fri Apr 1 23:59:00 SGT 2016"), pc.getSecondDate().getTime());
		assertEquals(tags, pc.getTags());		

		pc = ShowParser.createParsedCommandSearch(" my search keywords from 1/4/16 3pm to 2/4/16 5pm #tag \"description\"");
		assertEquals(CommandType.SEARCH, pc.getCommandType());
		assertEquals("my search keywords", pc.getKeywords());
		assertEquals(parseStringToDate("Fri Apr 1 15:00:00 SGT 2016"), pc.getFirstDate().getTime());
		assertEquals(parseStringToDate("Sat Apr 2 17:00:00 SGT 2016"), pc.getSecondDate().getTime());
		assertEquals(tags, pc.getTags());		


		pc = ShowParser.createParsedCommandSearch(" my search keywords from 31/4/16 3pm to 5pm #tag \"description\"");
		assertEquals(CommandType.ERROR, pc.getCommandType());
		assertEquals("Error: Invalid date(s) input", pc.getErrorMessage());
	}

	@Test
	public void testCreateParsedCommandShowDisplay() {
		ParsedCommand pc = ShowParser.createParsedCommandDisplay(234);
		assertEquals(MyParser.CommandType.DISPLAY, pc.getCommandType());
		assertEquals(234, pc.getTaskId());
		
		pc = ShowParser.createParsedCommandDisplay(0);
		assertEquals(MyParser.CommandType.DISPLAY, pc.getCommandType());
		assertEquals(0, pc.getTaskId());

		pc = ShowParser.createParsedCommandDisplay(-1);
		assertEquals(MyParser.CommandType.ERROR, pc.getCommandType());
		assertEquals("Error: Invalid/Missing taskId", pc.getErrorMessage());

	}

}
```
###### parser\TimeParser.java
``` java

package parser;

import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class TimeParser {
	private static final int INDEX_FOR_TIME_FORMAT = 2;
	private static final int INDEX_FOR_FIRST_TIME = 0;
	private static final int INDEX_FOR_NONTIME_STRING = 3;
	
	static final String TWELVE_HR_REGEX = "(?<=\\s|^)([0-9]?[0-9])([.:][0-9][0-9])?\\s?(am|pm)?(\\s?(?:-|to|until|til|till)\\s?([0-9]?[0-9])([.:][0-9][0-9])?\\s?)?(am|pm)(?=\\s|$)";
	static final String TWENTYFOUR_HR_REGEX = "(?<=\\s|^)(([0-9]?[0-9])[:]([0-9][0-9]))\\s?[?:h|H]?\\s?((?:-|to|until|til|till)?\\s?(([0-9]?[0-9])[:]([0-9][0-9])))?\\s?[?:h|H]?(?=\\s|$)";
		
	static final String TIME_REGEX = "(" + TWELVE_HR_REGEX + "|" + TWENTYFOUR_HR_REGEX + ")";
	
	static final Pattern HHMM = Pattern.compile(TWENTYFOUR_HR_REGEX);
	static final Pattern HMMA = Pattern.compile(TWELVE_HR_REGEX);
	
	static final String TWELVE_HR_FORMAT = "h:mma";
	static final String TWENTY_FOUR_HR_FORMAT = "HH:mm";

	private static final int TIME_H1 = 1;
	private static final int TIME_M1 = 2;
	private static final int TIME_APM1 = 3;
	private static final int TIME_H2 = 5;
	private static final int TIME_M2 = 6;
	private static final int TIME_APM2 = 7;
	
	private static final Logger logger = Logger.getLogger(TimeParser.class.getName() );

	private static String[] getTwentyfourHrTimesFromString(String input) {
		Matcher m = HHMM.matcher(input);
		String[] ans = new String[4];
		ans[INDEX_FOR_TIME_FORMAT] = TWENTY_FOUR_HR_FORMAT;
		
		int i = 0;
		while (m.find() & i < 2) {
			if (i == 0) {
				ans[0] = m.group(1);
				ans[1] = m.group(5);
			} else {
				ans[1] = m.group(1);
			}
			i++;
		}

		return ans;
	}

	private static String[] getTwelveHrTimesFromString(String input) {
		Matcher m = HMMA.matcher(input);
		String[] timeArr = new String[4];
		timeArr[INDEX_FOR_TIME_FORMAT] = TWELVE_HR_FORMAT;
		
		int i = 0;
		
		while (m.find() & i < 2) {
			int j = i;
			String time1 = m.group(TIME_H1);
			String min1 = m.group(TIME_M1);
			String apm1 = m.group(TIME_APM1);
			String apm2 = m.group(TIME_APM2);
			String h2 = m.group(TIME_H2);
			String m2 = m.group(TIME_M2);
		
			if (min1 != null) {
				time1 = time1 + ":" + min1.substring(1);
			} else {
				time1 = time1 + ":00";
			}
			
			if (apm1 != null) {
				time1 = time1 + apm1;
			} else {
				time1 = time1 + apm2;
			}
			
			timeArr[j] = time1;
		
			if (i < 1 & (h2 != null)) {
				String time2 = h2;
				if (m2 != null) {
					time2 = time2 + ":" + m2.substring(1) + apm2;
				} else {
					time2 = time2 + ":00" + apm2;
				}
				timeArr[1] = time2;
			}
			
			i++;
		}
		return timeArr;
	}
	
	public static String[] getStandardTimesFromString(String input) {
		if (input == null) {
			return null;
		}
		String[] times = new String[4];
		times = getTwelveHrTimesFromString(input);
		logger.log(Level.FINE, "12HR for " + input + " : " + times[0]);
		if (times[0] == null) {
			times = getTwentyfourHrTimesFromString(input);
			logger.log(Level.FINE, "24HR for " + input + " : " + times[0]);
		} 
		times[INDEX_FOR_NONTIME_STRING] = removeTimesFromString(input);
		// System.out.println(times[3]);
		return times;
	}
	
	private static String removeTimesFromString(String input) {
		input = input.replaceAll(TIME_REGEX, "");
		return input.trim();
	}
	
	public static boolean hasTime(String input) {
		String[] times = getStandardTimesFromString(input);
		if (times[INDEX_FOR_FIRST_TIME] == null) {
			return false;
		} else {
			return true;
		}
	}
}
```
###### parser\TodoParser.java
``` java

package parser;

public class TodoParser extends FlagParser {
	
	ParsedCommand parse(String[] input) {
		return createParsedCommandTodo(input);
	}
}
```
###### test\DateTimeParserTest.java
``` java

package test;

import static org.junit.Assert.*;

import org.junit.Test;

import parser.DateTimeParser;

public class DateTimeParserTest {

	
	@Test
	public void testExtractDateTimeSectionFromString() {
		// Test formatted dates
		assertEquals("12/2/13", DateTimeParser.extractDateTimeSectionFromString("do homework 12/2/13 @1200-1300 #tags \"descriptions...\""));
		assertEquals("2/12/13 12:00 2/12/13 13:00", DateTimeParser.extractDateTimeSectionFromString("do homework 2/12/13 #tags 12:00 to 2/12/13 13:00 #tags \"descriptions...\""));
		
		// Test date keywords
		assertEquals("12/2/13", DateTimeParser.extractDateTimeSectionFromString("do bacon bye homework on 12/2/13 @1200 #tags \"descriptions...\""));
		assertEquals("tmr 3pm", DateTimeParser.extractDateTimeSectionFromString("do homework on essay by tmr 3pm #tags \"descriptions...\""));
		assertEquals("tmr 3pm", DateTimeParser.extractDateTimeSectionFromString("do homework on essay bye tmr 3pm #tags \"descriptions...\""));
		assertEquals("12/2/13 12pm", DateTimeParser.extractDateTimeSectionFromString("do homework by 12/2/13 12pm #tags \"descriptions...\""));
		assertEquals("next tues from 16:00 to 18:00", DateTimeParser.extractDateTimeSectionFromString(" meet john on next tues from 16:00 to 18:00 #cs2103 #proj #cs2101"));
		assertEquals("tmr", DateTimeParser.extractDateTimeSectionFromString("watch tmr"));
		assertEquals("tmr", DateTimeParser.extractDateTimeSectionFromString("meeting by extra tmr"));
		// Test floating tasks
		assertEquals("", DateTimeParser.extractDateTimeSectionFromString("do homework #tags \"descriptions...\""));
		
		
	}
	
}
```
###### test\FlexibleDateTimeParserTest.java
``` java

package test;

import static org.junit.Assert.*;

import org.junit.Test;

import parser.FlexibleDateTimeParser;

public class FlexibleDateTimeParserTest {

	@Test
	public void testGetStandardFlexibleDates() {
		// Test month-date
		assertEquals("2 nov 2015", FlexibleDateTimeParser.getStandardFlexibleDates("November 2 until nov 5")[0]);
		assertEquals("5 nov 2015", FlexibleDateTimeParser.getStandardFlexibleDates("November 2 until nov 5")[1]);
		
		assertEquals("2 nov 2015", FlexibleDateTimeParser.getStandardFlexibleDates("November 2nd to Nov 12th")[0]);
		assertEquals("12 nov 2015", FlexibleDateTimeParser.getStandardFlexibleDates("November 2nd to Nov 12th")[1]);
		
		assertEquals("2 nov 2015", FlexibleDateTimeParser.getStandardFlexibleDates("november 2 2015 to nov 3 2016")[0]);
		assertEquals("3 nov 2016", FlexibleDateTimeParser.getStandardFlexibleDates("november 2 2015 to nov 3 2016")[1]);
		
		// Auto set to next valid date
		/**********COUNTERINTUITIVE!!! TRY SECOND DATE MUST BE AFTER FIRST DATE!!!*******************/
		assertEquals("2 feb 2016", FlexibleDateTimeParser.getStandardFlexibleDates("feb 2 lalala lala dec 5")[0]);
		assertEquals("5 dec 2015", FlexibleDateTimeParser.getStandardFlexibleDates("feb 2 lalala lala dec 5")[1]);
		
		// Test date-month
		assertEquals("2 nov 2015", FlexibleDateTimeParser.getStandardFlexibleDates("2 Nov")[0]);
		assertEquals(null, FlexibleDateTimeParser.getStandardFlexibleDates("2 Nov")[1]);
		
		assertEquals("2 nov 2016", FlexibleDateTimeParser.getStandardFlexibleDates("2nd november to 3rd nov 2016")[0]);
		assertEquals("3 nov 2016", FlexibleDateTimeParser.getStandardFlexibleDates("2nd november to 3rd nov 2016")[1]);
		
		/******************COUNTERINTUITIVE************************************************************/
		// Check no support for year month date
		assertEquals("2 nov 2015", FlexibleDateTimeParser.getStandardFlexibleDates("2012 november 2")[0]);
		
		assertEquals(null, FlexibleDateTimeParser.getStandardFlexibleDates("happy birthday to you")[0]);
		assertEquals(null, FlexibleDateTimeParser.getStandardFlexibleDates("happy birthday to you")[1]);

		assertEquals(null, FlexibleDateTimeParser.getStandardFlexibleDates("")[0]);
		assertEquals(null, FlexibleDateTimeParser.getStandardFlexibleDates("")[1]);

		assertEquals(null, FlexibleDateTimeParser.getStandardFlexibleDates("12 marching 34 93492 342")[0]);
		assertEquals(null, FlexibleDateTimeParser.getStandardFlexibleDates("12 marching 34 93492 342")[1]);		
	}

}
```
###### test\FormattedDateTimeParserTest.java
``` java

package test;

import static org.junit.Assert.*;

import org.junit.Test;

import parser.FormattedDateTimeParser;

public class FormattedDateTimeParserTest {	
	@Test
	public void testGetFormattedDates() {
		// Check supported formats
		// Check support for / for date
		assertEquals("12/2/2013", FormattedDateTimeParser.getStandardFormattedDates("12/2/13 12:00-13:00")[0]);
		assertEquals(null, FormattedDateTimeParser.getStandardFormattedDates("12/2/13 12:00-13:00")[1]);

		// Check support for / for date & 4 digit year
		assertEquals("5/4/2014", FormattedDateTimeParser.getStandardFormattedDates("Hello how 5/4/2014 are you today?")[0]);
		assertEquals("02/12/2014", FormattedDateTimeParser.getStandardFormattedDates("Hello how 02/12/2014 are you today?")[0]);

		// Check support for . for date (and returns in standard format dd/MM/yy)
		assertEquals("2/12/2014", FormattedDateTimeParser.getStandardFormattedDates("Hello how 2.12.14 are you today?")[0]);
		assertEquals("02/12/2014", FormattedDateTimeParser.getStandardFormattedDates("Hello how 02.12.14 are you today?")[0]);

		// Check support for - for date (and returns in standard format dd/MM/yy)
		assertEquals("2/12/2014", FormattedDateTimeParser.getStandardFormattedDates("Hello how 2-12-14 are you today?")[0]);
		assertEquals("02/12/2014", FormattedDateTimeParser.getStandardFormattedDates("Hello how 02-12-14 are you today?")[0]);

		// Check support for mixed date delimiters for date (and returns in standard format dd/MM/yy)
		assertEquals("2/12/2014", FormattedDateTimeParser.getStandardFormattedDates("Hello how 2.12/14 are you today?")[0]);
		assertEquals("02/12/2014", FormattedDateTimeParser.getStandardFormattedDates("Hello how 02-12.14 are you today?")[0]);
		
		// Check support both 02 and 2 etc. for day
		assertEquals("2/12/2014", FormattedDateTimeParser.getStandardFormattedDates("Hello how 2/12/14 are you today?")[0]);
		assertEquals("02/12/2014", FormattedDateTimeParser.getStandardFormattedDates("Hello how 02/12/14 are you today?")[0]);

		// Check support both 02 and 2 etc. for month
		assertEquals("2/02/2014", FormattedDateTimeParser.getStandardFormattedDates("Hello how 2/02/14 are you today?")[0]);
		assertEquals("2/2/2014", FormattedDateTimeParser.getStandardFormattedDates("Hello how 2/2/14 are you today?")[0]);

		// Check required to have whitespace
		assertEquals(null, FormattedDateTimeParser.getStandardFormattedDates("Hello how 12/3/14are you1/10/12 today?")[0]);
		assertEquals(null, FormattedDateTimeParser.getStandardFormattedDates("Hello how 12/3/14are you1/10/12 today?")[1]);
		
		// Check has support for dd/MM
		assertEquals("2/02/2016", FormattedDateTimeParser.getStandardFormattedDates("Hello how 2/02 are you today?")[0]);
		assertEquals(null, FormattedDateTimeParser.getStandardFormattedDates("Hello how 2/02 are you today?")[1]);
		assertEquals("2/2/2014", FormattedDateTimeParser.getStandardFormattedDates("Hello 3.2 how 2/2/14 are you today?")[0]);
		assertEquals(null, FormattedDateTimeParser.getStandardFormattedDates("Hello 3.2 how 2/2/14 are you today?")[1]);
		assertEquals("12/2/2016", FormattedDateTimeParser.getStandardFormattedDates("12/2 until 16/2")[0]);
		assertEquals("16/2/2016", FormattedDateTimeParser.getStandardFormattedDates("12/2 until 16/2")[1]);

		// Check no support for yyyy/MM/dd
		assertEquals(null, FormattedDateTimeParser.getStandardFormattedDates("Hello how 2012/02/14 are you today?")[0]);
		

		// Check invalid inputs return null
		
		// Check invalid day returns null
		assertEquals("32/12/2014", FormattedDateTimeParser.getStandardFormattedDates("Hello how 32/12/14 are you today?")[0]);
		assertEquals(null, FormattedDateTimeParser.getStandardFormattedDates("Hello how 32/12/14 are you today?")[1]);
		
	    // Check invalid month (i.e. numbers more than 12)
		assertEquals("10/13/2014", FormattedDateTimeParser.getStandardFormattedDates("Hello how 10/13/14 are you today?")[0]);
		assertEquals(null, FormattedDateTimeParser.getStandardFormattedDates("Hello how 10/13/14 are you today?")[1]);
		
		// Check invalid year (i.e. non 2-digit number)
		assertEquals(null, FormattedDateTimeParser.getStandardFormattedDates("Hello how 10/12/1 are you today?")[0]);
		assertEquals(null, FormattedDateTimeParser.getStandardFormattedDates("Hello how 10/12/1 are you today?")[1]);
		assertEquals(null, FormattedDateTimeParser.getStandardFormattedDates("Hello how 10/12/123 are you today?")[0]);
		assertEquals(null, FormattedDateTimeParser.getStandardFormattedDates("Hello how 10/12/123 are you today?")[1]);
		
		assertEquals(null, FormattedDateTimeParser.getStandardFormattedDates("hello")[0]);
		assertEquals(null, FormattedDateTimeParser.getStandardFormattedDates("hello")[0]);
		
		
		// Other checks
		
		// Check if more than 2 valid, we get first 2 dates
		assertEquals("1/10/2012", FormattedDateTimeParser.getStandardFormattedDates("Hello how are you 1/10/12 today 2/3/12 2/4/15?")[0]);
		assertEquals("2/3/2012", FormattedDateTimeParser.getStandardFormattedDates("Hello how are you 1/10/12 today 2/3/12 2/4/15?")[1]);
		
		// Check 2 valid dates are accepted
		assertEquals("23/12/2014", FormattedDateTimeParser.getStandardFormattedDates("Hello how 23/12/14 are you 1/5/12 today?")[0]);
		assertEquals("1/5/2012", FormattedDateTimeParser.getStandardFormattedDates("Hello how 23/12/14 are you 1/5/12 today?")[1]);
	}

	/*
	@Test
	public void testConvertStringToCalendar() {
		// Check supported formats
		
		// Check support for events (start and end time)
		String[] dates = FormattedDateTimeParser.getStandardFormattedDates("Hello how 23-12-14 are you @1200-1530 today?");
		String[] times = FormattedDateTimeParser.getFormattedTimes("Hello how 23-12-14 are you @1200-1530 today?");
		assertEquals(StringParser.parseStringToDate("Tue Dec 23 12:00:00 SGT 2014"), FormattedDateTimeParser.convertStringToCalendar(dates, times)[0].getTime());
		assertEquals(StringParser.parseStringToDate("Tue Dec 23 15:30:00 SGT 2014"),FormattedDateTimeParser.convertStringToCalendar(dates, times)[1].getTime());
		
		// Check support for deadline tasks (start time only)
		String[] dates2 = FormattedDateTimeParser.getStandardFormattedDates("Hello how 23-12-14 are you @1200 today?");
		String[] times2 = FormattedDateTimeParser.getFormattedTimes("Hello how 23-12-14 are you @1200 today?");
		assertEquals(StringParser.parseStringToDate("Tue Dec 23 12:00:00 SGT 2014"), FormattedDateTimeParser.convertStringToCalendar(dates2, times2)[0].getTime());
		assertEquals(null, FormattedDateTimeParser.convertStringToCalendar(dates2, times2)[1]);
		
		// Check support for deadline tasks (start date no start time) default timing set to 2359
		String[] dates3 = FormattedDateTimeParser.getStandardFormattedDates("Hello how 23-12-14 are you today?");
		String[] times3 = FormattedDateTimeParser.getFormattedTimes("Hello how 23-12-14 are you today?");
		assertEquals(StringParser.parseStringToDate("Tue Dec 23 23:59:00 SGT 2014"), FormattedDateTimeParser.convertStringToCalendar(dates3, times3)[0].getTime());
		assertEquals(null, FormattedDateTimeParser.convertStringToCalendar(dates3, times3)[1]);

		// Check support for floating tasks (no date/time)
		String[] dates4 = FormattedDateTimeParser.getStandardFormattedDates("Hello how are you today?");
		String[] times4 = FormattedDateTimeParser.getFormattedTimes("Hello how are you today?");
		assertEquals(null, FormattedDateTimeParser.convertStringToCalendar(dates4, times4)[0]);
		assertEquals(null, FormattedDateTimeParser.convertStringToCalendar(dates4, times4)[1]);

		
		// Check invalid inputs
		
		// Check invalid dates return null
		String[] invalidDates = FormattedDateTimeParser.getStandardFormattedDates("Hello how 31/2/14 are you @1200-1530 today?");
		String[] invalidTimes = FormattedDateTimeParser.getFormattedTimes("Hello how 31/2/14 are you @1200-1530 today?");
		assertArrayEquals(null, FormattedDateTimeParser.convertStringToCalendar(invalidDates, invalidTimes));
		
		// Check invalid times are ignored (treated as with date, no time) (if start time is incorrect, end time ignored)
		String[] invalidDates2 = FormattedDateTimeParser.getStandardFormattedDates("Hello how 23/12/14 are you @2900-1530 today?");
		String[] invalidTimes2 = FormattedDateTimeParser.getFormattedTimes("Hello how 23/12/14 are you @2900-1530 today?");
		assertEquals(StringParser.parseStringToDate("Tue Dec 23 23:59:00 SGT 2014"), FormattedDateTimeParser.convertStringToCalendar(invalidDates2, invalidTimes2)[0].getTime());
		assertEquals(null, FormattedDateTimeParser.convertStringToCalendar(invalidDates2, invalidTimes2)[1]);
	}*/
}
```
###### test\MyParserTest.java
``` java

	public static Calendar nextDayOfWeek(int day) {
        Calendar date = Calendar.getInstance();
        int difference = day - date.get(Calendar.DAY_OF_WEEK);
        if (difference < 0) {
            difference += 7;
        }
        date.add(Calendar.DAY_OF_MONTH, difference);
        return date;
    }
	
	@Before
	public void setUp() throws Exception {
	    initLogging();
	}

	@Test
	public void testParseCommand() {
		// Check null input returns no user input error
		pc = MyParser.parseCommand(null);
		assertEquals(MyParser.CommandType.ERROR, pc.getCommandType());
		assertEquals("Error: No user input", pc.getErrorMessage());

		// Check empty string returns no user input error
		pc = MyParser.parseCommand("");
		assertEquals(MyParser.CommandType.ERROR, pc.getCommandType());
		assertEquals("Error: No user input", pc.getErrorMessage());

		// Check empty input returns no user input error
		pc = MyParser.parseCommand(" ");
		assertEquals(MyParser.CommandType.ERROR, pc.getCommandType());
		assertEquals("Error: No user input", pc.getErrorMessage());

		// Check unrecognised command returns invalid command error
		pc = MyParser.parseCommand("hello");
		assertEquals(MyParser.CommandType.ERROR, pc.getCommandType());
		assertEquals("Error: Invalid command", pc.getErrorMessage());
	}

	@Test
	public void testParseCommandAdd() {
		ArrayList<String> taskTags = new ArrayList<String>();
		taskTags.add("cs2103");
		taskTags.add("proj");
		taskTags.add("cs2101");

		// Check support for floating task
		pcAdd = MyParser.parseCommand("Add meeting with john #cs2103 #proj \"rmb to \"bring\" notes\" #cs2101");
		assertEquals(MyParser.CommandType.ADD, pcAdd.getCommandType());
		assertEquals("meeting with john", pcAdd.getTitle());
		assertEquals("rmb to \"bring\" notes", pcAdd.getDescription());
		assertEquals(null, pcAdd.getFirstDate());
		assertEquals(null, pcAdd.getSecondDate());
		assertEquals(taskTags, pcAdd.getTags());
		assertEquals(TaskType.FLOATING_TASK, pcAdd.getTaskType());

        
		// Check support for floating task containing keyword
		pcAdd = MyParser.parseCommand("Add meeting with \\\"john\\\" on software requirements #cs2103 #proj #cs2101");
		assertEquals(CommandType.ADD, pcAdd.getCommandType());
		assertEquals("meeting with \"john\" on software requirements", pcAdd.getTitle());
		assertEquals(null, pcAdd.getDescription());
		assertEquals(null, pcAdd.getFirstDate());
		assertEquals(null, pcAdd.getSecondDate());
		assertEquals(taskTags, pcAdd.getTags());
		assertEquals(TaskType.FLOATING_TASK, pcAdd.getTaskType());
		
		// Check support for floating task containing keyword
		pcAdd = MyParser.parseCommand("Add meeting with john on 3 software requirements #cs2103 #proj #cs2101");
		assertEquals(CommandType.ADD, pcAdd.getCommandType());
		assertEquals("meeting with john on 3 software requirements", pcAdd.getTitle());
		assertEquals(null, pcAdd.getDescription());
		assertEquals(null, pcAdd.getFirstDate());
		assertEquals(null, pcAdd.getSecondDate());
		assertEquals(taskTags, pcAdd.getTags());
		assertEquals(TaskType.FLOATING_TASK, pcAdd.getTaskType());
		/* NOT SUPPORTED YET
		*/

		// Check support for deadline task formatted date (no keyword)
		pcAdd = MyParser.parseCommand("INSERT meeting with john 1/4/15 from 3pm to 7.30pm");
		assertEquals(MyParser.CommandType.ADD, pcAdd.getCommandType());
		assertEquals("meeting with john", pcAdd.getTitle());
		assertEquals(null, pcAdd.getDescription());
		assertEquals(StringParser.parseStringToDate("Wed Apr 1 15:00:00 SGT 2015"), pcAdd.getFirstDate().getTime());
		assertEquals(StringParser.parseStringToDate("Wed Apr 1 19:30:00 SGT 2015"), pcAdd.getSecondDate().getTime());
		assertEquals(emptyArrayList, pcAdd.getTags());
		assertEquals(TaskType.EVENT, pcAdd.getTaskType());
		
		// Check support for deadline task natty
		pcAdd = MyParser.parseCommand("+ meeting with john on tmr at 12pm");
		assertEquals(MyParser.CommandType.ADD, pcAdd.getCommandType());
		assertEquals("meeting with john", pcAdd.getTitle());
		assertEquals(null, pcAdd.getDescription());
		LocalDateTime dt = LocalDateTime.now();
		dt = LocalDateTime.from(dt.plusDays(1));
		dt = dt.withHour(12).withMinute(0).withSecond(0);
		assertEquals(Date.from(dt.atZone(ZoneId.systemDefault()).toInstant()).toString(), pcAdd.getFirstDate().getTime().toString());
		assertEquals(null, pcAdd.getSecondDate());
		assertEquals(emptyArrayList, pcAdd.getTags());
		assertEquals(TaskType.DEADLINE_TASK, pcAdd.getTaskType());
		
		// Check support for deadline task natty
		pcAdd = MyParser.parseCommand("Add meeting with john on tmr");
		assertEquals(MyParser.CommandType.ADD, pcAdd.getCommandType());
		assertEquals("meeting with john", pcAdd.getTitle());
		assertEquals(null, pcAdd.getDescription());
		dt = LocalDateTime.now();
		dt = LocalDateTime.from(dt.plusDays(1));
		dt = dt.withHour(23).withMinute(59).withSecond(0);
		assertEquals(Date.from(dt.atZone(ZoneId.systemDefault()).toInstant()).toString(), pcAdd.getFirstDate().getTime().toString());
		assertEquals(null, pcAdd.getSecondDate());
		assertEquals(emptyArrayList, pcAdd.getTags());
		assertEquals(TaskType.DEADLINE_TASK, pcAdd.getTaskType());
		
		// Check support for event spanning 2 days
		pcAdd = MyParser.parseCommand("add meeting with john 23/11/10 12:00h to 24/11/10 13:30H  #cs2103 #proj #cs2101");
		assertEquals(MyParser.CommandType.ADD, pcAdd.getCommandType());
		assertEquals("meeting with john", pcAdd.getTitle());
		assertEquals(null, pcAdd.getDescription());
		assertEquals(StringParser.parseStringToDate("Tue Nov 23 12:00:00 SGT 2010"), pcAdd.getFirstDate().getTime());
		assertEquals(StringParser.parseStringToDate("Wed Nov 24 13:30:00 SGT 2010"), pcAdd.getSecondDate().getTime());
		assertEquals(TaskType.EVENT, pcAdd.getTaskType());
		
		// Check support for event spanning 2 days
		/*
		pcAdd = MyParser.parseCommand("add meeting with john on next mon till next tues #cs2103 #proj #cs2101");
		assertEquals(MyParser.CommandType.ADD, pcAdd.getCommandType());
		assertEquals("meeting with john", pcAdd.getTitle());
		assertEquals(null, pcAdd.getDescription());
		assertEquals(StringParser.parseStringToDate("Mon Nov 2 23:59:00 SGT 2015"), pcAdd.getFirstDate().getTime());
		assertEquals(StringParser.parseStringToDate("Tue Nov 3 23:59:00 SGT 2015"), pcAdd.getSecondDate().getTime());
		assertEquals(TaskType.EVENT, pcAdd.getTaskType());
		*/	
		/********************DEFINITION OF 'NEXT TUES'???****************************/
		/*
		// Check support for event spanning 2 days
		pcAdd = ParsedCommand.parseCommand("Add meeting with john on next tues 2pm until next thurs 3pm  #cs2103 #proj #cs2101");
		assertEquals(CommandType.ADD, pcAdd.getCommandType());
		assertEquals("meeting with john", pcAdd.getTitle());
		assertEquals(null, pcAdd.getDescription());
		Calendar firstDate = nextDayOfWeek(Calendar.TUESDAY);
		Calendar secondDate = nextDayOfWeek(Calendar.THURSDAY);
		firstDate.set(Calendar.HOUR_OF_DAY, 14);
		firstDate.set(Calendar.MINUTE, 0);
		firstDate.set(Calendar.SECOND, 0);
		firstDate.set(Calendar.MILLISECOND, 0);
		secondDate.set(Calendar.HOUR_OF_DAY, 15);
		secondDate.set(Calendar.MINUTE, 0);
		secondDate.set(Calendar.SECOND, 0);
		secondDate.set(Calendar.MILLISECOND, 0);
		assertEquals(firstDate.getTime(), pcAdd.getFirstDate().getTime());
		assertEquals(secondDate.getTime(), pcAdd.getSecondDate().getTime());
		assertEquals(TaskType.EVENT, pcAdd.getTaskType());
		*/
		// Check invalid date returns invalid date error, where invalid date is in proper format
		pcAdd = MyParser.parseCommand("Add meeting with john 31/4/10 12:00h #proj");
		assertEquals(MyParser.CommandType.ERROR, pcAdd.getCommandType());
		assertEquals("Error: Invalid date(s) input", pcAdd.getErrorMessage());
		
		// Check missing arguments returns no arguments error
		pcAdd = MyParser.parseCommand("Add");
		assertEquals(MyParser.CommandType.ERROR, pcAdd.getCommandType());
		assertEquals("Error: No arguments entered", pcAdd.getErrorMessage());
	
		// Check missing title returns no title error
		pcAdd = MyParser.parseCommand("Add 2/3/15 3pm \"hello hello\" #tag1 #tag2");
		assertEquals(MyParser.CommandType.ERROR, pcAdd.getCommandType());
		assertEquals("Error: Missing task title", pcAdd.getErrorMessage());

		// Check missing title returns no title error
		pcAdd = MyParser.parseCommand("Add on tmr 3pm \"hello hello\" #tag1 #tag2");
		assertEquals(MyParser.CommandType.ERROR, pcAdd.getCommandType());
		assertEquals("Error: Missing task title", pcAdd.getErrorMessage());
	}

	@Test
	public void testParseCommandDelete() {
		// Check delete
		pcDelete = MyParser.parseCommand("Delete 234");
		assertEquals(MyParser.CommandType.DELETE, pcDelete.getCommandType());
		assertEquals(234, pcDelete.getTaskId());

		// Check allow extra whitespace
		pcDelete = MyParser.parseCommand("Delete  234");
		assertEquals(MyParser.CommandType.DELETE, pcDelete.getCommandType());
		assertEquals(234, pcDelete.getTaskId());

		// Check missing arguments returns no arguments error
		pcDelete = MyParser.parseCommand("delete");
		assertEquals(MyParser.CommandType.ERROR, pcDelete.getCommandType());
		assertEquals("Error: No arguments entered", pcDelete.getErrorMessage());

		// Check invalid/missing taskId returns error
		pcDelete = MyParser.parseCommand("delete abc");
		assertEquals(MyParser.CommandType.ERROR, pcDelete.getCommandType());
		assertEquals("Error: Invalid/Missing taskId", pcDelete.getErrorMessage());
	}

	@Test
	public void testParseCommandDisplay() {
		pcDisplay = MyParser.parseCommand("show 234");
		assertEquals(MyParser.CommandType.DISPLAY, pcDisplay.getCommandType());
		assertEquals(234, pcDisplay.getTaskId());

		// Check allow extra whitespace
		pcDisplay = MyParser.parseCommand("show  	234");
		assertEquals(MyParser.CommandType.DISPLAY, pcDisplay.getCommandType());
		assertEquals(234, pcDisplay.getTaskId());

		// Check missing arguments returns GUI command
		pcDisplay = MyParser.parseCommand("show");
		assertEquals(MyParser.CommandType.GUI_SHOW, pcDisplay.getCommandType());
		
		pcDisplay = MyParser.parseCommand("search 23/11/15");
		assertEquals(MyParser.CommandType.SEARCH, pcDisplay.getCommandType());
		//assertEquals("meeting", pcDisplay.getKeywords());
		assertEquals(StringParser.parseStringToDate("Mon Nov 23 00:00:00 SGT 2015"), pcDisplay.getFirstDate().getTime());
		assertEquals(StringParser.parseStringToDate("Mon Nov 23 23:59:00 SGT 2015"), pcDisplay.getSecondDate().getTime());
		
		// Check search function works
		pcDisplay = MyParser.parseCommand("show meeting 23/11/15 #tag todo deadline");
		assertEquals(MyParser.CommandType.SEARCH, pcDisplay.getCommandType());
		assertEquals("meeting", pcDisplay.getKeywords());
		assertEquals(StringParser.parseStringToDate("Mon Nov 23 00:00:00 SGT 2015"), pcDisplay.getFirstDate().getTime());
		assertEquals(StringParser.parseStringToDate("Mon Nov 23 23:59:00 SGT 2015"), pcDisplay.getSecondDate().getTime());
		ArrayList<String> list = new ArrayList<String>();
		list.add("tag");
		assertEquals(list, pcDisplay.getTags());
		assertEquals(false, pcDisplay.isCompleted());
		assertEquals(TaskType.DEADLINE_TASK, pcDisplay.getTaskType());
		
		// Check search function works
		pcDisplay = MyParser.parseCommand("show meeting 23/11/15 23:59 #tag todo");
		assertEquals(MyParser.CommandType.SEARCH, pcDisplay.getCommandType());
		assertEquals("meeting", pcDisplay.getKeywords());
		assertEquals(StringParser.parseStringToDate("Mon Nov 23 23:59:00 SGT 2015"), pcDisplay.getFirstDate().getTime());
		assertEquals(StringParser.parseStringToDate("Mon Nov 23 23:59:00 SGT 2015"), pcDisplay.getSecondDate().getTime());
		list = new ArrayList<String>();
		list.add("tag");
		assertEquals(list, pcDisplay.getTags());
		assertEquals(false, pcDisplay.isCompleted());
		assertEquals(null, pcDisplay.getTaskType());
	}

	@Test
	public void testParseCommandEdit() {
		// Check support for invalid date
		pcEdit = MyParser.parseCommand("Edit   234 meeting 31/2/15 \"hello\" #tag");
		assertEquals(MyParser.CommandType.ERROR, pcEdit.getCommandType());
						
		// Check support for edit title, description, date, time, tag
		pcEdit = MyParser.parseCommand("Edit 234 meeting \"hello\" 23/11/10 13:00-15:00 #tag");
		assertEquals(MyParser.CommandType.EDIT, pcEdit.getCommandType());
		assertEquals("hello", pcEdit.getDescription());
		assertEquals(StringParser.parseStringToDate("Tue Nov 23 13:00:00 SGT 2010"), pcEdit.getFirstDate().getTime());
		assertEquals(StringParser.parseStringToDate("Tue Nov 23 15:00:00 SGT 2010"), pcEdit.getSecondDate().getTime());
		ArrayList<String> list = new ArrayList<String>();
		list.add("tag");
		assertEquals(list, pcEdit.getTags());
		assertEquals("meeting", pcEdit.getTitle());
		
		// Check support for edit description, date, time, tag (flexible)
		pcEdit = MyParser.parseCommand("Edit 234 by nov 23 1-3pm \"hello\" #tag");
		assertEquals(MyParser.CommandType.EDIT, pcEdit.getCommandType());
		assertEquals("hello", pcEdit.getDescription());
		assertEquals(StringParser.parseStringToDate("Mon Nov 23 13:00:00 SGT 2015"), pcEdit.getFirstDate().getTime());
		assertEquals(StringParser.parseStringToDate("Mon Nov 23 15:00:00 SGT 2015"), pcEdit.getSecondDate().getTime());
		ArrayList<String> list1 = new ArrayList<String>();
		list1.add("tag");
		assertEquals(list1, pcEdit.getTags());
		assertEquals("", pcEdit.getTitle());
		
		// Check allow extra whitespace
		pcEdit = MyParser.parseCommand("Edit 234 test");
		assertEquals(MyParser.CommandType.EDIT, pcEdit.getCommandType());
		assertEquals(234, pcEdit.getTaskId());
		assertEquals("test", pcEdit.getTitle());
		
		// Check missing field inputs returns error
		pcEdit = MyParser.parseCommand("Edit 234");
		assertEquals(MyParser.CommandType.ERROR, pcEdit.getCommandType());
		assertEquals("Error: No fields were entered for editing", pcEdit.getErrorMessage());

		// Check missing arguments returns error
		pcEdit = MyParser.parseCommand("edit");
		assertEquals(MyParser.CommandType.ERROR, pcEdit.getCommandType());
		assertEquals("Error: No arguments entered", pcEdit.getErrorMessage());

		// Check invalid taskId returns error
		pcEdit = MyParser.parseCommand("edit abc #hello");
		assertEquals(MyParser.CommandType.ERROR, pcEdit.getCommandType());
		assertEquals("Error: Invalid/Missing taskId", pcEdit.getErrorMessage());
		
		// Check invalid date returns error
		pcEdit = MyParser.parseCommand("edit 123 31/2/16 #hello");
		assertEquals(MyParser.CommandType.ERROR, pcEdit.getCommandType());
		assertEquals("Error: Invalid date(s) input", pcEdit.getErrorMessage());
	}

	@Test
	public void testParseCommandUndo() {
		pcUndo = MyParser.parseCommand("Undo");
		assertEquals(MyParser.CommandType.UNDO, pcUndo.getCommandType());
	}
	
	@Test
	public void testParseCommandHelp() {
		pcHelp = MyParser.parseCommand("help");
		assertEquals(MyParser.CommandType.HELP, pcHelp.getCommandType());
	}

	@Test
	public void testParseCommandFlag() {
		// Partition 1: FLAG
		// Check flag command for done
		pcDone = MyParser.parseCommand("Flag completed 234");
		assertEquals(MyParser.CommandType.FLAG, pcDone.getCommandType());
		assertEquals(true, pcDone.isCompleted());
		assertEquals(234, pcDone.getTaskId());
		
		// Check flag for todo
		pcDone = MyParser.parseCommand("flag   TODO  234");
		assertEquals(MyParser.CommandType.FLAG, pcDone.getCommandType());
		assertEquals(false, pcDone.isCompleted());
		assertEquals(234, pcDone.getTaskId());

		
		// Partition 2: DONE
		// Check standard input
		pcDone = MyParser.parseCommand("Done 234");
		assertEquals(MyParser.CommandType.FLAG, pcDone.getCommandType());
		assertEquals(true, pcDone.isCompleted());
		assertEquals(234, pcDone.getTaskId());

		// Check allow extra whitespace
		pcDone = MyParser.parseCommand("finished  234");
		assertEquals(MyParser.CommandType.FLAG, pcDone.getCommandType());
		assertEquals(true, pcDone.isCompleted());
		assertEquals(234, pcDone.getTaskId());

		// Check missing arguments returns error
		pcDone = MyParser.parseCommand("done ");
		assertEquals(MyParser.CommandType.ERROR, pcDone.getCommandType());
		assertEquals("Error: No arguments entered", pcDone.getErrorMessage());

		// Check invalid/missing taskId returns error
		pcDone = MyParser.parseCommand("done abc");
		assertEquals(MyParser.CommandType.ERROR, pcDone.getCommandType());
		assertEquals("Error: Invalid/Missing taskId", pcDone.getErrorMessage());
		
		
		// Partition 3: TODO (similar pathway as DONE)
		pcDone = MyParser.parseCommand("todo 234");
		assertEquals(MyParser.CommandType.FLAG, pcDone.getCommandType());
		assertEquals(false, pcDone.isCompleted());
		assertEquals(234, pcDone.getTaskId());
	}
	
	@Test
	public void testGetErrorMessage() {
		// Check returns null if irrelevant (not an error)
		pcDone = MyParser.parseCommand("Done 234");
		assertEquals(MyParser.CommandType.FLAG, pcDone.getCommandType());
		assertEquals(null, pcDone.getErrorMessage());
	}
	
	@Test
	public void testParseCommandConfig() {
		// Check missing config type
		pcConfig = MyParser.parseCommand("Set");
		assertEquals(MyParser.CommandType.ERROR, pcConfig.getCommandType());
		assertEquals("Error: No arguments entered", pcConfig.getErrorMessage());
		
		// Check invalid config type
		pcConfig = MyParser.parseCommand("Set file");
		assertEquals(MyParser.CommandType.ERROR, pcConfig.getCommandType());
		assertEquals("Error: Invalid command", pcConfig.getErrorMessage());
		
		// Check missing path
		pcConfig = MyParser.parseCommand("set folder");
		assertEquals(MyParser.CommandType.ERROR, pcConfig.getCommandType());
		assertEquals("Error: No arguments entered", pcConfig.getErrorMessage());
		
		// Check missing path
		pcConfig = MyParser.parseCommand("set background");
		assertEquals(MyParser.CommandType.ERROR, pcConfig.getCommandType());
		assertEquals("Error: No arguments entered", pcConfig.getErrorMessage());
				
		// Check config data
		pcConfig = MyParser.parseCommand("set folder C:\\file name\\folder");
		assertEquals(MyParser.CommandType.CONFIG_DATA, pcConfig.getCommandType());
		assertEquals("C:\\file name\\folder", pcConfig.getConfigPath());
		
		// Check config img background
		pcConfig = MyParser.parseCommand("set background filePath");
		assertEquals(MyParser.CommandType.CONFIG_IMG, pcConfig.getCommandType());
		assertEquals(ConfigType.BACKGROUND, pcConfig.getConfigType());
		assertEquals("filePath", pcConfig.getConfigPath());
						
		// Check config img avatar
		pcConfig = MyParser.parseCommand("set avatar filePath");
		assertEquals(MyParser.CommandType.CONFIG_IMG, pcConfig.getCommandType());
		assertEquals(ConfigType.AVATAR, pcConfig.getConfigType());
		assertEquals("filePath", pcConfig.getConfigPath());
		
	}
	
	@Test
	public void testGuiCommands() {
		pcGui = MyParser.parseCommand("Open 1");
		assertEquals(CommandType.GUI_OPEN, pcGui.getCommandType());
		assertEquals("1", pcGui.getGuiType());
		
		String tabName = GUIController.taskListNames[2];
		pcGui = MyParser.parseCommand("Close " + tabName);
		assertEquals(CommandType.GUI_CLOSE, pcGui.getCommandType());
		assertEquals("2", pcGui.getGuiType());
		
		pcGui = MyParser.parseCommand("Close random");
		assertEquals(CommandType.ERROR, pcGui.getCommandType());
		assertEquals("Error: Invalid tab ID", pcGui.getErrorMessage());
		
		pcGui = MyParser.parseCommand("pin");
		assertEquals(CommandType.ERROR, pcGui.getCommandType());
		assertEquals("Error: No arguments entered", pcGui.getErrorMessage());
		
		pcGui = MyParser.parseCommand("log");
		assertEquals(CommandType.GUI_LOG, pcGui.getCommandType());
		
		pcGui = MyParser.parseCommand("mAin");
		assertEquals(CommandType.GUI_MAIN, pcGui.getCommandType());
		
		// Missing switch test
	}
}
```
###### test\ParserTestRunner.java
``` java

package test;

import org.junit.runner.JUnitCore;
import org.junit.runner.Result;
import org.junit.runner.notification.Failure;

public class ParserTestRunner {
	public static void main(String[] args) {
	      Result result = JUnitCore.runClasses(ParserTestSuite.class);
	      for (Failure failure : result.getFailures()) {
	         System.out.println(failure.toString());
	      }
	      System.out.println(result.wasSuccessful());
	   }
}


```
###### test\ParserTestSuite.java
``` java

package test;

import org.junit.runner.RunWith;
import org.junit.runners.Suite;

@RunWith(Suite.class)
@Suite.SuiteClasses({ 
   MyParserTest.class,
   DateTimeParserTest.class,
   TimeParserTest.class,
   FormattedDateTimeParserTest.class,
   FlexibleDateTimeParserTest.class,
   NattyDateTimeParserTest.class,
   parser.InputParserTest.class,
   parser.ShowParserTest.class
})
public class ParserTestSuite {

}
```
###### test\TimeParserTest.java
``` java

package test;

import static org.junit.Assert.*;

import org.junit.Test;

import parser.TimeParser;

public class TimeParserTest {

	@Test
	public void testGetStandardTimesFromString() {
		// Partition 1: 12 hr times
		// Test 12 hr format complete (formatted times), time at end
		assertEquals("12:30pm", TimeParser.getStandardTimesFromString("hello i have 10 class tmr 12.30pm-2.30pm")[0]);
		assertEquals("2:30pm", TimeParser.getStandardTimesFromString("hello i have 10 class tmr 12.30pm-2.30pm 1322")[1]);
		
		// Test 12 hr format, no am/pm for first time, whitespace (formatted times) 
		assertEquals("12:30pm", TimeParser.getStandardTimesFromString("hello i have class tmr 12.30 - 2.30 pm")[0]);
		assertEquals("2:30pm", TimeParser.getStandardTimesFromString("hello i have class tmr 12.30 - 2.30 pm")[1]);
		
		// Test no minutes indicated (start), am & pm (formatted times), time in middle
		assertEquals("8:00am", TimeParser.getStandardTimesFromString("hello i have 8am-2.30pm test")[0]);
		assertEquals("2:30pm", TimeParser.getStandardTimesFromString("hello i have 8am-2.30pm test")[1]);
		
		// Test no minutes indicated (end), whitespace (formatted times), time at the beginning
		assertEquals("9:30am", TimeParser.getStandardTimesFromString("9.30 - 11am on 2 feb")[0]);
		assertEquals("11:00am", TimeParser.getStandardTimesFromString("9.30 - 11am on 2 feb")[1]);
		
		// Test 'to' is acceptable delimiter, don't need am/pm
		assertEquals("8:00pm", TimeParser.getStandardTimesFromString("8 to 3pm")[0]);
		assertEquals("3:00pm", TimeParser.getStandardTimesFromString("8 to 3pm")[1]);
		
		// Test separated times, only am/pm times are detected
		assertEquals("11:00am", TimeParser.getStandardTimesFromString("tmr 9.30 hello lala 11am test 3.30pm")[0]);
		assertEquals("3:30pm", TimeParser.getStandardTimesFromString("tmr 9.30 hello lala 11am test 3.30pm")[1]);
		
		// Test start time only
		assertEquals("9:30am", TimeParser.getStandardTimesFromString("hello i have class tmr 9.30 am")[0]);
		assertEquals(null, TimeParser.getStandardTimesFromString("hello i have class tmr 9.30 am")[1]);
		
		
		// Partition 2: 24 hr times
		// Test separated times, no am/pm/h, time in beginning
		assertEquals("12:00", TimeParser.getStandardTimesFromString("12:00 lalala 13:20 lala")[0]);
		assertEquals("13:20", TimeParser.getStandardTimesFromString("12:00 lalala 13:20 lala")[1]);

		// Test separated times, no am/pm/h, time in beginning
		assertEquals("12:00", TimeParser.getStandardTimesFromString("12:00 until 13:20 lala")[0]);
		assertEquals("13:20", TimeParser.getStandardTimesFromString("12:00 until 13:20 lala")[1]);

		// Test with h, H, time at end
		assertEquals("12:00", TimeParser.getStandardTimesFromString("12/2/13 Meet John about proposal #cs2103 12:00 h - 13:30H")[0]);
		assertEquals("13:30", TimeParser.getStandardTimesFromString("12/2/13 Meet John about proposal #cs2103 12:00 - 13:30H")[1]);
		
		// Test no h/H, not separated (formatted times), time in middle
		assertEquals("12:00", TimeParser.getStandardTimesFromString("12/2/13 Meet John about proposal #cs2103 12:00-13:30 la la ")[0]);
		assertEquals("13:30", TimeParser.getStandardTimesFromString("12/2/13 Meet John about proposal #cs2103 12:00-13:30 la la ")[1]);
		
		
		// Partition 3: No times
		// Test non-time numbers are not detected
		assertEquals(null, TimeParser.getStandardTimesFromString("12/2/13 Meet John about 1200 proposal #cs2103")[0]);
		assertEquals(null, TimeParser.getStandardTimesFromString("12/2/13 Meet John about 1200 proposal #cs2103")[1]);

		
		// Partition 4: Invalid times 
		// Test invalid 12h times are accepted
		assertEquals("12:30pm", TimeParser.getStandardTimesFromString("hello i have class tmr 12:30-14:30pm")[0]);
		assertEquals("14:30pm", TimeParser.getStandardTimesFromString("hello i have class tmr 12:30-14:30pm")[1]);

		// Test invalid 24h times are accepted
		assertEquals("50:00", TimeParser.getStandardTimesFromString("hello i have class tmr 50:00-99:30h")[0]);
		assertEquals("99:30", TimeParser.getStandardTimesFromString("hello i have class tmr 50:00-99:30h")[1]);
				
		
		// Partition 5: Undetected formats
		// Test must have space before and after 24h time
		assertEquals(null, TimeParser.getStandardTimesFromString("hello i have $2:00 in my 3:00hello")[0]);
		assertEquals(null, TimeParser.getStandardTimesFromString("hello i have $2:00 in my 3:00hello")[1]);
				
		// Test must have space before and after 12h time
		assertEquals(null, TimeParser.getStandardTimesFromString("hello i have 2amphitheatres in3pm my pocket")[0]);
		assertEquals(null, TimeParser.getStandardTimesFromString("hello i have 2amphitheatres in3pm my pocket")[1]);		
		
		// Test invalid hour and minutes for 12 hr
		assertEquals(null, TimeParser.getStandardTimesFromString("hello i have 009:00am in my 3:0pm hello")[0]);
		assertEquals(null, TimeParser.getStandardTimesFromString("hello i have 009:00am in my 3:0pm hello")[1]);
						
		// Test invalid first time means second time is ignored for -
		assertEquals("15:00", TimeParser.getStandardTimesFromString("hello i have 112:00-13:00 my 15:00 pocket")[0]);
		assertEquals(null, TimeParser.getStandardTimesFromString("hello i have 112:00-13:00 my 15:00 pocket")[1]);		
		// Test invalid minutes for 24h
		assertEquals(null, TimeParser.getStandardTimesFromString("hello i have 13:0 my 15:000 pocket")[0]);
		assertEquals(null, TimeParser.getStandardTimesFromString("hello i have 13:0 my 15:000 pocket")[1]);		
				
				
		// Boundary values
		// Test empty string (NOTE: impossible to get null value)
		assertEquals(null, TimeParser.getStandardTimesFromString("")[0]);
		assertEquals(null, TimeParser.getStandardTimesFromString("")[1]);
		
		// Test empty string (NOTE: impossible to get null value)
		assertArrayEquals(null, TimeParser.getStandardTimesFromString(null));
	}
	
	@Test
	public void testGetStandardTimesFromStringNatty() {
		assertEquals("next monday  to next friday", TimeParser.getStandardTimesFromString("next monday 12.30pm to next friday 2.30pm")[3]);
		assertEquals("next tuesday", TimeParser.getStandardTimesFromString("next tuesday 3 until 7pm")[3]);
	}
		
		
}
```
