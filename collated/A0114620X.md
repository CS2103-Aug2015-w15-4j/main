# A0114620X
###### parser\AddParser.java
``` java

package parser;

import java.util.ArrayList;
import java.util.Calendar;

public class AddParser extends InputParser {

	protected ParsedCommand parse(String[] input) {
		if (isMissingArguments(input)) {
			return createParsedCommandError(ERROR_MISSING_ARGS);
		} else {
			String inputArgs = input[INDEX_FOR_ARGS];
			
			try {
				String parsedTitle = getTitleWithDateKeywords(inputArgs);
				Calendar[] parsedTimes = getStandardDatesTimes(inputArgs);
				if (mustRemoveDateKeywordSection(parsedTimes, inputArgs)) { 
					parsedTitle = removeDateKeywordSection(parsedTitle);
				}
				String parsedDescription = getDescriptionFromString(inputArgs);
				ArrayList<String> parsedTags = getTagsFromString(inputArgs);
				
				ParsedCommand pc = new ParsedCommand.ParsedCommandBuilder(MyParser.CommandType.ADD)
													.title(parsedTitle)
													.times(parsedTimes)
													.description(parsedDescription)
													.tags(parsedTags)
													.build();
				return pc;
			} catch (InvalidArgumentsForParsedCommandException e) {
				return InputParser.createParsedCommandError(e.getMessage());
			}
		}
	}	
}
```
###### parser\CloseParser.java
``` java

package parser;

import parser.MyParser.CommandType;

public class CloseParser extends GuiParser {

	protected ParsedCommand parse(String[] input) {
		return createParsedCommandGuiTabAction(CommandType.GUI_CLOSE, input);
	}

}
```
###### parser\ConfigParser.java
``` java

package parser;

import parser.MyParser.CommandType;
import parser.ParsedCommand.ConfigType;

public class ConfigParser extends InputParser {

	protected ParsedCommand parse(String[] input) {
		if (isMissingArguments(input)) {
			return createParsedCommandError(ERROR_MISSING_ARGS);
		} else {
			String[] subInput = input[INDEX_FOR_ARGS].split(" ", 2);
			String subCommand = subInput[INDEX_FOR_SUBCMD];
			if (subCommand.equalsIgnoreCase("folder")) {
				return createParsedCommandConfigData(subInput);
			} else {
				return createParsedCommandConfigImg(subInput);
			}
		}
	}

	static ParsedCommand createParsedCommandConfigImg(String[] input) {
		ConfigType configType = determineConfigImgType(input[INDEX_FOR_SUBCMD]);
		if (configType != ConfigType.INVALID) {
			if (isMissingArguments(input)) {
				return createParsedCommandError(ERROR_MISSING_ARGS);
			}
			try {
				String fileName = input[INDEX_FOR_SUBARGS];
				ParsedCommand pc = new ParsedCommand.ParsedCommandBuilder(CommandType.CONFIG_IMG)
													.configType(configType)
													.configPath(fileName)
													.build();
				return pc;
			} catch (InvalidArgumentsForParsedCommandException e) {
				return createParsedCommandError(e.getMessage());
			}
		} else {
			return InputParser.createParsedCommandError(InputParser.ERROR_INVALID_COMMAND);
		}
	}

	static ParsedCommand createParsedCommandConfigData(String[] input) {
		if (isMissingArguments(input)) { 
			return createParsedCommandError(ERROR_MISSING_ARGS);
		} else {
			try {
				String fileName = input[INDEX_FOR_SUBARGS];
				ParsedCommand pc = new ParsedCommand.ParsedCommandBuilder(MyParser.CommandType.CONFIG_DATA)
						  			  				.configPath(fileName)
						  			  				.build();
				return pc;
			} catch (InvalidArgumentsForParsedCommandException e){
				return createParsedCommandError(e.getMessage());
			}
		}
	}

	static ParsedCommand.ConfigType determineConfigImgType(String subCommand) {
		if (subCommand.equalsIgnoreCase("background")) {
			return ParsedCommand.ConfigType.BACKGROUND;
		} else if (subCommand.equalsIgnoreCase("avatar")) {
			return ParsedCommand.ConfigType.AVATAR;
		} else {
			return ParsedCommand.ConfigType.INVALID;
		}
	}

}
```
###### parser\DateTime.java
``` java

package parser;

import java.text.SimpleDateFormat;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.time.format.DateTimeParseException;
import java.util.Calendar;

public class DateTime {
    public enum ParserType {
        FORMATTED_PARSER, FLEXIBLE_PARSER, NATTY_PARSER;
    }
    static LocalDate today = LocalDate.now();
	private static final String CURR_YEAR = String.valueOf(today.getYear());
	
	
	private static final int INDEX_FOR_DATE = 0;
	private static final int INDEX_FOR_MONTH = 1;
	private static final int INDEX_FOR_YEAR = 2;
	
	private String[] startDate;
    private String[] endDate;
    private String startTime;
    private String endTime;
	private Boolean isValid;
	private ParserType parser;
    
    public DateTime(DateTimeBuilder builder) {
    	 this.startDate = builder.startDate;
    	 this.endDate = builder.endDate;
    	 this.startTime = builder.startTime;
    	 this.endTime = builder.endTime;
 		 this.isValid = builder.isValid;
 		 this.parser = builder.parser;
	}

	Calendar[] getSearchDatesTimes() {
		standardizeDatesForSearch();
		return getCalendarDates();
	}
	
	Calendar[] getStdDatesTimes() {
		standardizeDatesForStd();
		return getCalendarDates();
	}
	
	private void standardizeDatesForSearch() {
		setYearsForSearch();
		setTimesForSearch();
	}

	private void standardizeDatesForStd() {
		if (startDate == null) {
			return;
		}
		setYearsForStd();
		setTimesForStandard();
	}
	
	private void setYearsForSearch() { 
		if (startDate == null) { // no date detected
			return;
		} else {
			if (endDate == null) {
				if (startDate[INDEX_FOR_YEAR] == null) { 
					setCurrentYear(startDate);
					return;
				}
			} else { // has start and end date
				if (endDate[INDEX_FOR_YEAR] != null) { 
					if (startDate[INDEX_FOR_YEAR] == null) { 
						startDate[INDEX_FOR_YEAR] = endDate[INDEX_FOR_YEAR];
					} 
				} else { // no end year
					if(startDate[INDEX_FOR_YEAR] == null) {
						setCurrentYear(startDate);
					}
					if (isAfter(endDate, startDate)) {
						setCurrentYear(endDate);
					} else {
						setYearAfter(endDate, startDate);
					}
				}
			}
		}
	}
	
	private void setYearsForStd() { 
		if (startDate == null) { 
			return;
		} else {
			if (endDate == null) {
				if (startDate[INDEX_FOR_YEAR] == null) { 
					setNextValidYear(startDate);
				}
			} else { 
				if (endDate[INDEX_FOR_YEAR] != null) { 
					if (startDate[INDEX_FOR_YEAR] == null) { 
						startDate[INDEX_FOR_YEAR] = endDate[INDEX_FOR_YEAR];
					} 
				} else { 
					if (startDate[INDEX_FOR_YEAR] == null) {
					    setNextValidYear(startDate);
				    }
					if (isAfter(endDate, startDate)) {
						endDate[INDEX_FOR_YEAR] = startDate[INDEX_FOR_YEAR];
					} else {
						setYearAfter(endDate, startDate);
				    }
				}
			}
		}
	}
	private static void setYearAfter(String[] secondDate, String[] firstDate) {
		secondDate[INDEX_FOR_YEAR] = String.valueOf(Integer.parseInt(firstDate[INDEX_FOR_YEAR]) + 1);	
	}

	private static Boolean isAfter(String[] secondDate, String[] firstDate) {
		String second = CURR_YEAR + "-" + secondDate[INDEX_FOR_MONTH] + "-" + secondDate[INDEX_FOR_DATE];
		String first = CURR_YEAR + "-" + firstDate[INDEX_FOR_MONTH] + "-" + firstDate[INDEX_FOR_DATE];
		DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-M-d");
		try {
			LocalDate secDate = LocalDate.parse(second, formatter);
			LocalDate fstDate = LocalDate.parse(first, formatter);
			if (secDate.isAfter(fstDate) || secDate.isEqual(fstDate)) {
				return true;
			} else {
				return false;
			}
		} catch (DateTimeParseException e){
			return null;
		}
	}

	private static void setCurrentYear(String[] date) {
		date[INDEX_FOR_YEAR] = CURR_YEAR;
	}

	private static void setNextValidYear(String[] date) { //if is not search
		LocalDate today = LocalDate.now();
		String newDateString = CURR_YEAR + "-" + date[INDEX_FOR_MONTH] + "-" + date[INDEX_FOR_DATE];
		DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-M-d");
		try {
			LocalDate newDate = LocalDate.parse(newDateString, formatter);
			if (newDate.isAfter(today) || newDate.isEqual(today)) {
				setCurrentYear(date);
			} else {
				date[INDEX_FOR_YEAR] = String.valueOf(today.getYear() + 1);
			}
		} catch (DateTimeParseException e){
			date = null;
		}
	}


	private void setTimesForSearch() {
        if (startDate == null) {
        	return;
        } else if (endDate == null) { 
        	endDate = startDate;
        	if (startTime == null) { 
        		startTime = "00:00";
        		endTime = "23:59";
        	} else { 
        		if (endTime == null) { 
        			endTime = "23:59";
        		} 
        	}
        	return;
        } else { 
        	if (startTime == null) { // only start & end dates
        		// note: does not support date to date time e.g. 2 jan to 4 jan 3pm
        		startTime = "00:00";
        		endTime = "23:59";
        	} else { 
        		if (endTime == null) {
        			endTime = "23:59";
        		}
        	}
        	return;
        }
	} 


	private void setTimesForStandard() {
        if (startDate == null) {
        	return;
        } else if (endDate == null) { 
        	if (startTime == null) { 
        		startTime = "23:59";
        	} else { 
        		if (endTime != null) { 
        			endDate = startDate;
        		}
        	}
        	return;
        } else { 
        	if (startTime == null) { 
        		// Note: does not support date to date time e.g. 2 jan to 4 jan 3pm
        		startTime = "00:00";
        		endTime = "23:59";
        	} else { //has start time
        		if (endTime == null) {
        			endTime = "23:59";
        		}
        	}
        }
	} 

	private static String convertDateTimeToString(String[] dateArr, String time) {
		String date = dateArr[INDEX_FOR_DATE];
		if (date == null) {
			return null;
		}
		String month = dateArr[INDEX_FOR_MONTH];
		String year = dateArr[INDEX_FOR_YEAR];
		String std = date + "/" + month + "/" + year + " " + time;
		return std;
	}

	
	
	public Calendar[] getCalendarDates() {
		Calendar[] calTimes;
		if (parser == ParserType.NATTY_PARSER) {
			calTimes = new Calendar[3];
		} else {
			calTimes = new Calendar[2];
		}
		
		Calendar startCal = Calendar.getInstance();
		Calendar endCal = Calendar.getInstance();
		SimpleDateFormat dateTimeFormat = new SimpleDateFormat("d/M/yy HH:mm");
		
		// Check for null first to avoid null pointer exception
		if (isValid != null && isValid == false) {
			return null;
		}
		
		try {
			if (startDate == null) { // no date and time
				startCal = null;
				endCal = null;
			} else { // has start date
				dateTimeFormat.setLenient(false);
				startCal.setTime(dateTimeFormat.parse(convertDateTimeToString(startDate, startTime)));
				if (endDate != null) {
					endCal.setTime(dateTimeFormat.parse(convertDateTimeToString(endDate, endTime)));
				} else {
					endCal = null;
				}
			}
		} catch (java.text.ParseException e) {
			return null; // failed to parse
		}
		
		calTimes[0] = startCal;
		calTimes[1] = endCal;

		return calTimes;
	}

    static class DateTimeBuilder {		
    	private String[] startDate;
        private String[] endDate;
        private String startTime;
        private String endTime;
        private String unparsed;
		private Boolean isValid = null;
		private ParserType parser;

		public DateTimeBuilder(String input) {
			this.unparsed = input;
		}
		
		DateTimeBuilder times(String[] parsedTimes) {
			if (parsedTimes == null) {
				this.isValid = false;
			} else {
				this.startTime = parsedTimes[0];
				this.endTime = parsedTimes[1];
			}
			return this;
		}
		
		DateTimeBuilder dates(String[][] parsedDates) {
			if (parsedDates == null) {
				this.isValid = false;
			} else {
				if (parsedDates[0][0] == null) {
					this.startDate = null;
				} else {
					this.isValid = true;
					this.startDate = parsedDates[0];
				}
				
				if (parsedDates[1][0] == null) {
					this.endDate = null;
				} else {
					this.endDate = parsedDates[1];
				}
			}
			return this;
		}
		
		public DateTimeBuilder calDates(Calendar[] dates) {
			Calendar calStart = dates[0];
			Calendar calEnd = dates[1];
			if (calStart != null) {
				String[] start = convertCalToArr(calStart);
				this.startDate = start;
				this.isValid = true;
			} 
			
			if (calEnd != null) {
				String[] end = convertCalToArr(calEnd);
				this.endDate = end;
			} 
			this.parser = ParserType.NATTY_PARSER;
			return this;
		}

		private String[] convertCalToArr(Calendar calStart) {
			int date = calStart.get(Calendar.DAY_OF_MONTH);
			int month = calStart.get(Calendar.MONTH) + 1;
			int year = calStart.get(Calendar.YEAR);
			String[] arr = {String.valueOf(date), String.valueOf(month), String.valueOf(year)};
			return arr;
		}
		
		public DateTime build() {
			return new DateTime(this);
		}

		String getUnparsedInput() {
			return this.unparsed;
		}

		public Boolean isDoneParsing() {
			if (isValid == null) {
				return false;
			} else {
				return true;
			}
		}
    }
}
```
###### parser\DateTimeParser.java
``` java

package parser;

import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import parser.DateTime.DateTimeBuilder;

public abstract class DateTimeParser {
	static String DATE_KEYWORD_REGEX = "(?<=\\s|^)(on|by)\\s(?!.*( on | by ))([^\"#]*)";
	static final String TOMORROW_REGEX = "((?<=\\s|^)(tmr|tomorrow|tomorow).*(?=\\s|$))";
	static final String NO_KEYWORD_DATE_REGEX = FormattedDateParser.FORMATTED_DATE_REGEX + "|" 
												+ FlexibleDateParser.FLEXIBLE_DATE_REGEX + "|" + TOMORROW_REGEX;
	static final String NO_KEYWORD_DATE_TIME_REGEX = "(" + TimeParser.TIME_REGEX + "|" + NO_KEYWORD_DATE_REGEX + ")";
	static final Pattern NO_KEYWORD_DATE_TIME_PATTERN = Pattern.compile(NO_KEYWORD_DATE_TIME_REGEX);

	private static final Logger logger = Logger.getLogger(DateTimeParser.class.getName() );

	private static Pattern DATE_KEYWORD_PATTERN = Pattern.compile(DATE_KEYWORD_REGEX);
	private static final String TAG_OR_DESCRIPTION_REGEX = "(" + InputParser.TAG_REGEX + "|" 
														   + InputParser.DESCRIPTION_REGEX + ")";  	                                        
	private static final Pattern NO_KEYWORD_DATE_PATTERN = Pattern.compile(NO_KEYWORD_DATE_REGEX);
	
	protected DateTimeParser nextParser;
	
	abstract protected DateTimeBuilder parse(DateTimeBuilder currentlyParsed);

	
	public static String extractDateTimeSectionFromString(String input) {
		String extract = removeTagsAndDescriptions(input); // for formatted input
		if (hasNoKeywordDate(extract)) { 
			String noKeywordDateTime = extractNonNattyDateTimeSection(extract);
			logger.log(Level.FINE, "Non-Natty date section: " + noKeywordDateTime);
			return noKeywordDateTime;
		} else {
			String keywordDateTime = extractSectionAfterDateKeyword(extract);
			logger.log(Level.FINE, "Date keyword section: " + keywordDateTime + ",");
			return keywordDateTime;
		}
	}
		
	private static String removeTagsAndDescriptions(String input) {
		return InputParser.removeRegexPatternFromString(input, TAG_OR_DESCRIPTION_REGEX);
	}
	
	private static Boolean hasNoKeywordDate(String input) {
		Matcher m = NO_KEYWORD_DATE_PATTERN.matcher(input);
		if (m.find()) {
			return true;
		}
		return false;
	}
	
	private static String extractNonNattyDateTimeSection(String input) {
		Matcher m = NO_KEYWORD_DATE_TIME_PATTERN.matcher(input);
		String dateSection = "";
		while (m.find()) {
			dateSection = dateSection + m.group() + " ; ";
		}
		return dateSection.trim();
	}
	
	private static String extractSectionAfterDateKeyword(String input) {
		Matcher m = DATE_KEYWORD_PATTERN.matcher(input);
		String dateSection = "";
		if (m.find()) {
			dateSection = m.group(3);
		}
		return dateSection.trim();
	}
		
	public void setNextParser(DateTimeParser nextParser) {
		this.nextParser = nextParser;
	}
	
	public DateTime getDatesTimes(DateTimeBuilder currentlyParsed) {
		DateTimeBuilder datesTimes = parse(currentlyParsed);
		if (datesTimes.isDoneParsing()) { 
			return datesTimes.build();
		} else { // not detected
			if (nextParser != null) {
				return nextParser.getDatesTimes(currentlyParsed);
			}
		}
		return datesTimes.build();
	}
	
}
```
###### parser\DeleteParser.java
``` java

package parser;

public class DeleteParser extends InputParser {

	protected ParsedCommand parse(String[] input) {
		if (isMissingArguments(input)) {
			return createParsedCommandError(ERROR_MISSING_ARGS);
		} else {
			try {
				String inputArgs = input[INDEX_FOR_ARGS].trim();
				int taskId = getTaskIdFromString(inputArgs);
				ParsedCommand pc = new ParsedCommand.ParsedCommandBuilder(MyParser.CommandType.DELETE)
													.taskId(taskId)
													.build();
				return pc;
			} catch (InvalidArgumentsForParsedCommandException e) {
				return InputParser.createParsedCommandError(e.getMessage());
			}
		}
	}
}
```
###### parser\DoneParser.java
``` java

package parser;

public class DoneParser extends FlagParser {
	protected ParsedCommand parse(String[] input) {
		return createParsedCommandDone(input);
	}
}
```
###### parser\EditParser.java
``` java
package parser;

import java.util.ArrayList;
import java.util.Calendar;

public class EditParser extends InputParser {

	protected ParsedCommand parse(String[] input) {
		if (isMissingArguments(input)) {
			return InputParser.createParsedCommandError(ERROR_MISSING_ARGS);
		} else {
			String inputArgs[] = input[INDEX_FOR_ARGS].split(" ", 2);
			if (isMissingArguments(inputArgs)) {
				return InputParser.createParsedCommandError(ERROR_MISSING_FIELDS);
			} else {
				try {
					String task = inputArgs[0];
					String changes = inputArgs[1];
					int parsedTaskId = getTaskIdFromString(task);
					String parsedTitle = getTitleWithDateKeywords(changes);
					Calendar[] parsedTimes = getStandardDatesTimes(changes);
					if (mustRemoveDateKeywordSection(parsedTimes, changes)) { // date keyword used for date input
						parsedTitle = removeDateKeywordSection(parsedTitle);
					}
					String parsedDescription = getDescriptionFromString(changes);
					ArrayList<String> parsedTags = getTagsFromString(changes);
				
					ParsedCommand pc = new ParsedCommand.ParsedCommandBuilder(MyParser.CommandType.EDIT)
														.taskId(parsedTaskId)
														.title(parsedTitle)
														.times(parsedTimes)
														.description(parsedDescription)
														.tags(parsedTags)
														.build();
					return pc;
				} catch (InvalidArgumentsForParsedCommandException e) {
					return InputParser.createParsedCommandError(e.getMessage());
				}
			}
		}
	}

}
```
###### parser\FlagParser.java
``` java

package parser;

public class FlagParser extends InputParser {

	protected ParsedCommand parse(String[] input) {
		if (isMissingArguments(input)) {
			return createParsedCommandError(ERROR_MISSING_ARGS);
		} else {
			String[] subInput = input[INDEX_FOR_ARGS].split(" ");
			String subCommand = subInput[INDEX_FOR_SUBCMD];
			if (subCommand.equalsIgnoreCase("todo")) {
				return createParsedCommandTodo(subInput);
			} else if (subCommand.equalsIgnoreCase("done") || subCommand.equalsIgnoreCase("completed")) {
				return createParsedCommandDone(subInput);
			} else {
				return createParsedCommandError(InputParser.ERROR_INVALID_COMMAND);
			}
		}
	}

	private static ParsedCommand createParsedCommandFlagTaskStatus(String[] input, Boolean status) {
		if (isMissingArguments(input)) {
			return InputParser.createParsedCommandError(ERROR_MISSING_ARGS);
		} else {
			String inputArgs = input[INDEX_FOR_ARGS].trim();
			try {
				int taskId = getTaskIdFromString(inputArgs);
				ParsedCommand pc = new ParsedCommand.ParsedCommandBuilder(MyParser.CommandType.FLAG)
													.taskId(taskId)
													.isCompleted(status)
													.build();
				return pc;
			} catch (InvalidArgumentsForParsedCommandException e) {
				return InputParser.createParsedCommandError(e.getMessage());
			}
		}
	}

	static ParsedCommand createParsedCommandDone(String[] input) {
		return createParsedCommandFlagTaskStatus(input, true);
	}

	static ParsedCommand createParsedCommandTodo(String[] input) {
		return createParsedCommandFlagTaskStatus(input, false);
	}

}
```
###### parser\FlexibleDateParser.java
``` java

package parser;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Date;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import parser.DateTime.DateTimeBuilder;

public class FlexibleDateParser extends DateTimeParser {
	
	private static final int INDEX_FOR_UNPARSED = 2;

	private enum DateFormat {
		DATE_MONTH, MONTH_DATE;
	}
	
	private static final String MONTHS = "(jan(?:uary)?|feb(?:ruary)?|mar(?:ch)?|apr(?:il)?|may|jun(?:e)?|jul(?:y)?|aug(?:ust)?|sep(?:tember)?|oct(?:ober)?|nov(?:ember)?|dec(?:ember)?)";
	private static final String DATES = "(\\d?\\d)(?:st|rd|nd|th)?";
	private static final String YEARS = "(\\d{4})?";
	
	private static final String DATE_MONTH_REGEX = "(?<=\\s|^)" + DATES + "\\s" + MONTHS + ",?\\s?" + YEARS + "(?=\\s|$)";
	private static final String MONTH_DATE_REGEX = "(?<=\\s|^)" + MONTHS + "\\s" + DATES + ",?\\s?" + YEARS + "(?=\\s|$)";
	
	private static final Pattern DMMM = Pattern.compile(DATE_MONTH_REGEX);
	private static final Pattern MMMD = Pattern.compile(MONTH_DATE_REGEX);
	
	protected static final String FLEXIBLE_DATE_REGEX = "(" + DATE_MONTH_REGEX + "|" + MONTH_DATE_REGEX + ")";
	
	private static final int INDEX_FOR_DATE_ARR = 0;
	private static final int INDEX_FOR_MONTH_ARR = 1;
	private static final int INDEX_FOR_YEAR_ARR = 2;
	
	private static final int DM_INDEX_FOR_DATE = 1;
	private static final int DM_INDEX_FOR_MONTH = 2;
	private static final int DM_INDEX_FOR_YEAR = 3;
	
	private static final int MD_INDEX_FOR_DATE = 2;
	private static final int MD_INDEX_FOR_MONTH = 1;
	private static final int MD_INDEX_FOR_YEAR = 3;
	
	private static final int INDEX_FOR_START = 0;
	@SuppressWarnings("unused")
	private static final int INDEX_FOR_END = 1;
	
	private static final int[] DM_INDICES = {DM_INDEX_FOR_DATE, DM_INDEX_FOR_MONTH, DM_INDEX_FOR_YEAR};
	private static final int[] MD_INDICES = {MD_INDEX_FOR_DATE, MD_INDEX_FOR_MONTH, MD_INDEX_FOR_YEAR};
	
	private static final Logger logger = Logger.getLogger(FlexibleDateParser.class.getName() );
	
	@Override
	protected DateTimeBuilder parse(DateTimeBuilder currentlyParsed) {
		String input = currentlyParsed.getUnparsedInput();
		String[][] flexibleDates = getStandardFlexibleDates(input);
		logger.log(Level.FINE, "Flexible parse: [" + flexibleDates[0][0] +"/" + flexibleDates[0][1]);
		currentlyParsed = currentlyParsed.dates(flexibleDates);
		return currentlyParsed;
	}
	
	private static String[][] getStandardFlexibleDates(String input) {
		String[][] dates = new String[3][3];
		dates = getMonthDateFromString(input);
		if (dates[INDEX_FOR_START][INDEX_FOR_DATE_ARR] == null) { 
			dates = getDateMonthFromString(input);
		}
		return dates;
	}
	
	private static String[][] getMonthDateFromString(String input) {
		String[][] dateArr = parseStringToDateArray(input, DateFormat.MONTH_DATE);
		dateArr = convertDateArrayToStdFormat(dateArr);
		setUnparsedInput(DateFormat.MONTH_DATE, input, dateArr);
		// logger.log(Level.FINE, "MD start: " + dateArr[0] + " end: " + dateArr[1] + " format: " + dateArr[2] + " unparsed: " + dateArr[3]);		
		return dateArr;
	}
	
	private static String[][] getDateMonthFromString(String input) {
		String[][] dateArr = parseStringToDateArray(input, DateFormat.DATE_MONTH);
		dateArr = convertDateArrayToStdFormat(dateArr);
		setUnparsedInput(DateFormat.DATE_MONTH, input, dateArr);
		//logger.log(Level.FINE, "DM start: " + dateArr[0] + " end: " + dateArr[1] + " format: " + dateArr[2] + " unparsed: " + dateArr[3]);
		return dateArr;
	}

	private static String[][] parseStringToDateArray(String input, DateFormat df) {
		input = input.toLowerCase();
		String[][] dateArr = new String[2][3];
		Matcher m;
		int[] dmyIndices;
		
		if (df == DateFormat.MONTH_DATE) {
			m = MMMD.matcher(input);
			dmyIndices = MD_INDICES;
		} else if (df == DateFormat.DATE_MONTH) {
			m = DMMM.matcher(input);
			dmyIndices = DM_INDICES;
		} else {
			return null;
		}
		
		int i = 0;
		while (m.find() & i < 2) {
			String date = m.group(dmyIndices[INDEX_FOR_DATE_ARR]);
			String month = m.group(dmyIndices[INDEX_FOR_MONTH_ARR]);
			String year = m.group(dmyIndices[INDEX_FOR_YEAR_ARR]);
			updateDateArray(dateArr, i, date, month, year);
			i++;
		}
		return dateArr;
	}

	private static void updateDateArray(String[][] temp, int i, String date, String month, String year) {
		temp[i][INDEX_FOR_DATE_ARR] = date;
		temp[i][INDEX_FOR_MONTH_ARR] = month.substring(0,3);
		temp[i][INDEX_FOR_YEAR_ARR] = year;
	}
	
	private static String[][] convertDateArrayToStdFormat(String[][] temp) {
		String[][] dateArr = new String[3][3];
		dateArr[0] = convertToStandardDateFormat(temp[0]);
		dateArr[1] = convertToStandardDateFormat(temp[1]);
		return dateArr;
	}

	private static String[] convertToStandardDateFormat(String[] date) {
		date[INDEX_FOR_MONTH_ARR] = convertMonthToInt(date[INDEX_FOR_MONTH_ARR]);
		return date;
	}

	private static String convertMonthToInt(String monthName) {
		int month = -1;
		if (monthName == null) {
			return null;
		}
		try {
			Date date = new SimpleDateFormat("MMM").parse(monthName);
			Calendar cal = Calendar.getInstance();
			cal.setTime(date);
			month = cal.get(Calendar.MONTH) + 1;		    
		} catch (ParseException e) {
			// is never reached
			// do nothing
		}
		return String.valueOf(month);
	}
	
	private static void setUnparsedInput(DateFormat df, String input, String[][] dateArr) {
		if (df == DateFormat.MONTH_DATE) {
			dateArr[INDEX_FOR_UNPARSED][0] = removeMonthDateFromString(input);
		} else if (df == DateFormat.DATE_MONTH) {
			dateArr[INDEX_FOR_UNPARSED][0] = removeDateMonthFromString(input);
		}
	}
	
	private static String removeMonthDateFromString(String input) {
		return InputParser.removeRegexPatternFromString(input, MONTH_DATE_REGEX);
	}

	// double direction dependency!
	private static String removeDateMonthFromString(String input) {
		return InputParser.removeRegexPatternFromString(input, DATE_MONTH_REGEX);
	}
}
```
###### parser\FormattedDateParser.java
``` java

package parser;

import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import parser.DateTime.DateTimeBuilder;

public class FormattedDateParser extends DateTimeParser{
	
	private static final String DELIM = "-/.";
	static final String START = "(?<=^|\\s)";
	static final String END = "(?=\\s|$)";
	static final String DD = "([0-9]?[0-9])";
	static final String MM = "([0-9]?[0-9])";
	static final String DATE_DELIM = "[" + DELIM + "]";
	static final String YY = "(\\d{4}|\\d{2})";
	static final String NO_YEAR_FORMATTED_DATE_REGEX = START + DD + "[-/]" + MM + END;
	static final String FORMATTED_DATE_WITH_YEAR_REGEX = START + DD + DATE_DELIM + MM + DATE_DELIM + YY + END;
	static final String FORMATTED_DATE_REGEX = NO_YEAR_FORMATTED_DATE_REGEX + "|" + FORMATTED_DATE_WITH_YEAR_REGEX;
	static final String FORMATTED_DATE_FORMAT = "d/M/yy";
	
	private static final int INDEX_FOR_DATE_INPUT = 1;
	private static final int INDEX_FOR_MONTH_INPUT = 2;
	private static final int INDEX_FOR_YEAR_INPUT = 3;
	private static final int INDEX_FOR_DATE_ARR = 0;
	private static final int INDEX_FOR_MONTH_ARR = 1;
	private static final int INDEX_FOR_YEAR_ARR = 2;
	
	private static Pattern ddmmyy = Pattern.compile(FORMATTED_DATE_WITH_YEAR_REGEX);
	private static Pattern ddmm = Pattern.compile(NO_YEAR_FORMATTED_DATE_REGEX);
	
	private static final Logger logger = Logger.getLogger(FormattedDateParser.class.getName() );
	
	private static final int INDEX_FOR_START = 0;
	private static final int INDEX_FOR_END = 1;
	private static final int INDEX_FOR_UNPARSED = 2;
	
	@Override
	protected DateTimeBuilder parse(DateTimeBuilder currentlyParsed) {
		String input = currentlyParsed.getUnparsedInput();
		logger.log(Level.FINE, "date section: " + input + ".");
		String[][] formattedDates = getStandardFormattedDates(input);
		// logger.log(Level.FINE, "DATES:" + formattedDates[0] + ".");
		currentlyParsed = currentlyParsed.dates(formattedDates);
		// logger.log(Level.FINE, "TO FLEX:" + unparsedInput + ".");
		return currentlyParsed;
	}
	
	// Converts years to yyyy
	private static String convertYearToStandardFormat(String year) {
		if (year == null) {
			return null;
		} else if (year.length() < 4) {
			year = "20" + year;
		} else {
			return year;
		}
		return year;
	}
	
	private static String[][] getStandardFormattedDates(String input) {
		String[][] dates = getStandardFormattedDatesWithYear(input);
		if (dates[INDEX_FOR_START][INDEX_FOR_DATE_ARR] == null) {
			dates = getStandardFormattedDatesNoYear(input);
		}
		return processFormattedDates(input, dates);
	}

	private static String[][] getStandardFormattedDatesWithYear(String userInput) {
		return getFormattedDates(userInput, ddmmyy);
	}

	private static String[][] getStandardFormattedDatesNoYear(String userInput) {
		return getFormattedDates(userInput, ddmm);
	}

	private static String[][] getFormattedDates(String userInput, Pattern p) {
		Matcher m = p.matcher(userInput);
		
		int i = 0;
		String[][] tempDates = new String[2][3];
		while (m.find() & i < 2) {
			String[] dateArr = new String[3];
			dateArr[INDEX_FOR_DATE_ARR] = m.group(INDEX_FOR_DATE_INPUT);
			dateArr[INDEX_FOR_MONTH_ARR] = m.group(INDEX_FOR_MONTH_INPUT);
			String yr;
			if (m.groupCount() < 3) {
				yr = null;
			} else {
				yr = convertYearToStandardFormat(m.group(INDEX_FOR_YEAR_INPUT));
			}
			dateArr[INDEX_FOR_YEAR_ARR] = yr;
			tempDates[i] = dateArr;
			i++;
		}
		logDatesRead(tempDates);
		return tempDates;
	}

	private static String[][] processFormattedDates(String userInput, String[][] tempDates) {
		String[][] ans = new String[4][3];
		ans[0] = tempDates[INDEX_FOR_START];
		ans[1] = tempDates[INDEX_FOR_END];
		ans[INDEX_FOR_UNPARSED][0] = removeFormattedDatesFromString(userInput);
		return ans;
	}
	
	private static void logDatesRead(String[][] tempDates) {
		/*for (int a = 0; a < 2; a++) {
			for (int b = 0; b < 3; b++) {
				System.out.println("TEMP[" + a + "]["+b+"]: " + tempDates[a][b]);
			}
		}*/
	}

	private static String removeFormattedDatesFromString(String input) {
		return InputParser.removeRegexPatternFromString(input, FORMATTED_DATE_WITH_YEAR_REGEX);
	}
		
	
}
```
###### parser\GuiParser.java
``` java

package parser;

import parser.MyParser.CommandType;

public abstract class GuiParser extends InputParser {

	ParsedCommand createParsedCommandGuiTabAction(CommandType cmd, String[] input) {
		if (isMissingArguments(input)) {
			return createParsedCommandError(ERROR_MISSING_ARGS);
		} else {
			String tab = input[INDEX_FOR_ARGS];
			try {
				return new ParsedCommand.ParsedCommandBuilder(cmd)
										.guiType(tab)
										.build();
			} catch (InvalidArgumentsForParsedCommandException e) {
				return createParsedCommandError(e.getMessage());
			}
		}
	}
}
```
###### parser\InputParser.java
``` java

package parser;

import java.util.ArrayList;
import java.util.Calendar;
import java.util.logging.Logger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import parser.DateTime.DateTimeBuilder;
import parser.MyParser.CommandType;
import parser.ParsedCommand.TaskType;
import test.ParserTestingMethods;

@SuppressWarnings("unused")
public abstract class InputParser {
	static final String ERROR_INVALID_COMMAND = "Error: Invalid command";
	static final String ERROR_NO_INPUT = "Error: No user input";
	static final String ERROR_MISSING_ARGS = "Error: No fields entered";
	static final String ERROR_MISSING_FIELDS = "Error: No fields were entered for editing";
	static final String ERROR_INVALID_TASKID = "Error: Invalid/Missing taskId";
	
	static final int INDEX_FOR_CMD = 0;
	static final int INDEX_FOR_ARGS = 1;
	static final int INDEX_FOR_SUBCMD = 0;
	static final int INDEX_FOR_SUBARGS = 1;
	
	static final String TO_REGEX = "-|to|until|till";
	static final String TASK_ID_REGEX = "(^[0-9]+(?=\\s|$))";
	static final String SEARCH_TASK_ID_REGEX = "(^[0-9]+\\s*(?=$))";
	static final String TAG_REGEX = "(?<=\\s|^)#(\\w+)";
	static final String DESCRIPTION_REGEX = "(?<!\\\\)\"(.*)(?<!\\\\)\"(?!.*((?<!\\\\)\"))";
	static final String ERROR_INVALID_TABID = "Error: Invalid tab ID";
	
	private static final String TASK_STATUS_REGEX = "(?<=\\s|^)(todo|done|overdue)(?=\\s|$)";
	private static final String TASK_TYPE_REGEX = "(?<=\\s|^)(floating(?:task)?|deadline(?:task)?|event(?:task)?)(?:s)?(?=\\s|$)";
	private static final String OVERDUE_REGEX = "(?<=[^//s])(overdue)(?=\\s|$)";
	private static final String NOT_TITLE_REGEX_WITH_KEYWORD = "(" 
								+ "((?<=\\s|^)(from |fr |at |to |til |till |until |by |on |- ))?" 
								+ DateTimeParser.NO_KEYWORD_DATE_TIME_REGEX + "|" + TAG_REGEX + "|" 
								+ DESCRIPTION_REGEX + ")";  	
	
	static final Logger logger = Logger.getLogger(InputParser.class.getName() );
	
	protected static final int INDEX_FOR_START = 0;
	protected static final int INDEX_FOR_END = 1;

	protected abstract ParsedCommand parse(String[] input);
	
	protected static ParsedCommand createParsedCommandError(String errorMsg) {
		ParsedCommand pc;
		try {
			pc = new ParsedCommand.ParsedCommandBuilder(MyParser.CommandType.ERROR)
						 		  .errorMessage(errorMsg)
						 		  .build();
			return pc;
		} catch (InvalidArgumentsForParsedCommandException e) {
			return createParsedCommandError(e.getMessage());
		}
	}

	protected static ParsedCommand createParsedCommand(CommandType cmd) {
		try {
			return new ParsedCommand.ParsedCommandBuilder(cmd).build();
		} catch (InvalidArgumentsForParsedCommandException e) {
			return InputParser.createParsedCommandError(e.getMessage());
		}
	}
	
    
	// Methods to extract fields from string
	
	protected static String getTitleWithDateKeywords(String inputArgs) {
		if (inputArgs == null) {
			return null;
		}
		inputArgs = removeRegexPatternFromString(inputArgs, NOT_TITLE_REGEX_WITH_KEYWORD);
		return inputArgs.trim();
	}
	
	static String getSearchKeywordsWithDateKeywords(String inputArgs) {
		inputArgs = removeRegexPatternFromString(inputArgs, 
					NOT_TITLE_REGEX_WITH_KEYWORD + "|" + TASK_TYPE_REGEX  +"|" + TASK_STATUS_REGEX);
		return inputArgs.trim();
	}
	
	protected static String getDescriptionFromString(String inputArgs) {
		if (inputArgs == null) {
			return null;
		}
		Pattern descriptionPattern = Pattern.compile(DESCRIPTION_REGEX);
		Matcher m = descriptionPattern.matcher(inputArgs);
		String description = "";
		
		if (m.find()) {
			description = m.group(1);
		}
		
		return description;
	}

	protected static int getTaskIdFromString(String inputArgs) {
		Pattern taskIdPattern = Pattern.compile(TASK_ID_REGEX);
		Matcher m = taskIdPattern.matcher(inputArgs);
		int taskId = -1;

		if (m.find()) {
			taskId = Integer.parseInt(m.group());
		}

		return taskId;
	}
	
	static int getSearchTaskIdFromString(String inputArgs) {
		Pattern taskIdPattern = Pattern.compile(SEARCH_TASK_ID_REGEX);
		Matcher m = taskIdPattern.matcher(inputArgs);
		int taskId = -1;

		if (m.find()) {
			taskId = Integer.parseInt(m.group());
		}

		return taskId;
	}

	protected static ArrayList<String> getTagsFromString(String inputArgs) {
		Pattern tagsPattern = Pattern.compile(TAG_REGEX);
		Matcher m = tagsPattern.matcher(inputArgs);
		ArrayList<String> tags = new ArrayList<String>();

		while (m.find()) {
			String tag = m.group(1);
			tags.add(tag);
		}

		return tags;
	}

	protected static Boolean getTaskStatusFromString(String inputArgs) {
		inputArgs = inputArgs.toLowerCase();
		Pattern taskStatusPattern = Pattern.compile(TASK_STATUS_REGEX);
		Matcher m = taskStatusPattern.matcher(inputArgs);
		String status = "";

		if (m.find()) {
			status = m.group();
		}

		return determineTaskStatus(status);
	}
	
	protected static Boolean getIsOverdueFromString(String inputArgs) {
		inputArgs = inputArgs.toLowerCase();
		Pattern taskStatusPattern = Pattern.compile(OVERDUE_REGEX);
		Matcher m = taskStatusPattern.matcher(inputArgs);

		if (m.find()) {
			return true;
		}

		return false;
	}

	protected static TaskType getTaskTypeFromString(String inputArgs) {
		inputArgs = inputArgs.toLowerCase();
		Pattern taskTypePattern = Pattern.compile(TASK_TYPE_REGEX);
		Matcher m = taskTypePattern.matcher(inputArgs);
		String type = "";

		if (m.find()) {
			type = m.group(1);
		}
		
		return taskTypeToEnum(type);
	}

	
	private static Boolean determineTaskStatus(String status) {
		if (status.equalsIgnoreCase("todo")) {
			return false;
		} else if (status.equalsIgnoreCase("done")) {
			return true;
		} else {
			return null;
		}
	}

	
	private static TaskType taskTypeToEnum(String type) {
		if (type.equals("floating")) {
			return TaskType.FLOATING_TASK;
		} else if (type.equals("deadline")) {
			return TaskType.DEADLINE_TASK;
		} else if (type.equals("event")) {
			return TaskType.EVENT;
		} else {
			return null;
		}
	}
	
	
	protected static String removeDateKeywordSection(String input) {
		input = removeRegexPatternFromString(input, DateTimeParser.DATE_KEYWORD_REGEX);
		return input;
	}
	
	public static String removeRegexPatternFromString(String input, String regex) {
		if (input == null) {
			return null;
		}
		input = input.replaceAll("(?i)" + regex, "");
		return input.trim();
	}
	
	protected static boolean isMissingArguments(String[] input) {
		return input.length < 2;
	}
	
	protected static Calendar[] getStandardDatesTimes(String input) {
		DateTime parsedDatesTimes = getDatesTimesFromString(input);
		Calendar[] dates = parsedDatesTimes.getStdDatesTimes();
		return dates;
	}
	
	protected static Calendar[] getSearchDatesTimes(String input) {
		DateTime parsedDatesTimes = getDatesTimesFromString(input);
		Calendar[] dates = parsedDatesTimes.getSearchDatesTimes();
		return dates;
	}
	
	boolean mustRemoveDateKeywordSection(Calendar[] parsedTimes, String input) {
		return parsedTimes != null && parsedTimes[0] != null && parsedTimes.length > 2 && !containsTmr(input);
	}
	
	private boolean containsTmr(String input) {
		input = input.toLowerCase();
		Pattern taskTypePattern = Pattern.compile(DateTimeParser.TOMORROW_REGEX);
		Matcher m = taskTypePattern.matcher(input);

		if (m.find()) {
			return true;
		}
		
		return false;
	}
	
	// Date time parsing using chain of responsibility pattern
	private static DateTime getDatesTimesFromString(String input) {
		DateTimeParser dateTimeParserChain = getChainOfParsers();
		String dateSection = DateTimeParser.extractDateTimeSectionFromString(input.toLowerCase());
		DateTimeBuilder toParse = new DateTimeBuilder(dateSection);
		DateTime datesTimes = dateTimeParserChain.getDatesTimes(toParse);
		return datesTimes;
	}
	
	private static DateTimeParser getChainOfParsers() {
		DateTimeParser timeParser = new TimeParser();
		DateTimeParser formattedParser = new FormattedDateParser();
		DateTimeParser flexibleParser = new FlexibleDateParser();
		DateTimeParser nattyParser = new NattyDateParser();
		
		timeParser.setNextParser(formattedParser);
		formattedParser.setNextParser(flexibleParser);
		flexibleParser.setNextParser(nattyParser);
		return timeParser;
	}
}
```
###### parser\MyParser.java
``` java

package parser;

import java.util.HashMap;

public class MyParser {

	public enum CommandType {
		ADD, DELETE, EDIT, DISPLAY, ERROR, UNDO, REDO, FLAG, DONE, TODO, HELP, INVALID, CONFIG_DATA, CONFIG_IMG, 
		EXIT, CONFIG, SEARCH, SHOW, 
		GUI_OPEN, GUI_CLOSE, GUI_PIN, GUI_UNPIN, GUI_SHOW, GUI_SWITCH, GUI_LOG, GUI_MAIN, GUI_OPEN_ALL, GUI_CLOSE_ALL;
	}
	
	private static final int INDEX_FOR_CMD = 0;

	private static HashMap<String, MyParser.CommandType> _commandChoicesHashMap;
	public static final Pair[] COMMAND_CHOICES = {
		new Pair(MyParser.CommandType.ADD, new String[] {"add", "insert", "+"}),
		new Pair(MyParser.CommandType.DELETE, new String[] {"delete", "del", "remove", "cancel", "x"}),
		new Pair(MyParser.CommandType.EDIT, new String[] {"edit", "change", "update", "e;"}),
		new Pair(MyParser.CommandType.SHOW, new String[] {"show", "search", "find", "s;", "display"}),
		new Pair(MyParser.CommandType.EXIT, new String[] {"exit", "quit", "q;"}),
		new Pair(MyParser.CommandType.UNDO, new String[] {"undo"}),
		new Pair(MyParser.CommandType.REDO, new String[] {"redo"}),
		new Pair(MyParser.CommandType.DONE, new String[] {"done", "finished", "completed", "v"}),
		new Pair(MyParser.CommandType.FLAG, new String[] {"flag", "mark", "f;"}),
		new Pair(MyParser.CommandType.TODO, new String[] {"todo", "do"}),
		new Pair(MyParser.CommandType.CONFIG, new String[] {"set"}),
		new Pair(MyParser.CommandType.HELP, new String[] {"help", "?", "h;"}),
		new Pair(MyParser.CommandType.GUI_OPEN, new String[] {"open"}),
		new Pair(MyParser.CommandType.GUI_CLOSE, new String[] {"close"}),
		new Pair(MyParser.CommandType.GUI_PIN, new String[] {"pin"}),
		new Pair(MyParser.CommandType.GUI_SWITCH, new String[] {"switch"}),
		new Pair(MyParser.CommandType.GUI_LOG, new String[] {"log"}),
		new Pair(MyParser.CommandType.GUI_MAIN, new String[] {"main"}),
		new Pair(MyParser.CommandType.GUI_UNPIN, new String[] {"unpin"})
	};

	static {
		setupCommandChoicesHashMap();		
	}
	
	
	/**
	 * Parses user input into ParsedCommand attributes.
	 * @param userInput Entire string input by user.
	 * @return ParsedCommand object, with type error if userInput is invalid.
	 */
	public static ParsedCommand parseCommand(String userInput) {
		if (userInput == null || userInput.trim().length() == 0) {
			return InputParser.createParsedCommandError(InputParser.ERROR_NO_INPUT);
		} else {
			userInput = userInput.trim().replaceAll("\\s+", " ");
			String input[] = userInput.trim().split(" ", 2);
			String userCommand = input[INDEX_FOR_CMD];
			CommandType command = getStandardCommandType(userCommand.toLowerCase());
			
			InputParser ip;
			
			switch (command) {
				case ADD:
					ip = new AddParser();
					return ip.parse(input);
					
				case DELETE:
					ip = new DeleteParser();
					return ip.parse(input);
					
				case EDIT:
					ip = new EditParser();
					return ip.parse(input);
					
				case SHOW: 
					ip = new ShowParser();
					return ip.parse(input);
					
				case FLAG:
					ip = new FlagParser();
					return ip.parse(input);
					
				case DONE:
					ip = new DoneParser();
					return ip.parse(input);
	
				case TODO:
					ip = new TodoParser();
					return ip.parse(input);
					
				case UNDO:
					return InputParser.createParsedCommand(CommandType.UNDO);
	
				case REDO:
					return InputParser.createParsedCommand(CommandType.REDO);
				case GUI_OPEN:
					ip = new OpenParser();
					return ip.parse(input);
					
				case GUI_CLOSE:
					ip = new CloseParser();
					return ip.parse(input);
					
				case GUI_PIN:
					ip = new PinParser();
					return ip.parse(input);
					
				case GUI_SWITCH:
					return InputParser.createParsedCommand(CommandType.GUI_SWITCH);
					
				case GUI_LOG:
					return InputParser.createParsedCommand(CommandType.GUI_LOG);
					
				case GUI_MAIN:
					return InputParser.createParsedCommand(CommandType.GUI_MAIN);
				
				case GUI_UNPIN:
					return InputParser.createParsedCommand(CommandType.GUI_UNPIN);
					
				case CONFIG:
					ip = new ConfigParser();
					return ip.parse(input);
					
				case HELP:
					return InputParser.createParsedCommand(CommandType.HELP);
				
				case EXIT:
					return InputParser.createParsedCommand(CommandType.EXIT);
	
				case INVALID:
					return InputParser.createParsedCommandError(InputParser.ERROR_INVALID_COMMAND);
			
				default:
					// is never visited
					assert(false);
					throw new Error("ERROR");
			}
		}
	}


	private static void setupCommandChoicesHashMap() {
		_commandChoicesHashMap = new HashMap<String, CommandType>();
		for (int i = 0; i < COMMAND_CHOICES.length; i++) {
		    String[] cmdChoiceList = COMMAND_CHOICES[i].str;
		    CommandType cmd = COMMAND_CHOICES[i].commandType;
		    for (int j = 0; j < cmdChoiceList.length; j++) {
		    	_commandChoicesHashMap.put(cmdChoiceList[j], cmd);
		    }
		}
	}


	private static CommandType getStandardCommandType(String input) {
		CommandType cmd = _commandChoicesHashMap.get(input);
		if (cmd != null) {
			return cmd;
		} else {
			return CommandType.INVALID;
		}
	}

	public static class Pair {
		public String[] str;
		public CommandType commandType;
		public Pair(CommandType commandType, String[] stringChoices) {
			this.str = stringChoices;
			this.commandType = commandType;
		}
	}
}
```
###### parser\NattyDateParser.java
``` java

package parser;

import java.util.Calendar;
import java.util.Date;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import com.joestelmach.natty.DateGroup;
import com.joestelmach.natty.Parser;

import parser.DateTime.DateTimeBuilder;

public class NattyDateParser extends DateTimeParser{
	private static final String DAYS = "(mon(day)?|tue?(sday)?|tues|wed(nesday)?|thur(sday)?|thu|thurs|"
										+ "fri(day)?|sat(urday)?|sun(day)?|tmr|tomorrow|tomorow|today|tdy|ytd|yesterday)s?";
	private static final String RELATIVE_WORDS = "(next|nxt|prev|previous|last|coming|upcoming|before|after)";
	private static final String DURATION = "(day(s?)|month(s?)|year(s?)|yrs)";
	private static final String NUMBERS = "(\\d+\\s(" + DURATION + "|" + DAYS + "))";
	private static final String TO_ALTERNATIVES = "(?<=\\s|^)(until|til|till|-)(?=\\s|$)";	
	private static final String NATTY_REGEX = "(?<=\\s|^)(" + NUMBERS + "|" + RELATIVE_WORDS + "|" + DURATION 
											  + "|" + DAYS + "|to)(?=\\s|$)";
	private static final Pattern NATTY_DATES = Pattern.compile(NATTY_REGEX);
	
	private static final int INDEX_FOR_END = 1;

	private static final Logger logger = Logger.getLogger(NattyDateParser.class.getName() );

	@Override
    protected DateTimeBuilder parse(DateTimeBuilder currentlyParsed) {
    	String input = currentlyParsed.getUnparsedInput();
    	Calendar[] dates = new Calendar[2];
    	logger.log(Level.FINE, "Input to Natty: " + input);
    	input = standardiseNattyInput(input);
    	logger.log(Level.FINE,  "Standardised Natty: " + input);
    	dates = parseDateWithNatty(input);
    	return currentlyParsed.calDates(dates);
    }
	
	public static String standardiseNattyInput(String input) {
		input = input.replaceAll(TO_ALTERNATIVES, "to");
		input = input.toLowerCase();
		Matcher m = NATTY_DATES.matcher(input);
		String stdForm = "";
		while (m.find()) {
			stdForm = stdForm + m.group() + " ";
		}
		return stdForm;
	}
	
	public static Calendar[] parseDateWithNatty(String input) {
		
		Calendar[] parsedDates = new Calendar[3];
		Parser parser = new Parser();
		List<DateGroup> groups = parser.parse(input); // returns empty list if parse fails
		
		if (groups.isEmpty()) { 
			return parsedDates; 
		}
		
		List<Date> dates = groups.get(0).getDates();
		parsedDates[0] = convertDateToCalendar(dates.get(0));
		if (dates.size() < 2) {
			parsedDates[INDEX_FOR_END] = null; // no end time
		} else {
			parsedDates[INDEX_FOR_END] = convertDateToCalendar(dates.get(1));
		}
		return parsedDates;
	}

    private static Calendar convertDateToCalendar(Date date){ 
    	  Calendar cal = Calendar.getInstance();
    	  cal.setTime(date);
    	  return cal;
    }

    
}
```
###### parser\OpenParser.java
``` java

package parser;

import parser.MyParser.CommandType;

public class OpenParser extends GuiParser {

	protected ParsedCommand parse(String[] input) {
		return createParsedCommandGuiTabAction(CommandType.GUI_OPEN, input);
	}
	
}
```
###### parser\ParsedCommand.java
``` java

package parser;

import java.util.ArrayList;
import java.util.Calendar;

import gui.GuiController;

public class ParsedCommand {
	public enum ConfigType {
		BACKGROUND, AVATAR, INVALID;
	}
	
	public enum TaskType {
		FLOATING_TASK, DEADLINE_TASK, EVENT;
	}

	private MyParser.CommandType cmdType;
	private String title;
	private String errorMessage;
	private String searchKeywords;
	private String path;
	private Calendar firstDate;
	private Calendar secondDate;
	private String description;
	private ArrayList<String> tags;
	private int taskId;
	private String guiType;
	private TaskType taskType;
	private Boolean isCompleted;
	private Boolean isOverdue;
	private ConfigType configType;
	
	private static final String ERROR_INVALID_DATE = "Error: Invalid date(s) input";

	// private static final Logger logger = Logger.getLogger(ParsedCommand.class.getName() );
	private static final String ERROR_MISSING_TITLE = "Error: Missing task title";
	
	private static final int INDEX_FOR_START = 0;
	private static final int INDEX_FOR_END = 1;

	
	public static final String ERROR_INVALID_TASK_STATUS = null;
	public static final String ERROR_INVALID_CONFIG_TYPE = null;
	public static final String ERROR_INVALID_PATH = null;
	public static final String ERROR_INVALID_GUI_TAB_ID = null;
	
	
    /**
     * This method creates a ParsedCommand object (constructor).
     * 
     * @param cmdType Type of command or error.
     * @param title Title of task or error message (for error objects).
     * @param start Start date and time of task.
     * @param end End date and time of task.
     * @param description Description of task.
     * @param tags ArrayList of tags in task, tags must be alphanumeric with no whitespace.
     * @param taskId TaskId of task for edit, delete.
     * @param taskType Type of task, 1 for task, 2 for deadline task, 3 for event.
     */
	public ParsedCommand(ParsedCommandBuilder builder) {
		this.cmdType = builder.cmdType;
		this.title = builder.title;
		this.errorMessage = builder.errorMessage;
		this.searchKeywords = builder.searchKeywords;
		this.path = builder.path;
		this.firstDate = builder.firstDate;
		this.secondDate = builder.secondDate;
		this.description = builder.description;
		this.tags = builder.tags;
		this.taskId = builder.taskId;
		this.guiType = builder.guiType;
		this.taskType = builder.taskType;
		this.isCompleted = builder.isCompleted;
		this.isOverdue = builder.isOverdue;
		this.configType = builder.configType;
	}

	/**
	 * Returns command type of command, including error CommandType.
	 * @return command type.
	 */
	public MyParser.CommandType getCommandType() {
		return this.cmdType;
	}
	
	/**
	 * Returns title of task, empty string if not found, null if not applicable.
	 * @return title.
	 */
	public String getTitle() {
		return this.title;
	}
	
	/**
	 * Returns first date and time of task in Calendar format, null if not applicable.
	 * @return first date/time.
	 */
	public Calendar getFirstDate() {
		return this.firstDate;
	}
	
	/**
	 * Returns second date and time of task in Calendar format, null if not applicable.
	 * @return second date/time.
	 */
	public Calendar getSecondDate() {
		return this.secondDate;
	}
	
	/**
	 * Returns description of task, empty string if not found, null if not applicable.
	 * @return task description.
	 */
	public String getDescription() {
		return this.description;
	}
	
	/**
	 * Returns ArrayList of tags, empty ArrayList if not applicable.
	 * @return tags.
	 */
	public ArrayList<String> getTags() {
		return this.tags;
	}
	
	/**
	 * Returns error message if ParsedCommand is of type Error, null if not applicable.
	 * @return error message.
	 */
	public String getErrorMessage() {
		return this.errorMessage;
	}
	
	/**
	 * Returns taskId of task, -1 if not applicable.
	 * @return task ID.
	 */
	public int getTaskId() {
		return this.taskId;
	}
	
	/**
	 * Returns gui tab's index, empty string if not found, null if not applicable.
	 * @return gui tab index.
	 */
	public String getGuiType() {
		return this.guiType;
	}
	
	/**
	 * Returns TaskType.EVENT, TaskType.DEADLINE_TASK, TaskType.FLOATING_TASK or null.
	 * @return task type.
	 */
	public TaskType getTaskType() {
		return this.taskType;
	}
	
	/**
	 * Sets taskType of ParsedCommand object to argument.
	 * @param taskType
	 */
	public void setTaskType(TaskType taskType) {
		this.taskType = taskType;
	}
	
	/**
	 * Returns configuration type i.e. background or avatar for CONFIG_IMG, returns null if not applicable.
	 * @return
	 * @throws InvalidMethodForTaskTypeException
	 */
	public ConfigType getConfigType() {
		return this.configType;
	}
	
	/**
	 * Returns path for customisation for set file/background/avatar, returns null if not applicable.
	 * @return
	 * @throws InvalidMethodForTaskTypeException
	 */
	public String getConfigPath() {
		return this.path;
	}
	
	/**
	 * Returns true if completed, false if todo, null if irrelevant.
	 * @return
	 */
	public Boolean isCompleted() {
		return this.isCompleted;
	}
	
	/**
	 * Returns true if overdue, false if not, null if irrelevant.
	 * @return
	 */
	public Boolean isOverdue() {
		return this.isOverdue;
	}
	
	/**
	 * Returns search keywords for show command, empty string if not found, returns null if not applicable.
	 * @return
	 */
	public String getKeywords() {
		return this.searchKeywords;
	}
	
	static class ParsedCommandBuilder {
		private static final String ERROR_MISSING_ERROR_MESSAGE = "Error: Missing error message";

		private MyParser.CommandType cmdType;
		
		private String title = null;
		private String searchKeywords = null;
		private String errorMessage = null;
		private String path = null;
		private Calendar firstDate = null;
		private Calendar secondDate = null;
		private String description = null;
		private ArrayList<String> tags = new ArrayList<String>();
		private int taskId = -1;
		private String guiType = null;
		private TaskType taskType = null;
		private Boolean isCompleted = null;
		private Boolean isOverdue = null;
		private ConfigType configType = null;
		
		static final String ESC_CHAR_REGEX = "(?<!\\\\)(\\\\)";
		

		public ParsedCommandBuilder(MyParser.CommandType cmdType) {
			this.cmdType = cmdType;
		}
		
		public ParsedCommandBuilder title(String title) {
			this.title = removeEscapeChars(title);
			return this;
		}
		
		public ParsedCommandBuilder description(String description) {
			this.description = description;
			return this;
		}
		
		public ParsedCommandBuilder times(Calendar[] times) throws InvalidArgumentsForParsedCommandException {
			if (times == null) {
				throw new InvalidArgumentsForParsedCommandException(ERROR_INVALID_DATE);
			}
			this.firstDate = times[INDEX_FOR_START];
			this.secondDate = times[INDEX_FOR_END];
			return this;
		}
		
		public ParsedCommandBuilder tags(ArrayList<String> tags) {
			this.tags = tags;
			return this;
		}
		
		public ParsedCommandBuilder taskId(int taskId) throws InvalidArgumentsForParsedCommandException {
			if (taskId < 0) {
				throw new InvalidArgumentsForParsedCommandException(InputParser.ERROR_INVALID_TASKID);
			}
			this.taskId = taskId;
			return this;
		}
		
		public ParsedCommandBuilder guiType(String gui) {
			this.guiType = gui;
			return this;
		}
		
		public ParsedCommandBuilder errorMessage(String msg) {
			this.errorMessage = msg;
			return this;
		}
		
		public ParsedCommandBuilder configType(ConfigType configType) {
			this.configType = configType;
			return this;
		}
		
		public ParsedCommandBuilder configPath(String path) throws InvalidArgumentsForParsedCommandException {
			if (path.equals("")) {
				throw new InvalidArgumentsForParsedCommandException(InputParser.ERROR_MISSING_ARGS);
			}
			this.path = path;
			return this;
		}
		
		public ParsedCommandBuilder isCompleted(Boolean status) {
			this.isCompleted = status;
			return this;
		}
		
		public ParsedCommandBuilder isOverdue(Boolean status) {
			this.isOverdue = status;
			return this;
		}
		
		public ParsedCommandBuilder searchKeywords(String keywords) {
			this.searchKeywords = removeEscapeChars(keywords);
			return this;
		}
		
		public ParsedCommandBuilder taskType(TaskType type) {
			this.taskType = type;
			return this;
		}
		
		public ParsedCommand build() throws InvalidArgumentsForParsedCommandException {
			MyParser.CommandType command = this.cmdType;
			if (command == null) {
				throw new InvalidArgumentsForParsedCommandException("Error: Missing command type for building ParsedCommand");
			} else if (command == MyParser.CommandType.ADD) {
				validateTitle();
				setTaskType();
			} else if (command == MyParser.CommandType.EDIT || command == MyParser.CommandType.FLAG || command == MyParser.CommandType.DELETE) {
				validateTaskId();
				if (command == MyParser.CommandType.FLAG) {
					validateTaskStatus();
				}
			} else if (command == MyParser.CommandType.CONFIG_IMG) {
				validateConfigType();
				validatePath();
			} else if (command == MyParser.CommandType.GUI_OPEN || command == MyParser.CommandType.GUI_CLOSE 
					|| command == MyParser.CommandType.GUI_PIN) {
				validateGuiType();
			} else if (command == MyParser.CommandType.ERROR) {
				validateErrorMsg();
			}
			return new ParsedCommand(this);
		}

		private void validateErrorMsg() throws InvalidArgumentsForParsedCommandException {
			if (this.errorMessage == null || this.errorMessage.isEmpty()) {
				throw new InvalidArgumentsForParsedCommandException(ERROR_MISSING_ERROR_MESSAGE);
			}
		}

		private void validateTaskId() throws InvalidArgumentsForParsedCommandException {
			if (this.taskId < 0) {
				throw new InvalidArgumentsForParsedCommandException(InputParser.ERROR_INVALID_TASKID);
			}
		}
		
		private void validateGuiType() throws InvalidArgumentsForParsedCommandException {
			try {
				int tabNumber = Integer.parseInt(guiType);
				if (tabNumber <= GuiController.taskListNames.length && tabNumber > 0) {
					guiType = Integer.toString(tabNumber - 1); // convert to 0 indexing
					return;
				}
			} catch (NumberFormatException e) {
				// do nothing
			}
			
			for (int i = 0; i < GuiController.taskListNames.length; i++) {
				if (guiType.trim().equalsIgnoreCase(GuiController.taskListNames[i])) {
					guiType = Integer.toString(i - GuiController.taskListNames.length); // return specific format to indicate name call
					return;
				}
			}
			throw new InvalidArgumentsForParsedCommandException(InputParser.ERROR_INVALID_TABID);
		}

		private void validateTitle() throws InvalidArgumentsForParsedCommandException {
			if (this.title == null || this.title.equals("")) {
				throw new InvalidArgumentsForParsedCommandException(ERROR_MISSING_TITLE);
			}
		}
		
		private void validateTaskStatus() throws InvalidArgumentsForParsedCommandException {
			if (this.isCompleted == null) {
				throw new InvalidArgumentsForParsedCommandException(ERROR_INVALID_TASK_STATUS);
			}
		}
		
		private void validateConfigType() throws InvalidArgumentsForParsedCommandException {
			if (this.configType == ConfigType.INVALID || this.configType == null) {
				throw new InvalidArgumentsForParsedCommandException(ERROR_INVALID_CONFIG_TYPE);
			}
		}
		
		private void validatePath() throws InvalidArgumentsForParsedCommandException {
			if (this.path == null || this.path.isEmpty()){
				throw new InvalidArgumentsForParsedCommandException(ERROR_INVALID_PATH);
			}
		}

		private void setTaskType() {
			this.taskType = determineTaskType(this.firstDate, this.secondDate);
		}
		
		private static String removeEscapeChars(String input) {
			if (input == null) {
				return null;
			} else {
				return input.replaceAll(ESC_CHAR_REGEX, "");
			}
		}
		
		private static TaskType determineTaskType(Calendar start, Calendar end) {
			TaskType taskType;
			if (end == null) {
				if (start == null) {
					taskType = TaskType.FLOATING_TASK;
				} else {
					taskType = TaskType.DEADLINE_TASK;
				}
			} else {
				taskType = TaskType.EVENT;
			}
			return taskType;
		}
	}
}
```
###### parser\PinParser.java
``` java

package parser;

import parser.MyParser.CommandType;

public class PinParser extends GuiParser {

	protected ParsedCommand parse(String[] input) {
		return createParsedCommandGuiTabAction(CommandType.GUI_PIN, input);			
	}
	
}
```
###### parser\ShowParser.java
``` java

package parser;

import java.util.ArrayList;
import java.util.Calendar;
import java.util.logging.Level;

import parser.MyParser.CommandType;
import parser.ParsedCommand.TaskType;

public class ShowParser extends InputParser {
	protected ParsedCommand parse(String[] input) {
		if (isMissingArguments(input)) {
			return createParsedCommand(CommandType.GUI_SHOW);
		} else {
			String inputArgs = input[INDEX_FOR_ARGS];
			int taskId = getSearchTaskIdFromString(inputArgs);
			if (hasTaskId(taskId)) { 
				return createParsedCommandDisplay(taskId);
			} else { 
				return createParsedCommandSearch(inputArgs);
			}
		}
	}

	private ParsedCommand createParsedCommandSearch(String inputArgs) {
		ParsedCommand pc;
		try {
			String parsedKeywords = getSearchKeywordsWithDateKeywords(inputArgs);
			logger.log(Level.FINE, "Search keywords: " + parsedKeywords);
			Calendar[] parsedTimes = getSearchDatesTimes(inputArgs);
			if (mustRemoveDateKeywordSection(parsedTimes, inputArgs)) { // date keyword used for date input
				parsedKeywords = removeDateKeywordSection(parsedKeywords);
			}
			ArrayList<String> parsedTags = getTagsFromString(inputArgs);
			Boolean parsedStatus = getTaskStatusFromString(inputArgs);
			Boolean parsedOverdue = getIsOverdueFromString(inputArgs);
			TaskType taskType = getTaskTypeFromString(inputArgs);
			
			pc = new ParsedCommand.ParsedCommandBuilder(CommandType.SEARCH)
								  .searchKeywords(parsedKeywords)
								  .times(parsedTimes)
								  .tags(parsedTags)
								  .isCompleted(parsedStatus)
								  .isOverdue(parsedOverdue)
								  .taskType(taskType)
								  .build();
			return pc;
		} catch (InvalidArgumentsForParsedCommandException e) {
			return InputParser.createParsedCommandError(e.getMessage());
		}
	}
	
	private ParsedCommand createParsedCommandDisplay(int taskId) {
		ParsedCommand pc;
		try {
			pc = new ParsedCommand.ParsedCommandBuilder(CommandType.DISPLAY)
	  							  .taskId(taskId)
	  							  .build();
			return pc;
		} catch (InvalidArgumentsForParsedCommandException e) {
			return InputParser.createParsedCommandError(e.getMessage());
		}
	}
	
	private static boolean hasTaskId(int taskId) {
		return taskId >= 0;
	}

}
```
###### parser\TimeParser.java
``` java

package parser;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Date;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import parser.DateTime.DateTimeBuilder;

public class TimeParser extends DateTimeParser {
	private static final int INDEX_FOR_END = 1;

	private static final int INDEX_FOR_START = 0;

	private static final int INDEX_FOR_UNPARSED = 2;
	
	static final String TWELVE_HR_REGEX = "(?<=\\s|^)([0-9]?[0-9])([.:][0-9][0-9])?\\s?(am|pm)?(\\s?(?:-|to|until|til|till)\\s?([0-9]?[0-9])([.:][0-9][0-9])?\\s?)?(am|pm)(?=\\s|$)";
	static final String TWENTYFOUR_HR_REGEX = "(?<=\\s|^)(([0-9]?[0-9])[:]([0-9][0-9]))\\s?[?:h|H]?\\s?((?:-|to|until|til|till)?\\s?(([0-9]?[0-9])[:]([0-9][0-9])))?\\s?[?:h|H]?(?=\\s|$)";
		
	static final String TIME_REGEX = "(" + TWELVE_HR_REGEX + "|" + TWENTYFOUR_HR_REGEX + ")";
	
	static final Pattern HHMM = Pattern.compile(TWENTYFOUR_HR_REGEX);
	static final Pattern HMMA = Pattern.compile(TWELVE_HR_REGEX);
	
	static final String TWELVE_HR_FORMAT = "h:mma";
	static final String TWENTY_FOUR_HR_FORMAT = "HH:mm";

	private static final int TIME_H1 = 1;
	private static final int TIME_M1 = 2;
	private static final int TIME_APM1 = 3;
	private static final int TIME_H2 = 5;
	private static final int TIME_M2 = 6;
	private static final int TIME_APM2 = 7;
	
	private static final Logger logger = Logger.getLogger(TimeParser.class.getName() );
	
	@Override
	protected DateTimeBuilder parse(DateTimeBuilder currentlyParsed) {
		String input = currentlyParsed.getUnparsedInput();	
		if (input == null) {
			return null;
		}
		String[] times = new String[3];
		times = getTwelveHrTimesFromString(input);
		logger.log(Level.FINE, "12HR for " + input + " : " + times[0] + " " + times[1]);
		if (times[INDEX_FOR_START] == null) {
			times = getTwentyfourHrTimesFromString(input);
			logger.log(Level.FINE, "24HR for " + input + " : " + times[0] + " " + times[1]);
		} 
		times[INDEX_FOR_UNPARSED] = removeTimesFromString(input);
		if (isInvalidTimes(times)) {
			times = null;
		}
		currentlyParsed.times(times);
		return currentlyParsed;
	}
	
	private static String[] getTwelveHrTimesFromString(String input) {
		Matcher m = HMMA.matcher(input);
		String[] timeArr = new String[3];
		int i = 0;
		
		while (m.find() & i < 2) {
			String time1 = m.group(TIME_H1);
			String min1 = m.group(TIME_M1);
			String apm1 = m.group(TIME_APM1);
			String apm2 = m.group(TIME_APM2);
			String h2 = m.group(TIME_H2);
			String m2 = m.group(TIME_M2);
		
			if (min1 != null) {
				time1 = time1 + ":" + min1.substring(1);
			} else {
				time1 = time1 + ":00";
			}
			
			if (apm1 != null) {
				time1 = time1 + apm1;
			} else {
				time1 = time1 + apm2;
			}
			
			timeArr[i] = time1;
		
		    if (i < 1 & (h2 != null)) {
				String time2 = h2;
				if (m2 != null) {
					time2 = time2 + ":" + m2.substring(1) + apm2;
				} else {
					time2 = time2 + ":00" + apm2;
				}
				timeArr[1] = time2;
			}
			/*for (int a = 1; a <= 7; a++) {
				System.out.print(m.group(a) + "; ");
			}
			System.out.println("");*/
			i++;
		}
		timeArr[INDEX_FOR_START] = convertToTwentyFourHr(timeArr[INDEX_FOR_START]);
		timeArr[INDEX_FOR_END] = convertToTwentyFourHr(timeArr[INDEX_FOR_END]);
		return timeArr;
	}
	
	private static String convertToTwentyFourHr(String twelveHrTime) {
		if (twelveHrTime == null) {
			return null;
		}
		SimpleDateFormat twentyFourHrFormat = new SimpleDateFormat("HH:mm");
	    SimpleDateFormat twelveHrFormat = new SimpleDateFormat("hh:mma");
	    Date twelveHr;
	    String twentyFourHrTime;
		try {
			twelveHrFormat.setLenient(false);
			twentyFourHrFormat.setLenient(false);
			twelveHr = twelveHrFormat.parse(twelveHrTime);
			twentyFourHrTime = twentyFourHrFormat.format(twelveHr);
			return twentyFourHrTime;
		} catch (ParseException e) {
			return twelveHrTime;
		} 
	    // System.out.println(parseFormat.format(date) + " = " + displayFormat.format(date));
	}

	private static String[] getTwentyfourHrTimesFromString(String input) {
		Matcher m = HHMM.matcher(input);
		String[] ans = new String[4];
		
		int i = 0;
		while (m.find() & i < 2) {
			if (i == 0) {
				ans[INDEX_FOR_START] = m.group(1);
				ans[INDEX_FOR_END] = m.group(5);
			} else {
				ans[INDEX_FOR_END] = m.group(1);
			}
			i++;
		}

		return ans;
	}
	
	private static String removeTimesFromString(String input) {
		input = input.replaceAll(TIME_REGEX, "");
		return input.trim();
	}
	
	private static boolean isInvalidTimes(String[] times) {
		if (times[INDEX_FOR_START] == null) {
			return false;
		}

		SimpleDateFormat dateTimeFormat = new SimpleDateFormat("dd-mm-yy HH:mm");
		try {
			dateTimeFormat.setLenient(false);
			Calendar cal = Calendar.getInstance();
			cal.setTime(dateTimeFormat.parse("1-1-15 " + times[0]));
			if (times[INDEX_FOR_END] == null) {
				return false;
			}
			cal.setTime(dateTimeFormat.parse("1-1-15 " + times[1]));
		} catch (java.text.ParseException e) {
			return true; // failed to parse
		}
		return false;
	}

	

}
```
###### parser\TodoParser.java
``` java

package parser;

public class TodoParser extends FlagParser {
	
	protected ParsedCommand parse(String[] input) {
		return createParsedCommandTodo(input);
	}
}
```
###### test\AllTestSuite.java
``` java

package test;

import org.junit.runner.RunWith;
import org.junit.runners.Suite;

@RunWith(Suite.class)
@Suite.SuiteClasses({ 
	ParserTestSuite.class,
	GuiShortcutTest.class,
	IntegrationTest.class,
	StorageTest.class,
	LogicTestSuite.class
})


public class AllTestSuite {

}
```
###### test\DateTimeParserTest.java
``` java

package test;

import static org.junit.Assert.*;

import org.junit.Test;

import parser.DateTimeParser;

public class DateTimeParserTest {

	
	@Test
	public void testExtractDateTimeSectionFromString() {
		// Test formatted dates
		assertEquals("12/2/13 ;", DateTimeParser.extractDateTimeSectionFromString("do homework 12/2/13 @1200-1300 #tags \"descriptions...\""));
		assertEquals("2/12/13 ; 12:00 ; 2/12/13 ; 13:00 ;", DateTimeParser.extractDateTimeSectionFromString("do homework 2/12/13 #tags 12:00 to 2/12/13 13:00 #tags \"descriptions...\""));
		
		// Test date keywords
		assertEquals("12/2/13 ;", DateTimeParser.extractDateTimeSectionFromString("do bacon bye homework on 12/2/13 @1200 #tags \"descriptions...\""));
		assertEquals("tmr 3pm ;", DateTimeParser.extractDateTimeSectionFromString("do homework on essay by tmr 3pm #tags \"descriptions...\""));
		assertEquals("tmr 3pm ;", DateTimeParser.extractDateTimeSectionFromString("do homework on essay bye tmr 3pm #tags \"descriptions...\""));
		assertEquals("12/2/13 ; 12pm ;", DateTimeParser.extractDateTimeSectionFromString("do homework by 12/2/13 12pm #tags \"descriptions...\""));
		assertEquals("next tues from 16:00 to 18:00", DateTimeParser.extractDateTimeSectionFromString(" meet john on next tues from 16:00 to 18:00 #cs2103 #proj #cs2101"));
		assertEquals("tmr ;", DateTimeParser.extractDateTimeSectionFromString("watch tmr"));
		assertEquals("tmr ;", DateTimeParser.extractDateTimeSectionFromString("meeting by extra tmr"));
		// Test floating tasks
		assertEquals("", DateTimeParser.extractDateTimeSectionFromString("do homework #tags \"descriptions...\""));
		
		
	}
	
}
```
###### test\InputParserTest.java
``` java

package test;

import static org.junit.Assert.*;

import java.util.ArrayList;
import org.junit.Before;
import org.junit.Test;

import parser.InputParser;
import parser.MyParser;
import parser.ParsedCommand;
import parser.MyParser.CommandType;
import parser.ParsedCommand.TaskType;

public class InputParserTest extends InputParser {

	private static void checkTitleWithKeywords(String expected, String input) {
		assertEquals(expected, InputParser.getTitleWithDateKeywords(input));
	}
	
	private static void checkRemoveDateKeywords(String expected, String received) {
		assertEquals(expected, InputParser.removeDateKeywordSection(received));
	}

	private static void checkStdDatesTimes(String expectedStart, String expectedEnd, String received) {
		if (expectedStart == null) {
			assertEquals(ParserTestingMethods.parseStringToDate(expectedStart), 
					     InputParser.getStandardDatesTimes(received)[0]);
		} else {
			assertEquals(ParserTestingMethods.parseStringToDate(expectedStart), 
					     InputParser.getStandardDatesTimes(received)[0].getTime());
		}
		
		if (expectedEnd == null) {
			assertEquals(ParserTestingMethods.parseStringToDate(expectedEnd), 
					     InputParser.getStandardDatesTimes(received)[1]);
		} else {
			assertEquals(ParserTestingMethods.parseStringToDate(expectedEnd), 
					     InputParser.getStandardDatesTimes(received)[1].getTime());
		}
	}
	
	private static void checkStdDatesTimesError(String input) {
		assertArrayEquals(null, InputParser.getStandardDatesTimes(input));
	}
	
	private static void checkSearchDatesTimes(String expectedStart, String expectedEnd, String input) {
		if (expectedStart == null) {
			assertEquals(ParserTestingMethods.parseStringToDate(expectedStart), 
					     InputParser.getSearchDatesTimes(input)[0]);
		} else {
			assertEquals(ParserTestingMethods.parseStringToDate(expectedStart), 
					     InputParser.getSearchDatesTimes(input)[0].getTime());
		}
		
		if (expectedEnd == null) {
			assertEquals(ParserTestingMethods.parseStringToDate(expectedEnd), 
					     InputParser.getSearchDatesTimes(input)[1]);
		} else {
			assertEquals(ParserTestingMethods.parseStringToDate(expectedEnd), 
					     InputParser.getSearchDatesTimes(input)[1].getTime());
		}
	}
	
	private static void checkSearchDatesTimesError(String input) {
		assertArrayEquals(null, InputParser.getSearchDatesTimes(input));
	}
	
	private static void checkDescription(String expected, String input) {
		assertEquals(expected, InputParser.getDescriptionFromString(input));
	}
	
	@Before
	public void setUp() throws Exception {
	    ParserTestingMethods.initLogging();
	}

	
	@Test
	public void testCreateParsedCommandError() {
		ParsedCommand pc = InputParser.createParsedCommandError("ERROR");
		assertEquals(MyParser.CommandType.ERROR, pc.getCommandType());
		assertEquals("ERROR", pc.getErrorMessage());
		
		pc = InputParser.createParsedCommandError(null);
		assertEquals(MyParser.CommandType.ERROR, pc.getCommandType());
		assertEquals("Error: Missing error message", pc.getErrorMessage());
		
		pc = InputParser.createParsedCommandError("");
		assertEquals(MyParser.CommandType.ERROR, pc.getCommandType());
		assertEquals("Error: Missing error message", pc.getErrorMessage());
	}

	@Test
	public void testCreateParsedCommand() {
		ParsedCommand pc = InputParser.createParsedCommand(CommandType.UNDO);
		assertEquals(CommandType.UNDO, pc.getCommandType());
		
		pc = InputParser.createParsedCommand(CommandType.ADD);
		assertEquals(MyParser.CommandType.ERROR, pc.getCommandType());
		assertEquals("Error: Missing task title", pc.getErrorMessage());
		
		pc = InputParser.createParsedCommand(null);
		assertEquals(MyParser.CommandType.ERROR, pc.getCommandType());
		assertEquals("Error: Missing command type for building ParsedCommand", pc.getErrorMessage());
		
	}

	@Test
	public void testIsMissingArguments() {
		assertEquals(true, InputParser.isMissingArguments(new String[] {""}));
		assertEquals(false, InputParser.isMissingArguments(new String[] {"", ""}));
		assertEquals(false, InputParser.isMissingArguments(new String[] {null, null, ""}));
	}
	
	@Test
	public void testGetTitleWithKeywordsFromString() {
		// Check null input
		checkTitleWithKeywords(null, null);
		// Check empty string
		checkTitleWithKeywords("", "");
		
		
		// Check dates, times, descriptions and tags removed
		
		// formatted date, date keywords removed
		checkTitleWithKeywords("hello this is     my task", " hello this is By 12/12/12 5pm until 13/12/12 8am my task");
		checkTitleWithKeywords("hello  task \\12:00pm", " hello \"this is my\" task \\12:00pm 24/2");
		checkTitleWithKeywords("\\12.2-13 Meet John about proposal", "\\12.2-13 Meet John about proposal #cs2103 12:00h");
		checkTitleWithKeywords("Meet John about proposal", "#cs2101 Meet John about proposal on 23 jan #cs2103 at 12:00 12-2.13");
		checkTitleWithKeywords("", "23/1/15 2pm \"description\" #tAg1 #tag2");
		checkTitleWithKeywords("Meet John about proposal", "#cs2101 Meet John about proposal #cs2103 12:00 until 15:30 12/2/13");
		
		// flexible date, date keywords removed
		checkTitleWithKeywords("hello this is my task", " hello this is my task 2 feb 12:00 \"description\" #tags #tag1");
		checkTitleWithKeywords("Meet John about proposal \\23 Jan", "#cs2101 Meet John about proposal \\23 Jan #cs2103 from 12:00");
				
		// natty, date keywords not removed except for tmr
		checkTitleWithKeywords("watch", "watch tmr");
		checkTitleWithKeywords("watch on \\tmr", "watch on \\tmr");
		checkTitleWithKeywords("watch", "watch on Tomorrow");
		checkTitleWithKeywords("watch movie On next Fri", "watch movie On next Fri");

		// task status, type not removed
		checkTitleWithKeywords("lalala todo done floating deadline event", "lalala todo done floating deadline event");
	}
	
	@Test
	public void testRemoveDateKeywordSection() {
		checkRemoveDateKeywords("", "");
		checkRemoveDateKeywords(null, null);
		
		// Check string after keywords removed
		checkRemoveDateKeywords("", "on hello");
		checkRemoveDateKeywords("", "by lalala");
		
		// Check last possible section is removed when more than one keyword
		checkRemoveDateKeywords("on something by something", "on something by something by another");
		checkRemoveDateKeywords("by something", "by something on lala");
		
		// Check escape characters work
		checkRemoveDateKeywords("\\on hello \\by bye bye", "\\on hello \\by bye bye");
		
		// Check keywords must not be part of another word
		checkRemoveDateKeywords("bye bacon", "bye bacon");
		
	}

	@Test
	public void testGetStdDatesTimesFromString() {
		// Check supported formats
		
		// Check support for no date & time
		checkStdDatesTimes(null, null, "Meet John about proposal 1200 #cs2103 #cs2101");
		
		// Check support for formatted input (has start and end time) out of order
		checkStdDatesTimes("12/2/13 12:00", "12/2/13 13:30", "12/2/13 Meet John about proposal #cs2103 12:00-13:30");
		
		// Check support for formatted input no year, year set such that date is nearest upcoming date
		checkStdDatesTimes("12/2/16 12:00", "12/2/16 13:30", "12/2 Meet John about proposal #cs2103 12 until 1:30pm");
		
		// Check support for formatted input, event with no times, default start 0000, default end 2359
		checkStdDatesTimes("12/2/16 00:00", "14/2/16 23:59", "12/2 Meet John about proposal #cs2103 14/2");
				
		// Check support for flexible start date no time, default set to 23:59
		checkStdDatesTimes("1/4/2016 23:59", null, "Add meeting with john on 1st April");
				
		// Check support for flexible start date and time, keyword
		checkStdDatesTimes("12/2/13 12:00", null, "Meet John about proposal on feb 12 2013 12:00 #cs2103 #cs2101");
		
		// Check end must be after start if no year
		checkStdDatesTimes("12/1/16 12:00", "31/12/16 23:59", "Meet John about proposal JAN 12th 12:00 til dec 31 #cs2103 #cs2101");
		
		// Check support for natty start date no time, default time is 2359
		checkStdDatesTimes(ParserTestingMethods.inNDays(1, 23, 59), null, "finish homework by tmr");
		
		// Check support for Natty input start date & time
		checkStdDatesTimes(ParserTestingMethods.inNDays(1, 14, 0), null, "Meet John about proposal by tmr 2pm #cs2103 #cs2101");
		
		// Check support for Natty events
		checkStdDatesTimes(ParserTestingMethods.inNDays(1, 12, 0), ParserTestingMethods.inNDays(3, 13, 0), "event on tmr 12pm to 3 days 1pm");
		
		// Check invalid time for Natty input
		checkStdDatesTimesError("Meet John about proposal by tmr 32pm #cs2101");
				
		// Check support for flexible invalid date
		checkStdDatesTimesError("Add meeting with john on 31st April");

		// Check support for formatted input invalid time
		checkStdDatesTimesError("12/2/13 Meet John about proposal #cs2103 52:00-13:30");		
				
		// Consider having if only time is detected, set default to today		
	}
	
	@Test
	public void testGetSearchDatesTimesFromString() {
		// Check supported formats
		
		// Check support for no date & time
		checkSearchDatesTimes(null, null, "Meet John about proposal 1200 #cs2103 #cs2101");
		
		// Check support for formatted input (has start and end time) out of order
		checkSearchDatesTimes("12/2/13 12:00", "12/2/13 13:30", "12/2/13 Meet John about proposal #cs2103 12:00-13:30");
		
		// Check support for formatted input no year, year set to this year even if it's over already
		checkSearchDatesTimes("12/2/15 12:00", "12/2/15 13:30", "12/2 Meet John about proposal #cs2103 12 until 1:30pm");
		
		// Check support for formatted input, event with no times, default start 0000, default end 2359
		checkSearchDatesTimes("12/2/15 00:00", "14/2/15 23:59", "12/2 Meet John about proposal #cs2103 14/2");
				
		// Check support for flexible start date no time, time set to 0000 - 2359
		checkSearchDatesTimes("1/4/2015 00:00", "1/4/2015 23:59", "Add meeting with john on 1st April");
				
		// Check support for flexible start date and time, set end time to 2359
		checkSearchDatesTimes("12/2/13 12:00", "12/2/13 23:59", "Meet John about proposal on feb 12 2013 12:00 #cs2103 #cs2101");
		
		// Check if one time given, time is for start, end time is 2359 even if user inputs default time
		checkSearchDatesTimes("12/2/13 23:59", "12/2/13 23:59", "Meet John about proposal on feb 12 2013 11.59pm #cs2103 #cs2101");
				
		// Check end must be after start if no year, default end time 23:59
		checkSearchDatesTimes("12/1/15 12:00", "31/12/15 23:59", "Meet John about proposal JAN 12th 12:00 til dec 31 #cs2103 #cs2101");
		
		// Check support for natty start date no time, default time is 0000 - 2359
		checkSearchDatesTimes(ParserTestingMethods.inNDays(1, 0, 0), ParserTestingMethods.inNDays(1, 23, 59), "finish homework by tmr");
		
		// Check support for Natty input start date & time
		checkSearchDatesTimes(ParserTestingMethods.inNDays(1, 14, 0), ParserTestingMethods.inNDays(1, 23, 59), "Meet John about proposal by tmr 2pm #cs2103 #cs2101");
		
		// Check support for Natty events
		checkSearchDatesTimes(ParserTestingMethods.inNDays(1, 12, 0), ParserTestingMethods.inNDays(3, 13, 0), "event on tmr 12pm to 3 days 1pm");
		
		// Check invalid time for Natty input
		checkSearchDatesTimesError("Meet John about proposal by tmr 32pm #cs2101");
				
		// Check support for flexible invalid date
		checkSearchDatesTimesError("Add meeting with john on 31st April");

		// Check support for formatted input invalid time
		checkSearchDatesTimesError("12/2/13 Meet John about proposal #cs2103 52:00-13:30");			
	}
	
	@Test
	public void testGetDescriptionFromString() {
		checkDescription(null, null);
		checkDescription("", "");
		// Check no description
		checkDescription("", "Meet John about proposal @1200 #cs2103 #cs2101");

		// Check gets description
		checkDescription("and this my description", "this is my task \"and this my description\" blah blah 23/3/12");
		
		// Check gets outermost quotes
		checkDescription("my desc\" #cs2101 \"lalala", "Meet John about proposal @1200 #cs2103 \"my desc\" #cs2101 \"lalala\"");
		
		// Check escape characters work
		checkDescription("actual quote \\\"esc quote actual quote 2", 
						 "lalala \\\"esc quote \"actual quote \\\"esc quote actual quote 2\" hello");
	}

	@Test
	public void testGetTaskIdFromString() {
		// Check getTaskId returns integer at front of line
		assertEquals(4242, InputParser.getTaskIdFromString("4242 Meet John about proposal @1200 #cs2103 \"my desc\" #cs2101"));
		
		assertEquals(0, InputParser.getTaskIdFromString("0 Meet John about proposal @1200 #cs2103 \"my desc\" #cs2101"));
		
		// Negative numbers not detected
		assertEquals(-1, InputParser.getTaskIdFromString("-2 Meet John about proposal @1200 #cs2103 \"my desc\" #cs2101"));
		
		// Check invalid/missing taskId returns -1
		assertEquals(-1, InputParser.getTaskIdFromString("Meet Task John about proposal @1200 #cs2103 #cs2101"));
		assertEquals(-1, InputParser.getTaskIdFromString("this is my 23 task \"and this my description\" blah blah 23/3/12"));
	}

	@Test
	public void testGetTagsFromString() {
		assertEquals("Cs2103", InputParser.getTagsFromString("#Cs2103 Meet Task John about proposal @1200 #cs2101").get(0));
		assertEquals("cs2101", InputParser.getTagsFromString("#cs2103 Meet Task John about proposal @1200 #cs2101").get(1));
		assertEquals(new ArrayList<String>(), InputParser.getTagsFromString("Meet Task John about proposal @1200"));
	}
	
	@Test
	public void testGetTaskStatusFromString() {
		assertEquals(false, InputParser.getTaskStatusFromString("Meet Task John about proposal #cs2103 @1200 #cs2101 todo"));
		assertEquals(false, InputParser.getTaskStatusFromString("meeting 23/11/15 #tag Todo"));
		assertEquals(null, InputParser.getTaskStatusFromString("meeting 23/11/15 #tag"));
		assertEquals(true, InputParser.getTaskStatusFromString("meeting 23/11/15 #tag doNe"));

	}
	
	@Test
	public void testGetIsOverdueFromString() {
		assertEquals(false, InputParser.getIsOverdueFromString("Meet Task John about proposal #cs2103 @1200 #cs2101"));
		assertEquals(true, InputParser.getIsOverdueFromString("meeting 23/11/15 #tag Overdue"));
		assertEquals(true, InputParser.getIsOverdueFromString("meeting overdue lala 23/11/15 #tag"));
	}
	
	@Test
	public void testGetTaskTypeFromString() {
		assertEquals(TaskType.FLOATING_TASK, InputParser.getTaskTypeFromString("Floating task"));
		assertEquals(TaskType.FLOATING_TASK, InputParser.getTaskTypeFromString("floating tasks"));
		assertEquals(TaskType.FLOATING_TASK, InputParser.getTaskTypeFromString("lalala floating task lalala"));
		assertEquals(null, InputParser.getTaskTypeFromString("lalafloating task lalala"));

		assertEquals(TaskType.DEADLINE_TASK, InputParser.getTaskTypeFromString("deaDline task"));
		assertEquals(TaskType.DEADLINE_TASK, InputParser.getTaskTypeFromString("deadline tasks"));
		assertEquals(TaskType.DEADLINE_TASK, InputParser.getTaskTypeFromString("deadlines"));
		assertEquals(TaskType.DEADLINE_TASK, InputParser.getTaskTypeFromString("deadline"));
		assertEquals(TaskType.DEADLINE_TASK, InputParser.getTaskTypeFromString("lalala deadline task lalala"));
		assertEquals(null, InputParser.getTaskTypeFromString("lalaladeadline task lalala"));
		assertEquals(TaskType.DEADLINE_TASK, InputParser.getTaskTypeFromString("lalala deadlines lalala"));
		assertEquals(null, InputParser.getTaskTypeFromString("lalaladeadline lalala"));
		assertEquals(null, InputParser.getTaskTypeFromString("deadlineself"));

		assertEquals(TaskType.EVENT, InputParser.getTaskTypeFromString("eVent"));
		assertEquals(TaskType.EVENT, InputParser.getTaskTypeFromString("events"));
		assertEquals(TaskType.EVENT, InputParser.getTaskTypeFromString("lalala event lalala"));
		assertEquals(TaskType.EVENT, InputParser.getTaskTypeFromString("lalala events lalala"));
		assertEquals(null, InputParser.getTaskTypeFromString("lalaevent lalala"));
		assertEquals(null, InputParser.getTaskTypeFromString("eventsal"));

	}
	
	// For testing to be able to access InputParser protected methods 
	protected ParsedCommand parse(String[] input) {
		return null;
	}
	
}
```
###### test\LogicTestSuite.java
``` java

package test;

import org.junit.runner.RunWith;
import org.junit.runners.Suite;

@RunWith(Suite.class)
@Suite.SuiteClasses({ 
	AddTest.class,
	TaskTest.class,
	UpdateTest.class,
	LogicTest.class,
	SearchTest.class
})


public class LogicTestSuite {

}
```
###### test\MyParserTest.java
``` java

package test;

import static org.junit.Assert.*;

import java.util.ArrayList;

import org.junit.Before;
import org.junit.Test;

import gui.GuiController;
import parser.MyParser;
import parser.ParsedCommand;
import parser.MyParser.CommandType;
import parser.ParsedCommand.ConfigType;
import parser.ParsedCommand.TaskType;

public class MyParserTest {
	private ParsedCommand pc;
	private ParsedCommand pcAdd;
	private ParsedCommand pcUndo;
	private ParsedCommand pcEdit;
	private ParsedCommand pcDelete;
	private ParsedCommand pcDone;
	private ParsedCommand pcDisplay;
	private ParsedCommand pcConfig;
	private ParsedCommand pcHelp;
	private ParsedCommand pcGui;
	private ParsedCommand pcSearch;
	private ParsedCommand pcExit;
	
	private ArrayList<String> emptyArrayList = new ArrayList<String>();
	
	@Before
	public void setUp() throws Exception {
	    ParserTestingMethods.initLogging();
	}

	@Test
	public void testParseCommand() {
		// Check null input returns no user input error
		pc = MyParser.parseCommand(null);
		assertEquals(MyParser.CommandType.ERROR, pc.getCommandType());
		assertEquals("Error: No user input", pc.getErrorMessage());

		// Check empty string returns no user input error
		pc = MyParser.parseCommand("");
		assertEquals(MyParser.CommandType.ERROR, pc.getCommandType());
		assertEquals("Error: No user input", pc.getErrorMessage());

		// Check empty input returns no user input error
		pc = MyParser.parseCommand(" ");
		assertEquals(MyParser.CommandType.ERROR, pc.getCommandType());
		assertEquals("Error: No user input", pc.getErrorMessage());

		// Check unrecognised command returns invalid command error
		pc = MyParser.parseCommand("hello");
		assertEquals(MyParser.CommandType.ERROR, pc.getCommandType());
		assertEquals("Error: Invalid command", pc.getErrorMessage());
	}

	@Test
	public void testParseCommandAdd() {
		ArrayList<String> taskTags = new ArrayList<String>();
		taskTags.add("cs2103");
		taskTags.add("proj");
		taskTags.add("cs2101");
		
		// Floating tasks
		// Check support for floating task
		pcAdd = MyParser.parseCommand("Add meeting with john #cs2103 #proj \"rmb to \"bring\" notes\" #cs2101");
		assertEquals(MyParser.CommandType.ADD, pcAdd.getCommandType());
		assertEquals("meeting with john", pcAdd.getTitle());
		assertEquals("rmb to \"bring\" notes", pcAdd.getDescription());
		assertEquals(null, pcAdd.getFirstDate());
		assertEquals(null, pcAdd.getSecondDate());
		assertEquals(taskTags, pcAdd.getTags());
		assertEquals(TaskType.FLOATING_TASK, pcAdd.getTaskType());

		// Check support for floating task containing keyword
		pcAdd = MyParser.parseCommand("Add meeting with \\\"john\\\" on software requirements #cs2103 #proj #cs2101");
		assertEquals(CommandType.ADD, pcAdd.getCommandType());
		assertEquals("meeting with \"john\" on software requirements", pcAdd.getTitle());
		assertEquals("", pcAdd.getDescription());
		assertEquals(null, pcAdd.getFirstDate());
		assertEquals(null, pcAdd.getSecondDate());
		assertEquals(taskTags, pcAdd.getTags());
		assertEquals(TaskType.FLOATING_TASK, pcAdd.getTaskType());
		

		// Deadline tasks
		// Check support for deadline task formatted date (no keyword)
		pcAdd = MyParser.parseCommand("InSERT meeting with john 1/4/15 from 3pm until 7.30pm");
		assertEquals(MyParser.CommandType.ADD, pcAdd.getCommandType());
		assertEquals("meeting with john", pcAdd.getTitle());
		assertEquals("", pcAdd.getDescription());
		assertEquals(ParserTestingMethods.parseStringToDate("1/4/15 15:00"), pcAdd.getFirstDate().getTime());
		assertEquals(ParserTestingMethods.parseStringToDate("1/4/15 19:30"), pcAdd.getSecondDate().getTime());
		assertEquals(emptyArrayList, pcAdd.getTags());
		assertEquals(TaskType.EVENT, pcAdd.getTaskType());
		
		// Check support for deadline task tmr without keyword
		pcAdd = MyParser.parseCommand("+ meeting with john tmr at 12pm");
		assertEquals(MyParser.CommandType.ADD, pcAdd.getCommandType());
		assertEquals("meeting with john", pcAdd.getTitle());
		assertEquals("", pcAdd.getDescription());
		assertEquals(ParserTestingMethods.parseNDaysToDate(1, 12, 0), pcAdd.getFirstDate().getTime());
		assertEquals(null, pcAdd.getSecondDate());
		assertEquals(emptyArrayList, pcAdd.getTags());
		assertEquals(TaskType.DEADLINE_TASK, pcAdd.getTaskType());
		
		// Check support for deadline task natty
		pcAdd = MyParser.parseCommand("Add meeting with john on tmr");
		assertEquals(MyParser.CommandType.ADD, pcAdd.getCommandType());
		assertEquals("meeting with john", pcAdd.getTitle());
		assertEquals("", pcAdd.getDescription());
		assertEquals(ParserTestingMethods.parseNDaysToDate(1, 23, 59), pcAdd.getFirstDate().getTime());
		assertEquals(null, pcAdd.getSecondDate());
		assertEquals(emptyArrayList, pcAdd.getTags());
		assertEquals(TaskType.DEADLINE_TASK, pcAdd.getTaskType());
		
		
		// Events
		// Check support for event spanning 2 days
		pcAdd = MyParser.parseCommand("add meeting with john 23/11/10 12:00h to 24/11/10 13:30H  #cs2103 #proj #cs2101");
		assertEquals(MyParser.CommandType.ADD, pcAdd.getCommandType());
		assertEquals("meeting with john", pcAdd.getTitle());
		assertEquals("", pcAdd.getDescription());
		assertEquals(ParserTestingMethods.parseStringToDate("23/11/10 12:00"), pcAdd.getFirstDate().getTime());
		assertEquals(ParserTestingMethods.parseStringToDate("24/11/10 13:30"), pcAdd.getSecondDate().getTime());
		assertEquals(TaskType.EVENT, pcAdd.getTaskType());
		
		// Check support for event spanning 2 days natty
		pcAdd = MyParser.parseCommand("add meeting with john on tMr Till 3 daYs later #cs2103 #proj #cs2101");
		assertEquals(MyParser.CommandType.ADD, pcAdd.getCommandType());
		assertEquals("meeting with john", pcAdd.getTitle());
		assertEquals("", pcAdd.getDescription());
		assertEquals(ParserTestingMethods.parseNDaysToDate(1, 0, 0), pcAdd.getFirstDate().getTime());
		assertEquals(ParserTestingMethods.parseNDaysToDate(3, 23, 59), pcAdd.getSecondDate().getTime());
		assertEquals(TaskType.EVENT, pcAdd.getTaskType());
		
		// Check support for event spanning 2 days
		pcAdd = MyParser.parseCommand("add meeting with john on 20 days after nov 2010  #cs2103 #proj #cs2101");
		assertEquals(MyParser.CommandType.ADD, pcAdd.getCommandType());
		assertEquals("meeting with john", pcAdd.getTitle());
		assertEquals("", pcAdd.getDescription());
		assertEquals(ParserTestingMethods.parseNDaysToDate(20, 23, 59), pcAdd.getFirstDate().getTime());
		assertEquals(null, pcAdd.getSecondDate());
		assertEquals(TaskType.DEADLINE_TASK, pcAdd.getTaskType());
		assertEquals(taskTags, pcAdd.getTags());
				
		
		// Check date keywords are removed correctly
		// Date keywords not removed when no date
		pcAdd = MyParser.parseCommand("InSERT meeting with john on cats");
		assertEquals(MyParser.CommandType.ADD, pcAdd.getCommandType());
		assertEquals("meeting with john on cats", pcAdd.getTitle());
		assertEquals("", pcAdd.getDescription());
		assertEquals(null, pcAdd.getFirstDate());
		assertEquals(null, pcAdd.getSecondDate());
		assertEquals(emptyArrayList, pcAdd.getTags());
		assertEquals(TaskType.FLOATING_TASK, pcAdd.getTaskType());
				
		// Last keyword section removed when there are dates (tmr)
		pcAdd = MyParser.parseCommand("InSERT meeting with john On cats on tmr");
		assertEquals(MyParser.CommandType.ADD, pcAdd.getCommandType());
		assertEquals("meeting with john On cats", pcAdd.getTitle());
		assertEquals("", pcAdd.getDescription());
		assertEquals(ParserTestingMethods.parseNDaysToDate(1, 23, 59), pcAdd.getFirstDate().getTime());
		assertEquals(null, pcAdd.getSecondDate());
		assertEquals(emptyArrayList, pcAdd.getTags());
		assertEquals(TaskType.DEADLINE_TASK, pcAdd.getTaskType());

		// Last keyword section removed when there are dates (tmr)
		pcAdd = MyParser.parseCommand("InSERT meeting with john on cats on fri");
		assertEquals(MyParser.CommandType.ADD, pcAdd.getCommandType());
		assertEquals("meeting with john on cats", pcAdd.getTitle());
		assertEquals("", pcAdd.getDescription());
		assertEquals(ParserTestingMethods.nextDayOfWeek(6).getTime().toString(), pcAdd.getFirstDate().getTime().toString());
		assertEquals(null, pcAdd.getSecondDate());
		assertEquals(emptyArrayList, pcAdd.getTags());
		assertEquals(TaskType.DEADLINE_TASK, pcAdd.getTaskType());

		// Invalid inputs
		// Check invalid date returns invalid date error, where invalid date is in proper format
		pcAdd = MyParser.parseCommand("Add meeting with john 31-4.10 12:00h #proj");
		assertEquals(MyParser.CommandType.ERROR, pcAdd.getCommandType());
		assertEquals("Error: Invalid date(s) input", pcAdd.getErrorMessage());
		
		// Check missing arguments returns no arguments error
		pcAdd = MyParser.parseCommand("Add");
		assertEquals(MyParser.CommandType.ERROR, pcAdd.getCommandType());
		assertEquals("Error: No arguments entered", pcAdd.getErrorMessage());
	
		// Check missing title returns no title error
		pcAdd = MyParser.parseCommand("Add 2/3/15 3pm \"hello hello\" #tag1 #tag2");
		assertEquals(MyParser.CommandType.ERROR, pcAdd.getCommandType());
		assertEquals("Error: Missing task title", pcAdd.getErrorMessage());

		// Check missing title returns no title error
		pcAdd = MyParser.parseCommand("Add on tmr 3pm \"hello hello\" #tag1 #tag2");
		assertEquals(MyParser.CommandType.ERROR, pcAdd.getCommandType());
		assertEquals("Error: Missing task title", pcAdd.getErrorMessage());

		// Check escape character usage
		// Check missing fields detected even with escape character
		pcAdd = MyParser.parseCommand("Add \\");
		assertEquals(MyParser.CommandType.ERROR, pcAdd.getCommandType());
		assertEquals("Error: Missing task title", pcAdd.getErrorMessage());
		
		// Check escape character can be escaped
		pcAdd = MyParser.parseCommand("Add \\\\");
		assertEquals(MyParser.CommandType.ADD, pcAdd.getCommandType());
		assertEquals("\\", pcAdd.getTitle());	
	}

	@Test
	public void testParseCommandDelete() {
		// Check delete
		pcDelete = MyParser.parseCommand("Delete 234");
		assertEquals(MyParser.CommandType.DELETE, pcDelete.getCommandType());
		assertEquals(234, pcDelete.getTaskId());

		// Check allow extra whitespace
		pcDelete = MyParser.parseCommand("Delete  234");
		assertEquals(MyParser.CommandType.DELETE, pcDelete.getCommandType());
		assertEquals(234, pcDelete.getTaskId());

		// Check missing arguments returns no arguments error
		pcDelete = MyParser.parseCommand("delete");
		assertEquals(MyParser.CommandType.ERROR, pcDelete.getCommandType());
		assertEquals("Error: No arguments entered", pcDelete.getErrorMessage());

		// Check invalid/missing taskId returns error
		pcDelete = MyParser.parseCommand("delete abc");
		assertEquals(MyParser.CommandType.ERROR, pcDelete.getCommandType());
		assertEquals("Error: Invalid/Missing taskId", pcDelete.getErrorMessage());
	}

	@Test
	public void testParseCommandDisplay() {
		pcDisplay = MyParser.parseCommand("show 234");
		assertEquals(MyParser.CommandType.DISPLAY, pcDisplay.getCommandType());
		assertEquals(234, pcDisplay.getTaskId());

		// Check allow extra whitespace
		pcDisplay = MyParser.parseCommand("show  	234");
		assertEquals(MyParser.CommandType.DISPLAY, pcDisplay.getCommandType());
		assertEquals(234, pcDisplay.getTaskId());

		// Check missing arguments returns GUI command
		pcDisplay = MyParser.parseCommand("show");
		assertEquals(MyParser.CommandType.GUI_SHOW, pcDisplay.getCommandType());
		
		ParsedCommand pcShow = MyParser.parseCommand("show 234");
		assertEquals(MyParser.CommandType.DISPLAY, pcShow.getCommandType());
		assertEquals(234, pcShow.getTaskId());
		
		pcShow = MyParser.parseCommand("display 0");
		assertEquals(MyParser.CommandType.DISPLAY, pcShow.getCommandType());
		assertEquals(0, pcShow.getTaskId());

		pcShow = MyParser.parseCommand("shoW -1");
		assertEquals(MyParser.CommandType.SEARCH, pcShow.getCommandType());
		assertEquals("-1", pcShow.getKeywords());		
	}
	
	@Test
	public void testCreateParsedCommandShowSearch() {
		ArrayList<String> tags = new ArrayList<String>();
		tags.add("tag");
		
		// Search for date
		pcSearch = MyParser.parseCommand("search 23/11");
		assertEquals(MyParser.CommandType.SEARCH, pcSearch.getCommandType());
		assertEquals("", pcSearch.getKeywords());
		assertEquals(ParserTestingMethods.parseStringToDate("23/11/15 00:00"), pcSearch.getFirstDate().getTime());
		assertEquals(ParserTestingMethods.parseStringToDate("23/11/15 23:59"), pcSearch.getSecondDate().getTime());
		
		pcSearch = MyParser.parseCommand("search 23 Nov");
		assertEquals(MyParser.CommandType.SEARCH, pcSearch.getCommandType());
		assertEquals("", pcSearch.getKeywords());
		assertEquals(ParserTestingMethods.parseStringToDate("23/11/15 00:00"), pcSearch.getFirstDate().getTime());
		assertEquals(ParserTestingMethods.parseStringToDate("23/11/15 23:59"), pcSearch.getSecondDate().getTime());
		
		// Search multiple fields
		pcSearch = MyParser.parseCommand("show meeting on 23/11/15 #tag todo deadline");
		assertEquals(MyParser.CommandType.SEARCH, pcSearch.getCommandType());
		assertEquals("meeting", pcSearch.getKeywords());
		assertEquals(ParserTestingMethods.parseStringToDate("23/11/15 00:00"), pcSearch.getFirstDate().getTime());
		assertEquals(ParserTestingMethods.parseStringToDate("23/11/15 23:59"), pcSearch.getSecondDate().getTime());
		ArrayList<String> list = new ArrayList<String>();
		list.add("tag");
		assertEquals(list, pcSearch.getTags());
		assertEquals(false, pcSearch.isCompleted());
		assertEquals(TaskType.DEADLINE_TASK, pcSearch.getTaskType());
		assertEquals(false, pcSearch.isOverdue());
		
		// Check search function works
		pcSearch = MyParser.parseCommand("show meeting 23/11/15 23:59 #tag Todo oveRdue");
		assertEquals(MyParser.CommandType.SEARCH, pcSearch.getCommandType());
		assertEquals("meeting", pcSearch.getKeywords());
		assertEquals(ParserTestingMethods.parseStringToDate("23/11/15 23:59"), pcSearch.getFirstDate().getTime());
		assertEquals(ParserTestingMethods.parseStringToDate("23/11/15 23:59"), pcSearch.getSecondDate().getTime());
		list = new ArrayList<String>();
		list.add("tag");
		assertEquals(list, pcSearch.getTags());
		assertEquals(false, pcSearch.isCompleted());
		assertEquals(null, pcSearch.getTaskType());
		assertEquals(true, pcSearch.isOverdue());
		
		// Words in quotes are not detected
		ParsedCommand pcShow = MyParser.parseCommand(" Show my search keywords from 1/4/16 3pm to 5pm #tag");
		assertEquals(CommandType.SEARCH, pcShow.getCommandType());
		assertEquals("my search keywords", pcShow.getKeywords());
		assertEquals(ParserTestingMethods.parseStringToDate("1/4/16 15:00"), pcShow.getFirstDate().getTime());
		assertEquals(ParserTestingMethods.parseStringToDate("1/4/16 17:00"), pcShow.getSecondDate().getTime());
		assertEquals(tags, pcShow.getTags());		
		
		// Invalid input returns error
		pcShow = MyParser.parseCommand("search my search keywords from 31/4/16 3pm to 5pm #tag");
		assertEquals(CommandType.ERROR, pcShow.getCommandType());
		assertEquals("Error: Invalid date(s) input", pcShow.getErrorMessage());
	}

	@Test
	public void testParseCommandEdit() {
		// Check support for invalid date
		pcEdit = MyParser.parseCommand("Edit   234 meeting 31/2/15 \"hello\" #tag");
		assertEquals(MyParser.CommandType.ERROR, pcEdit.getCommandType());
						
		// Check support for edit title, description, date, time, tag
		pcEdit = MyParser.parseCommand("Edit 234 meeting \"hello\" 23/11/10 13:00-15:00 #tag");
		assertEquals(MyParser.CommandType.EDIT, pcEdit.getCommandType());
		assertEquals("hello", pcEdit.getDescription());
		assertEquals(ParserTestingMethods.parseStringToDate("23/11/10 13:00"), pcEdit.getFirstDate().getTime());
		assertEquals(ParserTestingMethods.parseStringToDate("23/11/10 15:00"), pcEdit.getSecondDate().getTime());
		ArrayList<String> list = new ArrayList<String>();
		list.add("tag");
		assertEquals(list, pcEdit.getTags());
		assertEquals("meeting", pcEdit.getTitle());

		// Check support for edit description, date, time, tag (flexible)
		pcEdit = MyParser.parseCommand("Edit 234 by nov 23 1-3pm \"hello\" #tag");
		assertEquals(MyParser.CommandType.EDIT, pcEdit.getCommandType());
		assertEquals("hello", pcEdit.getDescription());
		assertEquals(ParserTestingMethods.parseStringToDate("23/11/15 13:00"), pcEdit.getFirstDate().getTime());
		assertEquals(ParserTestingMethods.parseStringToDate("23/11/15 15:00"), pcEdit.getSecondDate().getTime());
		ArrayList<String> list1 = new ArrayList<String>();
		list1.add("tag");
		assertEquals(list1, pcEdit.getTags());
		assertEquals("", pcEdit.getTitle());
		
		// Check allow extra whitespace
		pcEdit = MyParser.parseCommand("Edit 234 test");
		assertEquals(MyParser.CommandType.EDIT, pcEdit.getCommandType());
		assertEquals(234, pcEdit.getTaskId());
		assertEquals("test", pcEdit.getTitle());
		
		// Check missing field inputs returns error
		pcEdit = MyParser.parseCommand("Edit 234");
		assertEquals(MyParser.CommandType.ERROR, pcEdit.getCommandType());
		assertEquals("Error: No fields were entered for editing", pcEdit.getErrorMessage());

		// Check missing arguments returns error
		pcEdit = MyParser.parseCommand("edit");
		assertEquals(MyParser.CommandType.ERROR, pcEdit.getCommandType());
		assertEquals("Error: No arguments entered", pcEdit.getErrorMessage());

		// Check invalid taskId returns error
		pcEdit = MyParser.parseCommand("edit abc #hello");
		assertEquals(MyParser.CommandType.ERROR, pcEdit.getCommandType());
		assertEquals("Error: Invalid/Missing taskId", pcEdit.getErrorMessage());
		
		// Check invalid date returns error
		pcEdit = MyParser.parseCommand("edit 123 31/2/16 #hello");
		assertEquals(MyParser.CommandType.ERROR, pcEdit.getCommandType());
		assertEquals("Error: Invalid date(s) input", pcEdit.getErrorMessage());
	}

	@Test
	public void testParseCommandUndo() {
		pcUndo = MyParser.parseCommand("Undo");
		assertEquals(MyParser.CommandType.UNDO, pcUndo.getCommandType());
		
		pcUndo = MyParser.parseCommand("redO");
		assertEquals(MyParser.CommandType.REDO, pcUndo.getCommandType());
	}
	
	@Test
	public void testParseCommandExit() {
		pcExit = MyParser.parseCommand("Q;");
		assertEquals(MyParser.CommandType.EXIT, pcExit.getCommandType());
	}
	
	@Test
	public void testParseCommandHelp() {
		pcHelp = MyParser.parseCommand("help");
		assertEquals(MyParser.CommandType.HELP, pcHelp.getCommandType());
		
		pcHelp = MyParser.parseCommand("?");
		assertEquals(MyParser.CommandType.HELP, pcHelp.getCommandType());
	}

	@Test
	public void testParseCommandFlag() {
		// Partition 1: FLAG
		// Check flag command for done
		pcDone = MyParser.parseCommand("Flag completed 234");
		assertEquals(MyParser.CommandType.FLAG, pcDone.getCommandType());
		assertEquals(true, pcDone.isCompleted());
		assertEquals(234, pcDone.getTaskId());
		
		// Check flag for todo
		pcDone = MyParser.parseCommand("flag   TODO  234");
		assertEquals(MyParser.CommandType.FLAG, pcDone.getCommandType());
		assertEquals(false, pcDone.isCompleted());
		assertEquals(234, pcDone.getTaskId());

		
		// Partition 2: DONE
		// Check standard input
		pcDone = MyParser.parseCommand("Done 234");
		assertEquals(MyParser.CommandType.FLAG, pcDone.getCommandType());
		assertEquals(true, pcDone.isCompleted());
		assertEquals(234, pcDone.getTaskId());

		// Check allow extra whitespace
		pcDone = MyParser.parseCommand("finished  234");
		assertEquals(MyParser.CommandType.FLAG, pcDone.getCommandType());
		assertEquals(true, pcDone.isCompleted());
		assertEquals(234, pcDone.getTaskId());

		// Check missing arguments returns error
		pcDone = MyParser.parseCommand("done ");
		assertEquals(MyParser.CommandType.ERROR, pcDone.getCommandType());
		assertEquals("Error: No arguments entered", pcDone.getErrorMessage());

		// Check invalid/missing taskId returns error
		pcDone = MyParser.parseCommand("done abc");
		assertEquals(MyParser.CommandType.ERROR, pcDone.getCommandType());
		assertEquals("Error: Invalid/Missing taskId", pcDone.getErrorMessage());
		
		
		// Partition 3: TODO (similar pathway as DONE)
		pcDone = MyParser.parseCommand("todo 234");
		assertEquals(MyParser.CommandType.FLAG, pcDone.getCommandType());
		assertEquals(false, pcDone.isCompleted());
		assertEquals(234, pcDone.getTaskId());
	}
	
	@Test
	public void testGetErrorMessage() {
		// Check returns null if irrelevant (not an error)
		pcDone = MyParser.parseCommand("Done 234");
		assertEquals(MyParser.CommandType.FLAG, pcDone.getCommandType());
		assertEquals(null, pcDone.getErrorMessage());
	}
	
	@Test
	public void testParseCommandConfig() {
		// Check missing config type
		pcConfig = MyParser.parseCommand("Set");
		assertEquals(MyParser.CommandType.ERROR, pcConfig.getCommandType());
		assertEquals("Error: No arguments entered", pcConfig.getErrorMessage());
		
		// Check invalid config type
		pcConfig = MyParser.parseCommand("Set file");
		assertEquals(MyParser.CommandType.ERROR, pcConfig.getCommandType());
		assertEquals("Error: Invalid command", pcConfig.getErrorMessage());
		
		// Check missing path
		pcConfig = MyParser.parseCommand("set folder");
		assertEquals(MyParser.CommandType.ERROR, pcConfig.getCommandType());
		assertEquals("Error: No arguments entered", pcConfig.getErrorMessage());
		
		// Check missing path
		pcConfig = MyParser.parseCommand("set background");
		assertEquals(MyParser.CommandType.ERROR, pcConfig.getCommandType());
		assertEquals("Error: No arguments entered", pcConfig.getErrorMessage());
				
		// Check config data
		pcConfig = MyParser.parseCommand("set folder C:\\file name\\folder");
		assertEquals(MyParser.CommandType.CONFIG_DATA, pcConfig.getCommandType());
		assertEquals("C:\\file name\\folder", pcConfig.getConfigPath());
		
		// Check config img background
		pcConfig = MyParser.parseCommand("set background filePath");
		assertEquals(MyParser.CommandType.CONFIG_IMG, pcConfig.getCommandType());
		assertEquals(ConfigType.BACKGROUND, pcConfig.getConfigType());
		assertEquals("filePath", pcConfig.getConfigPath());
						
		// Check config img avatar
		pcConfig = MyParser.parseCommand("set avatar filePath");
		assertEquals(MyParser.CommandType.CONFIG_IMG, pcConfig.getCommandType());
		assertEquals(ConfigType.AVATAR, pcConfig.getConfigType());
		assertEquals("filePath", pcConfig.getConfigPath());
		
	}
	
	@Test
	public void testGuiCommands() {
		pcGui = MyParser.parseCommand("Open 1");
		assertEquals(CommandType.GUI_OPEN, pcGui.getCommandType());
		assertEquals("0", pcGui.getGuiType());
		
		String tabName = GuiController.taskListNames[2];
		pcGui = MyParser.parseCommand("Close " + tabName);
		assertEquals(CommandType.GUI_CLOSE, pcGui.getCommandType());
		assertEquals("-3", pcGui.getGuiType());
		
		pcGui = MyParser.parseCommand("Close random");
		assertEquals(CommandType.ERROR, pcGui.getCommandType());
		assertEquals("Error: Invalid tab ID", pcGui.getErrorMessage());
		
		pcGui = MyParser.parseCommand("pin");
		assertEquals(CommandType.ERROR, pcGui.getCommandType());
		assertEquals("Error: No arguments entered", pcGui.getErrorMessage());
		
		pcGui = MyParser.parseCommand("log");
		assertEquals(CommandType.GUI_LOG, pcGui.getCommandType());
		
		pcGui = MyParser.parseCommand("mAin");
		assertEquals(CommandType.GUI_MAIN, pcGui.getCommandType());
		
		pcGui = MyParser.parseCommand("switcH");
		assertEquals(CommandType.GUI_SWITCH, pcGui.getCommandType());
	}
}
```
###### test\ParserTestingMethods.java
``` java

package test;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.text.SimpleDateFormat;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.Calendar;
import java.util.Date;
import java.util.logging.Level;
import java.util.logging.LogManager;
import java.util.logging.Logger;

public class ParserTestingMethods {
```
###### test\ParserTestingMethods.java
``` java
	static Calendar nextDayOfWeek(int day) {
        Calendar date = Calendar.getInstance();
        int difference = day - date.get(Calendar.DAY_OF_WEEK);
        if (difference < 0) {
            difference += 7;
        }
        date.add(Calendar.DAY_OF_MONTH, difference);
        date.set(Calendar.HOUR_OF_DAY, 23);
        date.set(Calendar.MINUTE, 59);
        date.set(Calendar.SECOND, 0);
        return date;
    }
	
	static Date parseStringToDate(String input) {
		if (input == null) {
			return null;
		}
		Date date = new Date();
			SimpleDateFormat format = new SimpleDateFormat("d/M/yy HH:mm");
			try {
				date = format.parse(input);
			} catch (java.text.ParseException e) {
				return null;
			}
			return date;
	}
	
	static String inNDays(int n, int h, int m) {
		DateTimeFormatter formatter = DateTimeFormatter.ofPattern("d/M/yy HH:mm");
		LocalDateTime date = LocalDateTime.now();
		date = LocalDateTime.from(date.plusDays(n));
		date = date.withHour(h).withMinute(m).withSecond(0);
		return date.format(formatter);
	}
	
	static Date parseNDaysToDate(int n, int h, int m) {
		String dateString = inNDays(n, h, m);
		return parseStringToDate(dateString);
	}


}
```
###### test\ParserTestSuite.java
``` java

package test;

import org.junit.runner.RunWith;
import org.junit.runners.Suite;

@RunWith(Suite.class)
@Suite.SuiteClasses({ 
	MyParserTest.class, 
	DateTimeParserTest.class,
	test.InputParserTest.class
})

public class ParserTestSuite {

}
```
