# A0124777W
###### logic\Add.java
``` java
public class Add implements Command {

	private static final TaskType TASK = TaskType.FLOATING_TASK;
	private static final TaskType DEADLINETASK = TaskType.DEADLINE_TASK;
	private static final TaskType EVENT = TaskType.EVENT;
	public static final String MESSAGE_ADDED = "%1$s added";

	private Task newTask;
	private ParsedCommand specifications;
	private int id;
	private Storage storage;
	private Model model;

	public Add(ParsedCommand specifications, Storage storage,Model model) {
		this.specifications = specifications;
		newTask = new Task(specifications);
		this.id = Logic.getNewId();
		this.storage = storage;
		this.model = model;
	}

	@Override
	public void execute() {
		if (specifications.getTaskType() == ParsedCommand.TaskType.FLOATING_TASK) {
			newTask = new Task(specifications);
			newTask.setId(id);
			storage.add(newTask);
		} else if (specifications.getTaskType() == ParsedCommand.TaskType.DEADLINE_TASK) {
			DeadlineTask newDeadlineTask = new DeadlineTask(specifications);
			newDeadlineTask.setId(id);
			storage.add(newDeadlineTask);
			newTask = newDeadlineTask;
		} else if (specifications.getTaskType() == ParsedCommand.TaskType.EVENT) {
			Event newEvent = new Event(specifications);
			newEvent.setId(id);
			storage.add(newEvent);
			newTask = newEvent;
		}

		model.updateModel(String.format(MESSAGE_ADDED, newTask.getName()),newTask.getId());
	}

	@Override
	public void undo() {
		storage.delete(id);

		model.updateModel();
	}

	/*
	 * Checks whether the parsedInput is valid. Does not check task ID as parser does not
	 * currently set task id.
	 */
	public static boolean checkValid(ParsedCommand parsedInput, Model view) {
		ParsedCommand.TaskType taskType = parsedInput.getTaskType();

		// Check if Task fields are present
		if (parsedInput.getTitle() == null) {
			view.setConsoleMessage("Error: Missing task title");
			return false;
		}
		if (taskType==null) {
			view.setConsoleMessage("Error: task type missing");
			return false;
		}
		if (taskType == TASK) {
			if (parsedInput.getSecondDate() != null) { // Error: Task Should have no End Field
				view.setConsoleMessage("Error: Task Should have no end field");
				return false;
			} else if (parsedInput.getFirstDate() != null) { // Error: Task Should have no Start Field
				view.setConsoleMessage("Error: Task Should have no start field");
				return false;
			}
		} else if (taskType == DEADLINETASK) {
			if (parsedInput.getSecondDate() != null) { // Error: DeadlineTask Should have no Start Field
				view.setConsoleMessage("Error: DeadlineTask Should have no start date");
				return false;
			} else if (parsedInput.getFirstDate() == null) {
				view.setConsoleMessage("Error: DeadlineTask should have an end date");
				return false;
			}
		} else if (taskType == EVENT) {
			if (parsedInput.getFirstDate() == null || parsedInput.getSecondDate() == null) {
				view.setConsoleMessage("Error: Event should have start and end dates");
				return false;
			}
		}

		return true;
	}

}
```
###### logic\Command.java
``` java
public interface Command {

	public void execute();

	public void undo();
}
```
###### logic\DeadlineTask.java
``` java
public class DeadlineTask extends Task {

	protected Calendar end;

	public DeadlineTask(String name, String details,int id,boolean isCompleted,ArrayList<String> tags,
			TaskType taskType, Calendar end) {
		super(name, details,id,isCompleted,tags,taskType);
		setEnd(end);
	}

	/*
	 *	Constructor for testing
	 */
	public DeadlineTask() {

	}

	/*
	 *	Constructor for upgrading a Task into a DeadlineTask
	 */
	public DeadlineTask(Task task, Calendar end) {
		super(task.getName(), task.getDescription(), task.getId(), task.getIsCompleted(), task.getTags(), TaskType.DEADLINE_TASK);
		this.end = end;
	}

	/*
	 *	Constructor used for Cloning Tasks
	 */
	public DeadlineTask(DeadlineTask newTask) {
		super(newTask.getName(),newTask.getDescription(),newTask.getId(),newTask.getIsCompleted(),newTask.getTags(),newTask.getTaskType());
		this.end = newTask.getEnd();
	}


	/*
	 *	Constructor for creating a new DeadlineTask from user input
	 */
	public DeadlineTask(ParsedCommand parsedInput) {
		super(parsedInput);
		this.end = parsedInput.getFirstDate();
	}

	/*
	 *	Returns all task fields in a String array format for displaying. The String array is formatted such that
	 *	array[0] contains the field name and array[1] contains the field data value. An ArrayList containing the
	 *	String array fields is returned.
	 *
	 *	@return an Arraylist of two field arrays(i.e. array[2]) containing the String data
	 *
	 */
	public ArrayList<String[]> getTaskDetails() {
		ArrayList<String[]> task = super.getTaskDetails();;
		String[] array = new String[2];
		
		array[0] = "End";
		array[1] = Logic.displayDateFormatter.format(end.getTime());
		task.add(array);
		
		return task;
	}

	public Calendar getEnd() {
		return end;
	}

	public void setEnd(Calendar end) {
		this.end = end;
	}
}
```
###### logic\Delete.java
``` java
public class Delete implements Command {

	public static final String MESSAGE_TASK_DELETED = "Task %1$s deleted";
	private Task toDelete;
	private int taskId;
	private Storage storage;
	private Model model;

	public Delete(Storage storage) {
		this.storage = storage;
	}

	public Delete(ParsedCommand specifications,Storage storage,Model model) {
		this.model = model;
		List<Task> taskList = storage.getAllTasks();
		this.taskId = specifications.getTaskId();
		this.toDelete = Logic.searchList(taskList,taskId);
		this.storage = storage;
	}

	@Override
	public void execute() {
		storage.delete(taskId);

		model.updateModel(String.format(MESSAGE_TASK_DELETED, taskId));
	}

	@Override
	public void undo() {
		Task deleted = toDelete;
		storage.add(deleted);

		model.updateFocus(deleted.getId());
	}


	public static boolean checkValid(ParsedCommand specifications, Model model) {
		int idToCheck = specifications.getTaskId();
		if (!Logic.checkID(idToCheck)) {
			model.setConsoleMessage(Logic.ERROR_INVALID_ID);
			return false;
		}
		return true;
	}

}
```
###### logic\Event.java
``` java
public class Event extends Task {

	protected Calendar start;
	protected Calendar end;

	public Event() {

	}

	/*
	 *	Constructor for upgrading Task to Event
	 */
	public Event(Task task, Calendar start, Calendar end) {
		super(task.getName(), task.getDescription(), task.getId(), task.getIsCompleted(), task.getTags(), TaskType.EVENT);
		this.start = start;
		this.end = end;
	}

	/*
	 *	Constructor for upgrading DeadlineTask to Event
	 */
	public Event(DeadlineTask dlTask, Calendar start) {
		super(dlTask.getName(), dlTask.getDescription(), dlTask.getId(), dlTask.getIsCompleted(), dlTask.getTags(), TaskType.EVENT);
		this.start = start;
		this.end = dlTask.getEnd();
	}


	public Event(String name, String details,int id,boolean isCompleted,ArrayList<String> tags,
			TaskType taskType, Calendar start, Calendar end) {
		super(name, details,id,isCompleted,tags,taskType);
		setStart(start);
		setEnd(end);
	}

	/*
	 *	Constructor used for Cloning Tasks
	 */
	public Event(Event newTask) {
		super(newTask.getName(),newTask.getDescription(),newTask.getId(),newTask.getIsCompleted(),newTask.getTags(),newTask.getTaskType());
		this.start = newTask.getStart();
		this.end = newTask.getEnd();
	}

	/*
	 *	Constructor for creating a new Event from user input
	 */
	public Event(ParsedCommand parsedInput) {
		super(parsedInput);
		this.start = parsedInput.getFirstDate();
		this.end = parsedInput.getSecondDate();
	}

	/*
	 *	Returns all task fields in a String array format for displaying. The String array is formatted such that
	 *	array[0] contains the field name and array[1] contains the field data value. An ArrayList containing the
	 *	String array fields is returned.
	 *
	 *	@return an Arraylist of two field arrays(i.e. array[2]) containing the String data
	 *
	 */
	public ArrayList<String[]> getTaskDetails() {
		ArrayList<String[]> task = super.getTaskDetails();
		String[] array = new String[2];
		
		array[0] = "Start";
		array[1] = Logic.displayDateFormatter.format(start.getTime());
		task.add(array);
		array = new String[2];
		array[0] = "End";
		array[1] = Logic.displayDateFormatter.format(end.getTime());
		task.add(array);
		
		return task;
	}

	public Calendar getStart() {
		return start;
	}

	public Calendar getEnd() {return end;}

	public void setStart(Calendar start) {
		this.start = start;
	}

	public void setEnd(Calendar end) {
		this.end = end;
	}
}
```
###### logic\Logic.java
``` java
public class Logic {

	// Date formatter for
	public static final SimpleDateFormat displayDateFormatter = new SimpleDateFormat("dd-MM-yyyy, HH:mm");

	// Error Messages
	public static final String ERROR_INVALID_ID = "Error: Invalid ID";
	public static final String ERROR_CANNOT_REDO = "Error: Cannot redo without first doing an undo";
	public static final String ERROR_SEARCH_FAILED = "Error: Search Failed";

	// Constants for Searching to end of the day
	public static final int TODAY_LAST_HOUR = 23;
	public static final int TODAY_LAST_MINUTE = 59;
	public static final int TODAY_LAST_SECOND = 59;

	// Search String queries
	public static final String INCOMPLTETED_TASKS = "isCompleted: false";
	public static final String FLOATING_TASKS = "taskType: FLOATING_TASK";

	// Messages
	public static final String MESSAGE_NO_RESULTS_FOUND = "No results found";
	public static final String MESSAGE_1_RESULT_FOUND = "1 result found";
	public static final String MESSAGE_NOTHING_TO_UNDO = "Nothing to undo";
	public static final String MESSAGE_UNDO_SUCCESSFUL = "Undo Successful";
	public static final String MESSAGE_AVATAR_SWITCHED = "Avatar switched";
	public static final String MESSAGE_FAILED_TO_SET_NEW_PATH = "Failed to Set new Path";
	public static final String MESSAGE_NOTHING_TO_REDO = "Oops! Nothing to redo!";
	public static final String MESSAGE_REDO_SUCCESSFUL = "Redo successful";
	public static final String MESSAGE_INVALID_FORMAT = "invalid command format :%1$s";
	public static final String MESSAGE_X_RESULTS_FOUND = "%1$s results found";
	public static final String MESSAGE_DATA_FILE_SET_TO = "data file set to %1$s";

	public static class UnrecognisedCommandException extends Exception {
		/**
		 *
		 */
		private static final long serialVersionUID = -297345203728757157L;

		public UnrecognisedCommandException(String message) {
			super(message);
		}
	}

	private Storage storage;
	private LinkedList<Command> commandHistory = new LinkedList<Command>();
	private Model model;
	private boolean canRedo = false;
	private LinkedList<Command> redoList = new LinkedList<Command>();

	private static final Logger logger = Logger.getGlobal();
	static {
		try {
			logger.addHandler(new FileHandler("Oracle log", 100000, 1, true));
		} catch (SecurityException e) {
			e.printStackTrace();
		} catch (IOException e) {
			e.printStackTrace();
		}
	}


	// Contructor used for testing purposes
	public Logic(Storage storage) {
		this.storage = storage;
		this.model = new Model(storage);
	}

	// Constructor
	public Logic() {
		storage = new Storage();
		model = new Model(storage);
	}

	/* 	Executes the user command based on the parsed input. Updates the Model based on
	 *	the command executed.
	 *	@param ParsedCommand
	 *	@return Model
	 */
	public Model executeCommand(ParsedCommand parsedCommand) throws UnrecognisedCommandException {
		logger.log(Level.INFO, "executing user input ", parsedCommand);
		if (checkIfEmptyCommand(parsedCommand)) {
			model.updateModel(MESSAGE_INVALID_FORMAT);
			return model;
		}

		assert(parsedCommand != null);

		switch (parsedCommand.getCommandType()) {
			case ADD:
				canRedo = false;
				return executeAdd(parsedCommand);
			case UNDO:
				canRedo = false;
				return executeUndo();
			case REDO:
				return executeRedo();
			case DELETE:
				return executeDelete(parsedCommand);
			case CONFIG_DATA:
				return executeSetData(parsedCommand);
			case CONFIG_IMG:
				return executeSet(parsedCommand);
			case FLAG:
				// Fall Over
			case EDIT:
				canRedo = false;
				return executeUpdate(parsedCommand);
			case DISPLAY:
				// Fall Over
			case SEARCH:
				return executeSearch(parsedCommand);
			case ERROR:
				model.updateModel(parsedCommand.getErrorMessage());
				return model;
			case EXIT:
				System.exit(0);
			default:
				// throw an error if the command is not recognized
				throw new UnrecognisedCommandException("Unrecognized command type: " + parsedCommand.getCommandType());
		}

	}

	/*
	 *	Method for changing Avatar
	 */
	private Model executeSet(ParsedCommand parsedCommand) {
		String consoleMessage = MESSAGE_FAILED_TO_SET_NEW_PATH;
		try {
			ParsedCommand.ConfigType type = parsedCommand.getConfigType();
			 if (type == ConfigType.AVATAR) {
				 storage.setAvatar(parsedCommand.getConfigPath());
				model.setAvatarLocation(parsedCommand.getConfigPath());
				consoleMessage = MESSAGE_AVATAR_SWITCHED;
			}
		} catch (Exception e) {
			logger.log(Level.WARNING, MESSAGE_FAILED_TO_SET_NEW_PATH, e);
			consoleMessage = MESSAGE_FAILED_TO_SET_NEW_PATH;
			this.model.setConsoleMessage(consoleMessage);
			e.printStackTrace();
			return model;
		}

		model.setConsoleMessage(consoleMessage);
		return model;
	}

	/*
	 *	Method for changing file folder
	 */
	private Model executeSetData(ParsedCommand parsedCommand) {

		String consoleMessage = MESSAGE_FAILED_TO_SET_NEW_PATH;
		try {
			storage.setFileLocation(parsedCommand.getConfigPath());
			consoleMessage = String.format(MESSAGE_DATA_FILE_SET_TO,parsedCommand.getConfigPath());
			this.model.setConsoleMessage(consoleMessage);
		} catch (Exception e) {
			logger.log(Level.WARNING, MESSAGE_FAILED_TO_SET_NEW_PATH, e);
			this.model.setConsoleMessage(consoleMessage);
			e.printStackTrace();
			return model;
		}
		return model;
	}

	/*
	 *	Method for executing search
	 */
	private Model executeSearch(ParsedCommand parsedCommand) {
		List<Task> tasksToDisplay;
		String consoleMessage;
		try {
			Search search = new Search();
			tasksToDisplay = search.multiSearch(storage.getAllTasks(), parsedCommand);
			if (tasksToDisplay.size() == 0) {
				consoleMessage = MESSAGE_NO_RESULTS_FOUND;
			} else if (tasksToDisplay.size() == 1) {
				consoleMessage = MESSAGE_1_RESULT_FOUND;
			} else {
				consoleMessage = String.format(MESSAGE_X_RESULTS_FOUND,tasksToDisplay.size());
			}
			model.updateSearch(consoleMessage, parsedCommand, tasksToDisplay);
		} catch (IOException | ParseException e) {
			logger.log(Level.WARNING, ERROR_SEARCH_FAILED, e);
			model.updateModel(ERROR_SEARCH_FAILED);
			e.printStackTrace();
			return model;
		}

		return model;
	}

	/*
	 *	Method for executing edit
	 */
	private Model executeUpdate(ParsedCommand userCommand) {

		Command command = new Update(userCommand, storage, model);
		if (!Update.checkValid(userCommand, model)) {
			return model;
		} else {
			command.execute();
			commandHistory.addFirst(command);
		}

		return model;
	}

	/*
	 *	Method for executing undo
	 */
	private Model executeUndo() {
		canRedo = true;
		if (commandHistory.size() != 0) {
			Command toUndo = commandHistory.poll();
			redoList.addFirst(toUndo);
			toUndo.undo();
			model.updateModel(MESSAGE_UNDO_SUCCESSFUL);
		} else {
			model.updateModel(MESSAGE_NOTHING_TO_UNDO);
		}
		return model;
	}

	/*
	 *	Method for executing Redo
	 */
	private Model executeRedo() {
		if (canRedo) {
			if (redoList.size() != 0) {
				Command toRedo = redoList.poll();
				commandHistory.addFirst(toRedo);
				toRedo.execute();
				model.updateModel(MESSAGE_REDO_SUCCESSFUL);
			} else {
				model.updateModel(MESSAGE_NOTHING_TO_REDO);
			}
		} else {
			model.updateModel(ERROR_CANNOT_REDO);
		}
		return model;
	}

	/*
	 *	Method for executing delete
	 */
	private Model executeDelete(ParsedCommand userCommand) {

		if (!Delete.checkValid(userCommand,model)) {
			return model;
		} else {
			Command command = new Delete(userCommand, storage, model);
			command.execute();
			commandHistory.addFirst(command);

			return model;
		}
	}

	/*
	 *	Method for executing Add.
	 */
	private Model executeAdd(ParsedCommand userCommand) {

		if (!Add.checkValid(userCommand, model)) {
			return model;

		} else {
			Command command = new Add(userCommand, storage, model);
			command.execute();
			commandHistory.addFirst(command);

			return model;
		}
	}

	/*
	 * Issues the next available ID. IDs take integer values and are not replaced when deleted.
	 */
	public static int getNewId() {
		Storage storage = new Storage();
		List<Task> taskList = storage.getAllTasks();
		if (taskList.size() == 0) {
			return 1;
		} else {
			return taskList.get(taskList.size() - 1).getId() + 1;
		}
	}

	/*
	 * Checks if the ID specified is a currently assigned ID.
	 */
	public static boolean checkID(int id) {
		Storage storage = new Storage();
		List<Task> taskList = storage.getAllTasks();
		boolean isFound = false;
		if (id >= getNewId() || id < 1){
			return false;
		}
		for (Task task : taskList) {
			if (task.getId() == id) {
				isFound = true;
			}
		}
		return isFound;
	}

	private static boolean checkIfEmptyCommand(ParsedCommand parsedCommand) {
		return parsedCommand == null;
	}

	/*
	 *	Searches the taskList and finds the task specified.
	 *	@param taskList The task list to search in.
	 *	@param taskId	The id of the task to find.
	 * 	@return task specified
	 */
	public static Task searchList(List<Task> taskList, int taskId) throws IndexOutOfBoundsException {
		for (int i = 0; i < taskList.size(); i++) {
			if (taskList.get(i).getId() == taskId) {
				return taskList.get(i);
			}
		}
		return null;
	}

	/*
	 *	Searches for all tasks from now to the end of the day. Returns the results in a List.
	 *	Results are sorted by date with the earliest tasks appearing first while the later tasks
	 *	appearing later.
	 *
	 *	@returns List<Task> returns the updated today List.
	 */
	public static List<Task> updateTodayList() {
		try {
			Storage storage = new Storage();
			Calendar fromCal = Calendar.getInstance();

			Calendar toCal = Calendar.getInstance();
			toCal.set(Calendar.HOUR_OF_DAY, TODAY_LAST_HOUR);
			toCal.set(Calendar.MINUTE, TODAY_LAST_MINUTE);
			toCal.set(Calendar.SECOND, TODAY_LAST_SECOND);

			List<Task> todayList = Search.searchDate(storage.getAllTasks(), fromCal, toCal);
			Collections.sort(todayList,Task.compareByDate);

			return todayList;
		} catch (ParseException e) {
			logger.log(Level.WARNING, "update TodayList failed", e);
			e.printStackTrace();
			return null;
		} catch (IOException e) {
			logger.log(Level.WARNING, "update TodayList failed", e);
			e.printStackTrace();
			return null;
		}
	}

	/*
	 *	Searches for all tasks that are due from today onwards. Returns the results in a List.
	 *	Returns the results in a List. Results are sorted by date with the earliest tasks appearing
	 *	first while the later tasks	appearing later.
	 *
	 *	@return List<Task> returns the updated Main List.
	 */
	public static List<Task> updateMainList() {
		try {
			Storage storage = new Storage();
			Calendar fromCal = Calendar.getInstance();
			Calendar toCal = Calendar.getInstance();
			toCal.setTime(new Date(Long.MAX_VALUE));

			List<Task> mainList = Search.searchDate(storage.getAllTasks(), fromCal, toCal);
			Collections.sort(mainList,Task.compareByDate);

			return mainList;

		} catch (ParseException e) {
			logger.log(Level.WARNING, "update main List failed", e);
			e.printStackTrace();
			return null;
		} catch (IOException e) {
			logger.log(Level.WARNING, "update main List failed", e);
			e.printStackTrace();
			return null;
		}
	}

	/*
	 *	Searches for all floating tasks. Results are returned in a List.
	 *	@returns List<Task> returns the updated floating List.
	 */
	public static List<Task> updateFloatingList() {
		try {
			Storage storage = new Storage();

			return Search.search(storage.getAllTasks(), FLOATING_TASKS);

		} catch (ParseException e) {
			logger.log(Level.WARNING, "update floating list failed", e);
			e.printStackTrace();
			return null;
		} catch (IOException e) {
			logger.log(Level.WARNING, "update floating list failed", e);
			e.printStackTrace();
			return null;
		}
	}

	/*
	 *	Searches for all Overdue tasks. Results are returned in a List.
	 *	Results are sorted by date with the earliest tasks appearing
	 *	first while the later tasks	appearing later.
	 *
	 *	@return List<Task> returns the updated Overdue List.
	 */
	public static List<Task> updateOverdueList() {
		try {

			Storage storage = new Storage();
			Calendar toCal = Calendar.getInstance();

			Calendar fromCal = Calendar.getInstance();
			fromCal.setTime(new Date(0));

			List<Task> incompleteOverdue = Search.searchDate(storage.getAllTasks(), fromCal, toCal);
			List<Task> overdue = Search.search(incompleteOverdue, INCOMPLTETED_TASKS);
			Collections.sort(overdue,Task.compareByDate);

			return overdue;

		} catch (ParseException e) {
			logger.log(Level.WARNING, "update overdue List failed", e);
			e.printStackTrace();
			return null;
		} catch (IOException e) {
			logger.log(Level.WARNING, "update overdue List failed", e);
			e.printStackTrace();
			return null;
		}
	}
}
```
###### logic\Model.java
``` java
public class Model {

	public static final int DEFAULT_FOCUS = 1;
	private String consoleMessage;
	private List<Task> searchList;
	private List<Task> todayList;
	private List<Task> allTasks;
	private List<Task> mainList;
	private List<Task> floatingList;
	private List<Task> overdueList;
	private int focusId;
	private String avatarLocation;
	private ParsedCommand searchQuery;
	
	private Storage storage;

	/*
	 *	Constuctor used for testing
	 */
	public Model() {

	}

	public Model(Storage storage) {
		this.storage = storage;
		this.consoleMessage = "";
		this.focusId = DEFAULT_FOCUS;
		this.searchList = new ArrayList<Task>();
		this.todayList = Logic.updateTodayList();
		this.mainList = Logic.updateMainList();
		this.allTasks = storage.getAllTasks();
		avatarLocation = storage.getAvatarPath();
	}

	public String getAvatarLocation() {
		return avatarLocation;
	}

	public void setAvatarLocation(String newLocation) {
		avatarLocation = newLocation;
	}

	public String getConsoleMessage() {
		return consoleMessage;
	}
	
	public List<Task> getTodayList() {
		return todayList;
	}
	
	public List<Task> getMainList() {
		return mainList;
	}
	
	public List<Task> getSearchList() {
		return searchList;
	}

	public List<Task> getAllTasks() {
		return allTasks;
	}

	public List<Task> getFloatingList() { return floatingList; }

	public List<Task> getOverdueList() { return overdueList; }

	public int getFocusId() { return focusId; }

	/*
	 *	Updates the searchQuery so that Model can automatically refresh the searchList through
	 * 	future user commands.
	 */
	public void updateSearch(String consoleMessage, ParsedCommand searchQuery, List<Task> searchList) {
		this.consoleMessage = consoleMessage;
		this.searchQuery = searchQuery;
		this.searchList = searchList;
	}

	/*
	 *	Method to automate updating the searchList whenever updateModel is called.
	 */
	public void updateSearchList() {
		try {
			Search search = new Search();
			this.searchList = search.multiSearch(storage.getAllTasks(), searchQuery);
		} catch (ParseException e) {
			consoleMessage = "Error: Search ParseException";
		} catch (IOException e) {
			consoleMessage = "Error: Search IOException";
		}
	}

	/*
	 *	Updates all possible fields in the Model and assigns the new message as the consoleMessage.
	 */
	public void updateModel(String consoleMessage) {
		this.consoleMessage = consoleMessage;
		updateModel();
	}

	/*
	 *	Updates all possible fields in the Model and assigns the new message as the consoleMessage
	 * 	as well as the new task id as the focusId.
	 */
	public void updateModel(String consoleMessage,int focusId) {
		this.consoleMessage = consoleMessage;
		updateModel();
		this.focusId = focusId;
	}

	/*
	 *	Updates all of : allTask, mainList, todayList, floatingList, overdueList and searchList if possible.
	 */
	public void updateModel() {
		this.allTasks = storage.getAllTasks();
		this.mainList = Logic.updateMainList();
		this.todayList = Logic.updateTodayList();
		this.floatingList = Logic.updateFloatingList();
		this.overdueList = Logic.updateOverdueList();
		if (searchQuery != null) {
			updateSearchList();
		}
	}

	/*
	 *	Sets a particular task as the focus for the focus view.
	 */
	public void updateFocus(int focusId) {
		this.focusId = focusId;
	}


	/*
	 *	Sets the consoleMessage to the new message without updating the view.
	 */
	public void setConsoleMessage(String consoleMessage) {
		this.consoleMessage = consoleMessage;
	}
}
```
###### logic\Search.java
``` java
public class Search {
	private static final TaskType TASK = TaskType.FLOATING_TASK;
	private static final TaskType DEADLINETASK = TaskType.DEADLINE_TASK;
	private static final TaskType EVENT = TaskType.EVENT;

	@SuppressWarnings("deprecation")
	public List<Task> multiSearch(List<Task> taskList, ParsedCommand toSearch) throws IOException, ParseException{
		StandardAnalyzer analyzer = new StandardAnalyzer();
		Directory index = indexTaskList(taskList,analyzer);
		BooleanQuery bQuery = new BooleanQuery();

		if (toSearch.getKeywords() != null && !toSearch.getKeywords().isEmpty()) {
			String titleQuery = toSearch.getKeywords();

			Query title = createQuery(analyzer, titleQuery);
			bQuery.add(title, BooleanClause.Occur.SHOULD);

			try {
				String descriptionQuery = "details: " + toSearch.getKeywords();
				Query description = createQuery(analyzer, descriptionQuery);
				bQuery.add(description, BooleanClause.Occur.SHOULD);
			} catch (ParseException e) {
				// Search has a string value that parser does not accept, skip
			}

		}

		if (toSearch.getFirstDate() != null && toSearch.getSecondDate() != null) {
			TermRangeQuery dates = createDateQuery(analyzer,toSearch.getFirstDate(),toSearch.getSecondDate(),"end");
			bQuery.add(dates, BooleanClause.Occur.SHOULD);
			dates = createDateQuery(analyzer,toSearch.getFirstDate(),toSearch.getSecondDate(),"start");
			bQuery.add(dates, BooleanClause.Occur.SHOULD);
		}
		if (toSearch.getTaskId() >= 0) {
			String idQuery = "id: " + toSearch.getTaskId();
			Query isComplete = createQuery(analyzer, idQuery);
			bQuery.add(isComplete, BooleanClause.Occur.MUST);
		}
		if (toSearch.getTags() != null && toSearch.getTags().size() != 0) {
			String tagQuery = "tags: ";
			for (String tag : toSearch.getTags()) {
				tagQuery += tag + " ";
			}
			Query tags = createQuery(analyzer, tagQuery);
			bQuery.add(tags, BooleanClause.Occur.MUST);
		}
		if (toSearch.isCompleted() != null) {
			String isCompleteQuery = "isCompleted: " + toSearch.isCompleted();
			Query isComplete = createQuery(analyzer, isCompleteQuery);
			bQuery.add(isComplete, BooleanClause.Occur.MUST);
		}
		if (toSearch.getTaskType() != null) {
			String typeQuery = "taskType: " + toSearch.getTaskType();
			Query type = createQuery(analyzer, typeQuery);
			bQuery.add(type, BooleanClause.Occur.MUST);
		}


		return queryIndex(index, bQuery);
	}

	/*
	 * Search function. Uses the Lucene Library to search through all the fields of a task. Only
	 * searches through 1 task at a time so range searches are not within the scope of this function.
	 */
	public static List<Task> search(List<Task> taskList, String query) throws IOException, ParseException{
		StandardAnalyzer analyzer = new StandardAnalyzer();
		Directory index = indexTaskList(taskList,analyzer);

	    String querystr = query;
	    Query q = new QueryParser("name", analyzer).parse(querystr);	// Searches through the 'name' field by default
	    																// if no field explicitly specified.
	    ArrayList<Task> hitList = queryIndex(index, q);

		return hitList;
	}

	private Query createQuery(StandardAnalyzer analyzer, String querystr) throws ParseException {
		Query q = new QueryParser("name", analyzer).parse(querystr);
		return q;
	}

	/*
	 * Searches the index list using the search query provided. Stores the results in an ArrayList and returns that list.
	 */
	private static ArrayList<Task> queryIndex(Directory index, Query q)
			throws IOException {
		// Search
	    int hitsPerPage = 1000;
	    IndexReader reader = DirectoryReader.open(index);
	    IndexSearcher searcher = new IndexSearcher(reader);
	    TopScoreDocCollector collector = TopScoreDocCollector.create(hitsPerPage);
	    searcher.search(q, collector);
	    ScoreDoc[] hits = collector.topDocs().scoreDocs;
	    
	    // Store results
	    ArrayList<Task> hitList = new ArrayList<Task>();
	    Gson gson = new Gson();
	    for(int i=0;i<hits.length;++i) {
	        int docId = hits[i].doc;
	        Document d = searcher.doc(docId);
	        
	        Task task = gson.fromJson(d.get("json"),Task.class);
	        if (task.getTaskType() == TASK) {
	        	hitList.add(gson.fromJson(d.get("json"),Task.class));
	        } else if (task.getTaskType() == DEADLINETASK) {
	        	hitList.add(gson.fromJson(d.get("json"),DeadlineTask.class));
	        } else if (task.getTaskType() == EVENT) {
	        	hitList.add(gson.fromJson(d.get("json"),Event.class));
	        }
	    }
		return hitList;
	}

	
	/*
	 * A search involving fields with dates
	 */
	public static List<Task> searchDate(List<Task> taskList, Calendar fromDate, Calendar toDate) throws IOException, ParseException{
		
		// Create indexes with taskList
		StandardAnalyzer analyzer = new StandardAnalyzer();
	    Directory index = indexTaskList(taskList,analyzer);
	    
	    // Set up Query
		String sFromDate = DateTools.dateToString(fromDate.getTime(),
		        Resolution.SECOND);
		String sToDate = DateTools.dateToString(toDate.getTime(),
		        Resolution.SECOND);
		
	    TermRangeQuery rq = TermRangeQuery.newStringRange("end" ,sFromDate,sToDate,true,true);
	    
	    ArrayList<Task> hitList = queryIndex(index, rq);

		return hitList;
	}

	private TermRangeQuery createDateQuery(StandardAnalyzer analyzer, Calendar fromDate, Calendar toDate,String field) {
		// Set up Query
		String sFromDate = DateTools.dateToString(fromDate.getTime(),
				Resolution.SECOND);

		String sToDate = DateTools.dateToString(toDate.getTime(),
				Resolution.SECOND);

		TermRangeQuery rq = TermRangeQuery.newStringRange(field ,sFromDate,sToDate,true,true);

		return rq;
	}

	/*
	 * Indexes the taskList specified for Lucene to do its search with
	 */
	private static Directory indexTaskList(List<Task> taskList,StandardAnalyzer analyzer)
			throws IOException {
	    Directory index = new RAMDirectory();
	    IndexWriterConfig config = new IndexWriterConfig(analyzer);
	    IndexWriter w = new IndexWriter(index, config);
	    
	    for (Task task : taskList) {
	    	addDoc(w,task);
	    }
	    w.close();
		return index;
	}
	
	/*
	 * Specific index Writer for tasks/DeadlineTasks/Events
	 */
	  private static void addDoc(IndexWriter w, Task task) throws IOException {
		    Document doc = new Document();
		    Gson gson = new Gson();
		    String jsonString = gson.toJson(task);

		  if(task.getTaskType().equals(ParsedCommand.TaskType.DEADLINE_TASK)) {
			  DeadlineTask dlTask = (DeadlineTask) task;
			  doc.add(new TextField("end", DateTools.dateToString(dlTask.getEnd().getTime(), DateTools.Resolution.SECOND), Field.Store.YES));
		  } else if(task.getTaskType().equals(ParsedCommand.TaskType.EVENT)) {
			  Event event = (Event) task;
			  doc.add(new TextField("start", DateTools.dateToString(event.getStart().getTime(), DateTools.Resolution.SECOND), Field.Store.YES));
			  doc.add(new TextField("end", DateTools.dateToString(event.getEnd().getTime(), DateTools.Resolution.SECOND), Field.Store.YES));
		  }
		    doc.add(new TextField("name", task.getName(), Field.Store.YES));
		    doc.add(new TextField("id",new Integer(task.getId()).toString(), Field.Store.YES));
		    doc.add(new TextField("isCompleted",new Boolean(task.getIsCompleted()).toString(), Field.Store.YES));
		    String tagString = "";
		  	if (task.getTags() != null) {
				for (String tags : task.getTags()) {
					tagString = tagString + tags + " ";
				}
			}
		    doc.add(new TextField("tags",tagString, Field.Store.YES));
		    doc.add(new TextField("taskType",task.getTaskType().toString(), Field.Store.YES));
		    if (task.getDescription() != null) {
		    	doc.add(new TextField("details",task.getDescription(), Field.Store.YES));
		    }
		    
		    doc.add(new StringField("json",jsonString,Field.Store.YES));
		    w.addDocument(doc);
		  }
	
	
}
```
###### logic\Task.java
``` java
public class Task implements Comparable<Task> {

	public static final String FIELD_NAME = "Name";
	public static final String FIELD_ID = "ID";
	public static final String FIELD_DETAILS = "Details";
	public static final String FIELD_TAGS = "Tags";
	// Task Type Enums
	private static ParsedCommand.TaskType DEADLINE_TASK = ParsedCommand.TaskType.DEADLINE_TASK;
	private static ParsedCommand.TaskType EVENT = ParsedCommand.TaskType.EVENT;

	// Comparator constants
	public static final int LESSER = -1;
	public static final int GREATER = 1;
	public static final int NO_DATE = 999;

	// Class fields
	private String name;
	private String details;
	private int id;
	private boolean isCompleted;
	private ArrayList<String> tags;
	private ParsedCommand.TaskType taskType;

	public Task() {
		name = details = "";
		id = 0;
		isCompleted = false;
		tags = null;
	}

	public Task(String name, String details,int id,boolean isCompleted,ArrayList<String> tags,ParsedCommand.TaskType taskType) {
		setName(name);
		setDescription(details);
		setId(id);
		setIsCompleted(isCompleted);
		setTags(tags);
		setTaskType(taskType);
	}

	/*
	 *	Constructor for cloning a task
	 */
	public Task(Task newTask) {
		this.name = newTask.getName();
		this.details = newTask.getDescription();
		this.id = newTask.getId();
		this.isCompleted = newTask.getIsCompleted();
		this.tags = newTask.getTags();
		this.taskType = newTask.getTaskType();
	}

	public Task(ParsedCommand parsedInput) {
		this.name = parsedInput.getTitle();
		this.details = parsedInput.getDescription();
		this.id = parsedInput.getTaskId();
		this.isCompleted = false;
		this.tags = parsedInput.getTags();
		this.taskType = parsedInput.getTaskType();
	}

	/*
	 *	Returns all task fields in a String array format for displaying. The String array is formatted such that
	 *	array[0] contains the field name and array[1] contains the field data value. An ArrayList containing the
	 *	String array fields is returned.
	 *
	 *	@return an Arraylist of two field arrays(i.e. array[2]) containing the String data
	 *
	 */
	public ArrayList<String[]> getTaskDetails() {
		ArrayList<String[]> task = new ArrayList<String[]>();
		String[] array = new String[2];
		String tagList = "";

		array[0] = FIELD_NAME;
		array[1] = name;
		task.add(array);
		array = new String[2];
		array[0] = FIELD_ID;
		array[1] = "" + id;
		task.add(array);
		array = new String[2];
		array[0] = FIELD_DETAILS;
		array[1] = details;

		task.add(array);
		array = new String[2];
		array[0] = FIELD_TAGS;
		if(tags != null) {	
			for (int i = 0; i<tags.size(); i++) {
				tagList += "[" + tags.get(i) + "]";
			}
		}
		array[1] = tagList;
		task.add(array);

		return task;	
	}

	public String getName() {
		return name;
	}

	public String getDescription() {
		return details;
	}

	public int getId() {
		return id;
	}

	public boolean getIsCompleted() {
		return isCompleted;
	}

	public ArrayList<String> getTags() {
		return tags;
	}

	public ParsedCommand.TaskType getTaskType() {
		return taskType;
	}

	public void setName(String name) {
		this.name = name;
	}

	public void setDescription(String details) {
		this.details = details;
	}

	public void setId(int id) {
		this.id = id;
	}

	public void setIsCompleted(boolean isCompleted) {
		this.isCompleted = isCompleted;
	}

	public void setTags(ArrayList<String> tags) {
		this.tags = tags;
	}

	public void setTaskType(ParsedCommand.TaskType taskType) {
		this.taskType = taskType;
	}

	@Override
	public int compareTo(Task o) {
		return ((Integer)id).compareTo(o.getId());
	}


	/*
	 * 	Comparator to sort by date. Sorts by end date if Task is an event.
	 */
	public static final Comparator<Task> compareByDate = new Comparator<Task>() {

		@Override
		public int compare(Task task1, Task task2) {

			if(task1.getTaskType() == DEADLINE_TASK && task2.getTaskType() == DEADLINE_TASK) {
				DeadlineTask dlTask1 = (DeadlineTask) task1;
				DeadlineTask dlTask2 = (DeadlineTask) task2;

				if (dlTask1.getEnd().before(dlTask2.getEnd())) {
					return LESSER;
				} else {
					return GREATER;
				}
			} else if (task1.getTaskType() == EVENT && task2.getTaskType() == EVENT) {
				Event event1 = (Event) task1;
				Event event2 = (Event) task2;

				if (event1.getEnd().before(event2.getEnd())) {
					return LESSER;
				} else {
					return GREATER;
				}
			} else if (task1.getTaskType() == EVENT && task2.getTaskType() == DEADLINE_TASK) {
				Event event1 = (Event) task1;
				DeadlineTask dlTask2 = (DeadlineTask) task2;

				if (event1.getEnd().before(dlTask2.getEnd())) {
					return LESSER;
				} else {
					return GREATER;
				}
			} else if (task1.getTaskType() == DEADLINE_TASK && task2.getTaskType() == EVENT) {
				DeadlineTask dlTask1 = (DeadlineTask) task1;
				Event event2 = (Event) task2;

				if (dlTask1.getEnd().before(event2.getEnd())) {
					return LESSER;
				} else {
					return GREATER;
				}
			} else {
				return NO_DATE;
			}
		}
	};

}
```
###### logic\Update.java
``` java
public class Update implements Command {

	private static final TaskType TASK = TaskType.FLOATING_TASK;
	private static final TaskType DEADLINETASK = TaskType.DEADLINE_TASK;
	private static final TaskType EVENT = TaskType.EVENT;

	public static final String MESSAGE_UPDATED = "%1$s updated";

	private ParsedCommand specifications;
	private Task toUpdate;
	private Task updated;
	private Storage storage;
	private Model model;

	public Update() {

	}

	public Update(ParsedCommand specifications,Storage storage,Model model) {
		this.specifications = specifications;
		this.storage = storage;
		this.model = model;
	}

	public void execute() {
		List<Task> taskList = storage.getAllTasks();
		toUpdate = Logic.searchList(taskList, specifications.getTaskId());
		// Clone Task
		if (toUpdate.getTaskType() == TASK) {
			updated = new Task(toUpdate);
			updated = updateTask(specifications, updated);
		} else if (toUpdate.getTaskType() == DEADLINETASK) {
			DeadlineTask newTask = new DeadlineTask((DeadlineTask)toUpdate);
			updated = newTask;
			updated = updateTask(specifications, updated);
		} else if (toUpdate.getTaskType() == EVENT) {
			Event newTask = new Event((Event)toUpdate);
			updated = newTask;
			updated = updateTask(specifications, updated);
		}
		
		storage.delete(toUpdate.getId());
		storage.add(updated);
		model.updateModel(String.format(MESSAGE_UPDATED, toUpdate.getName()),updated.getId());
	}

	public void undo() {
		storage.delete(updated.getId());
		storage.add(toUpdate);
		storage.sort();
		model.updateFocus(toUpdate.getId());
	}

	/*
	 * Returns a Task Object with all the specified fields updated. Does not add
	 * anything to database.
	 */
	public Task updateTask(ParsedCommand parsedInput, Task toUpdate) {
		String title = parsedInput.getTitle();
		String description = parsedInput.getDescription();
		ArrayList<String> tags = parsedInput.getTags();
		Boolean isCompleted = parsedInput.isCompleted();
		Calendar firstDate = parsedInput.getFirstDate();
		Calendar secondDate = parsedInput.getSecondDate();

		return updateTask(title,description,tags,isCompleted,firstDate,secondDate, toUpdate);
	}

	/*
	 * Returns a Task Object with all the specified fields updated. Does not add
	 * anything to database.
	 */
	public Task updateTask(String title,String description,ArrayList<String> tags,Boolean isCompleted,Calendar firstDate,Calendar secondDate, Task toUpdate) {

		if (title != null && !title.isEmpty()) {
			toUpdate.setName(title);
		}
		if (description != null && !description.isEmpty()) {
			toUpdate.setDescription(description);
		}
		if (tags != null && tags.size() != 0) {
			toUpdate.setTags(tags);
		}
		if (isCompleted != null) {
			toUpdate.setIsCompleted(isCompleted);
		}
		if (firstDate != null && secondDate == null) {
			if (toUpdate.getTaskType() == TASK) {
				toUpdate = new DeadlineTask(toUpdate,firstDate);	// Convert from task to DeadlineTask
			} else if (toUpdate.getTaskType() == DEADLINETASK) {
				((DeadlineTask) toUpdate).setEnd(firstDate);
			} else if (toUpdate.getTaskType() == EVENT) {
				toUpdate = new DeadlineTask(toUpdate,firstDate);	// Convert from Event to DealineTask
			}

		} else if (firstDate != null && secondDate != null) {

			if (toUpdate.getTaskType() == TASK || toUpdate.getTaskType() == DEADLINETASK) {
				toUpdate = new Event(toUpdate,firstDate,secondDate);	// Convert to Event
			} else if (toUpdate.getTaskType() == EVENT) {
				((Event) toUpdate).setStart(firstDate);
				((Event) toUpdate).setEnd(secondDate);
			}
		}

		return toUpdate;
	}

	/*
	 *	Checks if the parsedInput is valid for the execute method and updates the view with
	 * 	the corresponding error message
	 */
	public static boolean checkValid(ParsedCommand parsedInput, Model view) {

		if (!Logic.checkID(parsedInput.getTaskId())) {
			view.setConsoleMessage(Logic.ERROR_INVALID_ID);
			return false;
		}

		return true;
	}

}
```
###### test\AddTest.java
``` java
public class AddTest {


    @Before
    public void initialize() {
        File dataFile = new File("Data.txt");
        dataFile.renameTo(new File("temp.txt"));
        File testFile = new File("Test_Data2.txt");
        testFile.renameTo(new File("Data.txt"));

    }

    @After
    public void reset() {
        File dataFile = new File("Data.txt");
        dataFile.renameTo(new File("Test_Data2.txt"));
        File testFile = new File("temp.txt");
        testFile.renameTo(new File("Data.txt"));
    }


    @Test
    public void testExecute() throws Exception {
        Storage storage = new Storage();
        Model model = new Model(storage);
        Model correct = new Model(storage);

        // Test add task
        ParsedCommand specifications = MyParser.parseCommand("add test task");

        Add add = new Add(specifications,storage,model);
        add.execute();
        correct.setConsoleMessage("test task added");

        boolean result = consoleMessageChecker(correct,model);
        assertEquals(true,result);

        add.undo();
        result = storage.getAllTasks().size() == 0;

        assertEquals(true,result);


        // Test add task with description
        specifications = MyParser.parseCommand("add test task \"description test\" ");

        add = new Add(specifications,storage,model);
        add.execute();
        correct.setConsoleMessage("test task added");

        result = consoleMessageChecker(correct,model);
        assertEquals(true,result);

        add.undo();
        result = storage.getAllTasks().size() == 0;

        assertEquals(true,result);


        // Test add task with tags
         specifications = MyParser.parseCommand("add test task #CheckTags");

         add = new Add(specifications,storage,model);
        add.execute();
        correct.setConsoleMessage("test task added");

         result = consoleMessageChecker(correct,model);
        assertEquals(true,result);

        add.undo();
        result = storage.getAllTasks().size() == 0;

        assertEquals(true,result);


        // Test add DeadlineTask
        specifications = MyParser.parseCommand("add test deadlinetask 20 november 1990");

        add = new Add(specifications,storage,model);
        add.execute();
        correct.setConsoleMessage("test deadlinetask added");

        result = consoleMessageChecker(correct, model);
        assertEquals(true,result);

        add.undo();
        result = storage.getAllTasks().size() == 0;
        assertEquals(true,result);

        // Test add task with description
        specifications = MyParser.parseCommand("add test deadlinetask 20 november 1990 \"description test\"  ");

        add = new Add(specifications,storage,model);
        add.execute();
        correct.setConsoleMessage("test deadlinetask added");

        result = consoleMessageChecker(correct,model);
        assertEquals(true,result);

        add.undo();
        result = storage.getAllTasks().size() == 0;

        assertEquals(true,result);

        // Test add Event
        specifications = MyParser.parseCommand("add test event 20 november 1990 to 20 december 1990");

        add = new Add(specifications,storage,model);
        add.execute();
        correct.setConsoleMessage("test event added");

        add.undo();
        result = storage.getAllTasks().size() == 0;
        assertEquals(true, result);

        // Test add Event with description
        specifications = MyParser.parseCommand("add test event 20 november 1990 to 20 december 1990 \"test description\"");

        add = new Add(specifications,storage,model);
        add.execute();
        correct.setConsoleMessage("test event added");

        add.undo();
        result = storage.getAllTasks().size() == 0;
        assertEquals(true, result);
    }

    @Test
    public void testUndo() throws Exception {
        Storage storage = new Storage();
        Model model = new Model(storage);
        Model correct = new Model(storage);
        // Test undo task
        ParsedCommand specifications = MyParser.parseCommand("add test undo");

        Add add = new Add(specifications,storage,model);
        add.execute();
        correct.setConsoleMessage("test undo added");

        boolean result = consoleMessageChecker(correct, model);
        assertEquals(true,result);

        add.undo();
        result = storage.getAllTasks().size() == 0;
        assertEquals(true,result);

        // Test undo DeadlineTask
        specifications = MyParser.parseCommand("add test deadlinetask 15 november 3001");

        add = new Add(specifications,storage,model);
        add.execute();
        correct.setConsoleMessage("test deadlinetask added");

        result = consoleMessageChecker(correct,model);
        assertEquals(true,result);

        add.undo();
        result = storage.getAllTasks().size() == 0;
        assertEquals(true,result);

        // Test undo Event
        specifications = MyParser.parseCommand("add test event 1 november 3000 to 30 december 3000");

        add = new Add(specifications,storage,model);
        add.execute();
        correct.setConsoleMessage("test event added");

        result = consoleMessageChecker(correct,model);
        assertEquals(true,result);

        add.undo();
        result = storage.getAllTasks().size() == 0;
        assertEquals(true,result);
    }

    public static boolean consoleMessageChecker(Model model1, Model model2) {
        if (!model1.getConsoleMessage().equals(model2.getConsoleMessage())) {
            System.out.println("ConsoleMessage different");
            return false;
        }
        return true;
    }

}
```
###### test\LogicTest.java
``` java
public class LogicTest {

    @Before
    public void initialize() {
        File dataFile = new File("Data.txt");
        dataFile.renameTo(new File("temp.txt"));
        File testFile = new File("Test_Data2.txt");
        testFile.renameTo(new File("Data.txt"));
    }

    @Test
    public void testExecuteCommand() throws Exception {
        Storage storage = new Storage();
        Model correct = new Model(storage);
        Logic logic = new Logic(storage);
        Model executed;
        boolean result;

        // test empty command
        executed = logic.executeCommand(null);
        correct.updateModel(Logic.MESSAGE_INVALID_FORMAT);
        result = modelChecker(correct, executed);
        assertEquals(true, result);

        // test add Task
        ParsedCommand command = MyParser.parseCommand("add task");
        executed = logic.executeCommand(command);
        correct.updateModel("task added");
        result = modelChecker(correct,executed);
        assertEquals(true,result);

        System.out.println(storage.getAllTasks().size());

        // test add DeadlineTask
        command = MyParser.parseCommand("add DeadlineTask 27/5/2000");
        logic.executeCommand(command);
        correct.updateModel("DeadlineTask added");
        result = modelChecker(correct,executed);
        assertEquals(true,result);

        // test add Event
        command = MyParser.parseCommand("add Event 27/5/2000 28/5/2000");
        logic.executeCommand(command);
        correct.updateModel("Event added");
        result = modelChecker(correct,executed);
        assertEquals(true,result);

        // test delete valid
        command = MyParser.parseCommand("delete 1");
        logic.executeCommand(command);
        correct.updateModel("Task 1 deleted");
        result = modelChecker(correct,executed);
        assertEquals(true,result);

        // test delete invalid
        command = MyParser.parseCommand("delete 500");
        logic.executeCommand(command);
        correct.updateModel(Logic.ERROR_INVALID_ID);
        result = modelChecker(correct,executed);
        assertEquals(true,result);

        // test update invalid
        command = MyParser.parseCommand("Edit 500 New name ");
        logic.executeCommand(command);
        correct.updateModel(Logic.ERROR_INVALID_ID);
        result = modelChecker(correct,executed);
        assertEquals(true,result);

        // test update valid
        command = MyParser.parseCommand("Edit 1 new name");
        logic.executeCommand(command);
        correct.updateModel(Logic.ERROR_INVALID_ID);
        result = modelChecker(correct,executed);
        assertEquals(true,result);

        // test flag done Task
        command = MyParser.parseCommand("flag done 2");
        logic.executeCommand(command);
        correct.updateModel("DeadlineTask updated");
        result = modelChecker(correct,executed);
        assertEquals(true,result);

        // test flag done invalid task
        command = MyParser.parseCommand("flag done 500");
        logic.executeCommand(command);
        correct.updateModel(Logic.ERROR_INVALID_ID);
        result = modelChecker(correct,executed);
        assertEquals(true,result);

        // test flag to do Task
        command = MyParser.parseCommand("flag todo 2");
        logic.executeCommand(command);
        correct.updateModel("DeadlineTask updated");
        result = modelChecker(correct,executed);
        assertEquals(true,result);

        // test flag to do invalid task
        command = MyParser.parseCommand("flag todo 500");
        logic.executeCommand(command);
        correct.updateModel(Logic.ERROR_INVALID_ID);
        result = modelChecker(correct,executed);
        assertEquals(true,result);

        // test invalid command
        command = MyParser.parseCommand("this is an invalid command");
        logic.executeCommand(command);
        correct.updateModel(command.getErrorMessage());
        result = modelChecker(correct,executed);
        assertEquals(true,result);

        // test search
        command = MyParser.parseCommand("search pikachu");
        logic.executeCommand(command);
        correct.updateModel(Logic.MESSAGE_NO_RESULTS_FOUND);
        result = modelChecker(correct,executed);
        assertEquals(true,result);

        // test display
        command = MyParser.parseCommand("show 2");
        logic.executeCommand(command);
        Search search = new Search();
        correct.updateSearch(Logic.MESSAGE_1_RESULT_FOUND, command, search.multiSearch(storage.getAllTasks(), command));
        result = modelChecker(correct,executed);
        assertEquals(true,result);

//        // test set folder
//        command = MyParser.parseCommand("set folder /");
//        logic.executeCommand(command);
//        result = modelChecker(correct,executed);
//        assertEquals(true,result);

//        // test set avatar
//        command = MyParser.parseCommand("set avatar avatar.jpg");
//        logic.executeCommand(command);
//        correct.updateModel("Avatar switched");
//        result = modelChecker(correct,executed);
//        assertEquals(true,result);

        // test undo
        command = MyParser.parseCommand("undo number 1");
        logic.executeCommand(command);
        correct.updateModel(Logic.MESSAGE_UNDO_SUCCESSFUL);
        result = modelChecker(correct,executed);
        assertEquals(true,result);

        command = MyParser.parseCommand("undo number 2");
        logic.executeCommand(command);
        correct.updateModel(Logic.MESSAGE_UNDO_SUCCESSFUL);
        result = modelChecker(correct,executed);
        assertEquals(true,result);

        command = MyParser.parseCommand("undo number 3");
        logic.executeCommand(command);
        correct.updateModel(Logic.MESSAGE_UNDO_SUCCESSFUL);
        result = modelChecker(correct,executed);
        assertEquals(true,result);

        command = MyParser.parseCommand("undo number 4");
        logic.executeCommand(command);
        correct.updateModel(Logic.MESSAGE_UNDO_SUCCESSFUL);
        result = modelChecker(correct,executed);
        assertEquals(true,result);

        command = MyParser.parseCommand("undo number 5");
        logic.executeCommand(command);
        correct.updateModel(Logic.MESSAGE_UNDO_SUCCESSFUL);
        result = modelChecker(correct,executed);
        assertEquals(true,result);

        command = MyParser.parseCommand("undo number 6");
        logic.executeCommand(command);
        correct.updateModel(Logic.MESSAGE_UNDO_SUCCESSFUL);
        result = modelChecker(correct,executed);
        assertEquals(true,result);

        // Test nothing to undo
        command = MyParser.parseCommand("undo number 7");
        logic.executeCommand(command);
        correct.updateModel(Logic.MESSAGE_NOTHING_TO_UNDO);
        result = modelChecker(correct,executed);
        assertEquals(true,result);



        // test redo
        command = MyParser.parseCommand("redo number 1");
        logic.executeCommand(command);
        correct.updateModel(Logic.MESSAGE_REDO_SUCCESSFUL);
        result = modelChecker(correct,executed);
        assertEquals(true,result);

        command = MyParser.parseCommand("redo number 2");
        logic.executeCommand(command);
        correct.updateModel(Logic.MESSAGE_REDO_SUCCESSFUL);
        result = modelChecker(correct,executed);
        assertEquals(true,result);

        command = MyParser.parseCommand("redo number 3");
        logic.executeCommand(command);
        correct.updateModel(Logic.MESSAGE_REDO_SUCCESSFUL);
        result = modelChecker(correct,executed);
        assertEquals(true,result);

        command = MyParser.parseCommand("redo number 4");
        logic.executeCommand(command);
        correct.updateModel(Logic.MESSAGE_REDO_SUCCESSFUL);
        result = modelChecker(correct,executed);
        assertEquals(true,result);

        command = MyParser.parseCommand("redo number 5");
        logic.executeCommand(command);
        correct.updateModel(Logic.MESSAGE_REDO_SUCCESSFUL);
        result = modelChecker(correct,executed);
        assertEquals(true,result);

        command = MyParser.parseCommand("redo number 6");
        logic.executeCommand(command);
        correct.updateModel(Logic.MESSAGE_REDO_SUCCESSFUL);
        result = modelChecker(correct,executed);
        assertEquals(true,result);

        // Test nothing to redo
        command = MyParser.parseCommand("redo number 7");
        logic.executeCommand(command);
        correct.updateModel(Logic.MESSAGE_NOTHING_TO_REDO);
        result = modelChecker(correct,executed);
        assertEquals(true,result);

        // test undo
        command = MyParser.parseCommand("undo number 1");
        logic.executeCommand(command);
        correct.updateModel(Logic.MESSAGE_UNDO_SUCCESSFUL);
        result = modelChecker(correct,executed);
        assertEquals(true,result);

        command = MyParser.parseCommand("undo number 2");
        logic.executeCommand(command);
        correct.updateModel(Logic.MESSAGE_UNDO_SUCCESSFUL);
        result = modelChecker(correct,executed);
        assertEquals(true,result);

        command = MyParser.parseCommand("undo number 3");
        logic.executeCommand(command);
        correct.updateModel(Logic.MESSAGE_UNDO_SUCCESSFUL);
        result = modelChecker(correct,executed);
        assertEquals(true,result);

        command = MyParser.parseCommand("undo number 4");
        logic.executeCommand(command);
        correct.updateModel(Logic.MESSAGE_UNDO_SUCCESSFUL);
        result = modelChecker(correct,executed);
        assertEquals(true,result);

        command = MyParser.parseCommand("undo number 5");
        logic.executeCommand(command);
        correct.updateModel(Logic.MESSAGE_UNDO_SUCCESSFUL);
        result = modelChecker(correct,executed);
        assertEquals(true,result);

        command = MyParser.parseCommand("undo number 6");
        logic.executeCommand(command);
        correct.updateModel(Logic.MESSAGE_UNDO_SUCCESSFUL);
        result = modelChecker(correct,executed);
        assertEquals(true,result);

        // Test nothing to undo
        command = MyParser.parseCommand("undo number 7");
        logic.executeCommand(command);
        correct.updateModel(Logic.MESSAGE_NOTHING_TO_UNDO);
        result = modelChecker(correct,executed);
        assertEquals(true,result);
    }

    @Test
    public void testCheckID() throws Exception {
        Logic logic = new Logic();
        ParsedCommand command = MyParser.parseCommand("add task");
        logic.executeCommand(command);
        logic.executeCommand(command);

        assertEquals(true,Logic.checkID(1));
        assertEquals(true,Logic.checkID(2));
        assertEquals(false,Logic.checkID(0));
        assertEquals(false,Logic.checkID(-1));
        assertEquals(false,Logic.checkID(500));

        command = MyParser.parseCommand("undo");
        logic.executeCommand(command);
        logic.executeCommand(command);
    }

    /*
     *  Compares two models and check if their fields are the same
     */
    public static boolean modelChecker(Model model1, Model model2) {
        boolean isSame = true;
        if (!model1.getConsoleMessage().equals(model2.getConsoleMessage())) {
            System.out.println("ConsoleMessage different");
            System.out.println(model1.getConsoleMessage());
            System.out.println(model2.getConsoleMessage());
            return false;
        }
        if (!model1.getAvatarLocation().equals(model2.getAvatarLocation())) {
            System.out.println("Avatar location different");
            return false;
        }
        if (model1.getAllTasks().size() != model2.getAllTasks().size()) {
            System.out.println("AlltasksList different");
            return false;
        } else {
            int i = 0;
            for(Task task : model1.getAllTasks()) {
                if (task.compareTo(model2.getAllTasks().get(i++)) != 0) {
                    System.out.println("AlltasksList different");
                    return false;
                }
            }
        }
        if (model1.getSearchList().size() != model2.getSearchList().size()) {
            System.out.println("searchList different");
            return false;
        } else {
            int i = 0;
            for(Task task : model1.getSearchList()) {
                if (task.compareTo(model2.getSearchList().get(i++)) != 0) {
                    System.out.println("searchList different");
                    return false;
                }
            }
        }
        if (model1.getFloatingList().size() != model2.getFloatingList().size()) {
            System.out.println("floatingList different");
            return false;
        } else {
            int i = 0;
            for(Task task : model1.getFloatingList()) {
                if (task.compareTo(model2.getFloatingList().get(i++)) != 0) {
                    System.out.println("floatingList different");
                    return false;
                }
            }
        }
        if (model1.getMainList().size() != model2.getMainList().size()) {
            System.out.println("mainList different");
            return false;
        } else {
            int i = 0;
            for(Task task : model1.getMainList()) {
                if (task.compareTo(model2.getMainList().get(i++)) != 0) {
                    System.out.println("mainList different");
                    return false;
                }
            }
        }
        if (model1.getTodayList().size() != model2.getTodayList().size()) {
            System.out.println("todayList different");
            return false;
        } else {
            int i = 0;
            for(Task task : model1.getTodayList()) {
                if (task.compareTo(model2.getTodayList().get(i++)) != 0) {
                    System.out.println("todayList different");
                    return false;
                }
            }
        }
        if (model1.getOverdueList().size() != model2.getOverdueList().size()) {
            System.out.println("overdueList different");
            return false;
        } else {
            int i = 0;
            for(Task task : model1.getOverdueList()) {
                if (task.compareTo(model2.getOverdueList().get(i++)) != 0) {
                    System.out.println("overdueList different");
                    return false;
                }
            }
        }

        return isSame;
    }

    @After
    public void reset() {
        File dataFile = new File("Data.txt");
        dataFile.renameTo(new File("Test_Data2.txt"));
        File testFile = new File("temp.txt");
        testFile.renameTo(new File("Data.txt"));
    }
}

```
###### test\SearchTest.java
``` java
public class SearchTest {


    @Before
    public void initialize() {
        File dataFile = new File("Data.txt");
        dataFile.renameTo(new File("temp.txt"));
        File testFile = new File("Test_Data.txt");
        testFile.renameTo(new File("Data.txt"));

    }

    @Test
    public void testMultiSearch() throws Exception {
        Search search = new Search();
        Storage storage = new Storage();
        // search for index
        ParsedCommand command = MyParser.parseCommand("search 9");
        List<Task> searchList = search.multiSearch(storage.getAllTasks(), command);

        ArrayList<Task> correctList = new ArrayList<Task>();
        correctList.add(new Task("Professor Oak Assignement 4",null,9,false,new ArrayList<String>(), ParsedCommand.TaskType.FLOATING_TASK));
        boolean result = listChecker(searchList, correctList);

        assertEquals(true, result);

        // search for keywords with multiple results
        command = MyParser.parseCommand("search brock");
        searchList = search.multiSearch(storage.getAllTasks(), command);

        correctList = new ArrayList<Task>();
        correctList.add(new Task("GYM battle with Brock",null,1,false,new ArrayList<String>(), ParsedCommand.TaskType.DEADLINE_TASK));
        correctList.add(new Task("lost Battle with brock 3",null,14,false,new ArrayList<String>(), ParsedCommand.TaskType.EVENT));
        result = listChecker(searchList, correctList);

        assertEquals(true,result);

        //search for keyword rocket + meeting
        command = MyParser.parseCommand("search rocket meeting");
        searchList = search.multiSearch(storage.getAllTasks(), command);

        correctList = new ArrayList<Task>();
        correctList.add(new Task("Feed Pikachu",null,5,false,new ArrayList<String>(), ParsedCommand.TaskType.FLOATING_TASK));
        correctList.add(new Task("Evolve Charizard",null,17,false,new ArrayList<String>(), ParsedCommand.TaskType.FLOATING_TASK));
        correctList.add(new Task("find thunderstone",null,18,false,new ArrayList<String>(), ParsedCommand.TaskType.FLOATING_TASK));
        correctList.add(new Task("find waterstone",null,21,false,new ArrayList<String>(), ParsedCommand.TaskType.FLOATING_TASK));
        correctList.add(new Task("find firestone",null,22,false,new ArrayList<String>(), ParsedCommand.TaskType.FLOATING_TASK));
        correctList.add(new Task("find firestone",null,23,false,new ArrayList<String>(), ParsedCommand.TaskType.FLOATING_TASK));
        correctList.add(new Task("find firestone",null,24,false,new ArrayList<String>(), ParsedCommand.TaskType.FLOATING_TASK));
        correctList.add(new Task("find firestone",null,25,false,new ArrayList<String>(), ParsedCommand.TaskType.FLOATING_TASK));
        correctList.add(new Task("find firestone",null,26,false,new ArrayList<String>(), ParsedCommand.TaskType.FLOATING_TASK));
        correctList.add(new Task("find firestone",null,27,false,new ArrayList<String>(), ParsedCommand.TaskType.FLOATING_TASK));
        result = listChecker(searchList, correctList);

        assertEquals(true,result);

        //search tags
        command = MyParser.parseCommand("search #gym");
        searchList = search.multiSearch(storage.getAllTasks(), command);
        correctList = new ArrayList<Task>();
        correctList.add(new Task("GYM battle with Brock",null,1,false,new ArrayList<String>(), ParsedCommand.TaskType.DEADLINE_TASK));
        result = listChecker(searchList, correctList);

        assertEquals(true,result);

        command = MyParser.parseCommand("search #worth #duck #doesnotexist #empty");
        searchList = search.multiSearch(storage.getAllTasks(), command);
        correctList = new ArrayList<Task>();
        result = listChecker(searchList, correctList);

        assertEquals(true,result);

        command = MyParser.parseCommand("search #lunch");
        searchList = search.multiSearch(storage.getAllTasks(), command);
        correctList = new ArrayList<Task>();
        correctList.add(new Task("Feed Pikachu",null,3,false,new ArrayList<String>(), ParsedCommand.TaskType.FLOATING_TASK));
        result = listChecker(searchList, correctList);

        assertEquals(true,result);

        // search task type
        command = MyParser.parseCommand("search event");
        searchList = search.multiSearch(storage.getAllTasks(), command);
        correctList = new ArrayList<Task>();
        correctList.add(new Task("Daily meeting with team Rocket",null,5,false,new ArrayList<String>(), ParsedCommand.TaskType.EVENT));
        correctList.add(new Task("lost Battle with brock 3",null,14,false,new ArrayList<String>(), ParsedCommand.TaskType.EVENT));
        result = listChecker(searchList, correctList);

        assertEquals(true,result);

        command = MyParser.parseCommand("search floating");
        searchList = search.multiSearch(storage.getAllTasks(), command);
        correctList = new ArrayList<Task>();
        correctList.add(new Task("Feed Pikachu",null,3,false,new ArrayList<String>(), ParsedCommand.TaskType.FLOATING_TASK));
        correctList.add(new Task("Evolve Charizard",null,4,false,new ArrayList<String>(), ParsedCommand.TaskType.FLOATING_TASK));
        correctList.add(new Task("find thunderstone",null,28,false,new ArrayList<String>(), ParsedCommand.TaskType.FLOATING_TASK));
        correctList.add(new Task("find waterstone",null,29,false,new ArrayList<String>(), ParsedCommand.TaskType.FLOATING_TASK));
        correctList.add(new Task("find firestone",null,30,false,new ArrayList<String>(), ParsedCommand.TaskType.FLOATING_TASK));

        result = listChecker(searchList, correctList);

        assertEquals(true,result);

        command = MyParser.parseCommand("search deadline");
        searchList = search.multiSearch(storage.getAllTasks(), command);
        correctList = new ArrayList<Task>();
        correctList.add(new Task("Feed Pikachu",null,1,false,new ArrayList<String>(), ParsedCommand.TaskType.FLOATING_TASK));
        correctList.add(new Task("Feed Pikachu",null,6,false,new ArrayList<String>(), ParsedCommand.TaskType.FLOATING_TASK));
        correctList.add(new Task("Feed Pikachu",null,7,false,new ArrayList<String>(), ParsedCommand.TaskType.FLOATING_TASK));
        correctList.add(new Task("Feed Pikachu",null,8,false,new ArrayList<String>(), ParsedCommand.TaskType.FLOATING_TASK));
        correctList.add(new Task("Feed Pikachu",null,9,false,new ArrayList<String>(), ParsedCommand.TaskType.FLOATING_TASK));
        correctList.add(new Task("Feed Pikachu",null,10,false,new ArrayList<String>(), ParsedCommand.TaskType.FLOATING_TASK));
        correctList.add(new Task("Feed Pikachu",null,15,false,new ArrayList<String>(), ParsedCommand.TaskType.FLOATING_TASK));
        correctList.add(new Task("Feed Pikachu",null,16,false,new ArrayList<String>(), ParsedCommand.TaskType.FLOATING_TASK));
        correctList.add(new Task("Feed Pikachu",null,17,false,new ArrayList<String>(), ParsedCommand.TaskType.FLOATING_TASK));
        correctList.add(new Task("Feed Pikachu",null,18,false,new ArrayList<String>(), ParsedCommand.TaskType.FLOATING_TASK));
        correctList.add(new Task("Feed Pikachu",null,20,false,new ArrayList<String>(), ParsedCommand.TaskType.FLOATING_TASK));
        correctList.add(new Task("Feed Pikachu",null,21,false,new ArrayList<String>(), ParsedCommand.TaskType.FLOATING_TASK));
        correctList.add(new Task("Feed Pikachu",null,22,false,new ArrayList<String>(), ParsedCommand.TaskType.FLOATING_TASK));
        correctList.add(new Task("Feed Pikachu",null,23,false,new ArrayList<String>(), ParsedCommand.TaskType.FLOATING_TASK));
        correctList.add(new Task("Feed Pikachu",null,24,false,new ArrayList<String>(), ParsedCommand.TaskType.FLOATING_TASK));
        correctList.add(new Task("Feed Pikachu",null,25,false,new ArrayList<String>(), ParsedCommand.TaskType.FLOATING_TASK));
        correctList.add(new Task("Feed Pikachu",null,26,false,new ArrayList<String>(), ParsedCommand.TaskType.FLOATING_TASK));
        correctList.add(new Task("Feed Pikachu",null,27,false,new ArrayList<String>(), ParsedCommand.TaskType.FLOATING_TASK));
        result = listChecker(searchList, correctList);

        assertEquals(true,result);
    }

    public boolean listChecker(List<Task> list1, List<Task> list2) {
        int index = 0;
        if (list1.size() != list2.size()) {
            System.out.println("list size different");
            return false;
        }
        for (Task task : list1) {
            if (list2.get(index).getId() != task.getId()) {
                return false;
            }
            index++;
        }
        return true;
    }

    @Test
    public void testSearch() throws Exception {

        Storage storage = new Storage();
        List<Task> searchList = Search.search(storage.getAllTasks(), "pikachu");

        ArrayList<Task> correctList = new ArrayList<Task>();
        correctList.add(new Task("Feed Pikachu",null,3,false,new ArrayList<String>(), ParsedCommand.TaskType.FLOATING_TASK));
        boolean result = listChecker(searchList, correctList);

        assertEquals(true,result);
    }


    @Test
    public void testSearchDate() throws Exception {

        Storage storage = new Storage();
        ParsedCommand command = MyParser.parseCommand("search 03/11/15 07/11/15");
        List<Task> searchList = Search.searchDate(storage.getAllTasks(), command.getFirstDate(), command.getSecondDate());

        ArrayList<Task> correctList = new ArrayList<Task>();
        correctList.add(new Task("important meeting with client 2",null,24,false,new ArrayList<String>(), ParsedCommand.TaskType.FLOATING_TASK));
        correctList.add(new Task("important meeting with client 3",null,25,false,new ArrayList<String>(), ParsedCommand.TaskType.FLOATING_TASK));
        correctList.add(new Task("important meeting with client 4",null,26,false,new ArrayList<String>(), ParsedCommand.TaskType.FLOATING_TASK));
        correctList.add(new Task("important meeting with client 5",null,27,false,new ArrayList<String>(), ParsedCommand.TaskType.FLOATING_TASK));

        boolean result = listChecker( searchList, correctList);

        assertEquals(true, result);

        command = MyParser.parseCommand("search 01/11/15 06/11/15");
        searchList = Search.searchDate(storage.getAllTasks(), command.getFirstDate(), command.getSecondDate());

        correctList = new ArrayList<Task>();
        correctList.add(new Task("important meeting with client 2",null,22,false,new ArrayList<String>(), ParsedCommand.TaskType.FLOATING_TASK));
        correctList.add(new Task("important meeting with client 2",null,23,false,new ArrayList<String>(), ParsedCommand.TaskType.FLOATING_TASK));
        correctList.add(new Task("important meeting with client 3",null,24,false,new ArrayList<String>(), ParsedCommand.TaskType.FLOATING_TASK));
        correctList.add(new Task("important meeting with client 4",null,25,false,new ArrayList<String>(), ParsedCommand.TaskType.FLOATING_TASK));
        correctList.add(new Task("important meeting with client 5",null,26,false,new ArrayList<String>(), ParsedCommand.TaskType.FLOATING_TASK));
        correctList.add(new Task("important meeting with client 5",null,27,false,new ArrayList<String>(), ParsedCommand.TaskType.FLOATING_TASK));

        result = listChecker( searchList, correctList);

        assertEquals(true, result);

        command = MyParser.parseCommand("search 01/11/15");
        searchList = Search.searchDate(storage.getAllTasks(), command.getFirstDate(), command.getSecondDate());

        correctList = new ArrayList<Task>();
        correctList.add(new Task("important meeting with client 2",null,22,false,new ArrayList<String>(), ParsedCommand.TaskType.FLOATING_TASK));

        result = listChecker( searchList, correctList);

        assertEquals(true, result);

        command = MyParser.parseCommand("search 02/11/15");
        searchList = Search.searchDate(storage.getAllTasks(), command.getFirstDate(), command.getSecondDate());

        correctList = new ArrayList<Task>();
        correctList.add(new Task("important meeting with client 2",null,23,false,new ArrayList<String>(), ParsedCommand.TaskType.FLOATING_TASK));

        result = listChecker( searchList, correctList);

        assertEquals(true, result);

    }


    @After
    public void reset() {
        File dataFile = new File("Data.txt");
        dataFile.renameTo(new File("Test_Data.txt"));
        File testFile = new File("temp.txt");
        testFile.renameTo(new File("Data.txt"));
    }
}
```
###### test\TaskTest.java
``` java
public class TaskTest {

    public static final String TEST_DESCRIPTION_1 = "TestDescription1";
    public static final String TEST_DESCRIPTION_2 = "TestDescription2";
    public static final String TEST_DESCRIPTION_3 = "TestDescription3";

    public static final String TEST_NAME_1 = "TestName1";
    public static final String TEST_NAME_2 = "TestName2";
    public static final String TEST_NAME_3 = "TestName3";

    public static final int TEST_ID_1 = 1;
    public static final int TEST_ID_2 = 2;
    public static final int TEST_ID_3 = 3;

    public ArrayList<Task> list = new ArrayList<Task>();
    public ArrayList<String> tags = new ArrayList<String>();
    public Task task1 ;
    public Task task2 ;
    public Task task3 ;
    public Task task4 ;
    public Task task5 ;


    @Before
    public void initialize() throws Exception {
        tags.add("TestTag1");
        tags.add("TestTag2");
        tags.add("TestTag3");

        Calendar endDate = Calendar.getInstance();
        endDate.set(2000,10,10);
        task1 = new Task(TEST_NAME_1, TEST_DESCRIPTION_1, TEST_ID_1, true, tags, ParsedCommand.TaskType.FLOATING_TASK);
        task2 = new DeadlineTask(TEST_NAME_2, TEST_DESCRIPTION_2, TEST_ID_2, false, tags, ParsedCommand.TaskType.DEADLINE_TASK, endDate);
        endDate.set(1990,10,10);
        task3 = new Event(TEST_NAME_3, TEST_DESCRIPTION_3, TEST_ID_3, true, tags, ParsedCommand.TaskType.EVENT, Calendar.getInstance(), endDate);
        endDate.set(1990,10,10);
        task4 = new Event(TEST_NAME_3, TEST_DESCRIPTION_3, TEST_ID_3, true, tags, ParsedCommand.TaskType.EVENT, Calendar.getInstance(), endDate);
        endDate.set(2005,10,10);
        task5 = new DeadlineTask(TEST_NAME_2, TEST_DESCRIPTION_2, TEST_ID_2, false, tags, ParsedCommand.TaskType.DEADLINE_TASK, endDate);

        list.add(task1);
        list.add(task2);
        list.add(task3);
        list.add(task4);
        list.add(task5);
    }

    @Test
    public void testTaskDetails() throws Exception {

        Task task = new Task("Test Setter Name", "Test Setter description", 50, true, tags, ParsedCommand.TaskType.FLOATING_TASK);
        new Task(MyParser.parseCommand("Add Task"));
        new Task(task);

        int i = 0;
        assertEquals(task.getTaskDetails().get(i++)[0],Task.FIELD_NAME);
        assertEquals(task.getTaskDetails().get(i++)[0], Task.FIELD_ID);
        assertEquals(task.getTaskDetails().get(i++)[0], Task.FIELD_DETAILS);
        assertEquals(task.getTaskDetails().get(i++)[0], Task.FIELD_TAGS);

        i = 0;
        assertEquals(task.getTaskDetails().get(i++)[1],"Test Setter Name");
        assertEquals(task.getTaskDetails().get(i++)[1], "" + 50);
        assertEquals(task.getTaskDetails().get(i++)[1], "Test Setter description");
        assertEquals(task.getTaskDetails().get(i++)[1],String.format("[%1$s][%2$s][%3$s]", tags.get(0), tags.get(1), tags.get(2)));
    }

    @Test
    public void testGetName() throws Exception {
        Task setNameTest1 = task1;
        setNameTest1.setName("Test");
        Task setNameTest2 = task2;
        setNameTest2.setName("Set");
        Task setNameTest3 = task3;
        setNameTest3.setName("Long Name");

        assertEquals(setNameTest1.getName(), "Test");
        assertEquals(setNameTest2.getName(), "Set");
        assertEquals(setNameTest3.getName(), "Long Name");
    }

    @Test
    public void testGetDetails() throws Exception {
        Task setNameTest1 = new Task();
        setNameTest1.setDescription("Test");
        Task setNameTest2 = new Task();
        setNameTest2.setDescription("Set");
        Task setNameTest3 = new Task();
        setNameTest3.setDescription("Description");

        assertEquals(setNameTest1.getDescription(), "Test");
        assertEquals(setNameTest2.getDescription(), "Set");
        assertEquals(setNameTest3.getDescription(), "Description");
    }

    @Test
    public void testGetId() throws Exception {
        Task setNameTest1 = new Task();
        setNameTest1.setId(1);
        Task setNameTest2 = new Task();
        setNameTest2.setId(0);
        Task setNameTest3 = new Task();
        setNameTest3.setId(-1);

        assertEquals(setNameTest1.getId(), 1);
        assertEquals(setNameTest2.getId(), 0);
        assertEquals(setNameTest3.getId(), -1);
    }

    @Test
    public void testGetIsCompleted() throws Exception {
        Task setCompletedTest = new Task();
        setCompletedTest.setIsCompleted(false);

        assertEquals(task1.getIsCompleted(), true);
        assertEquals(task2.getIsCompleted(), false);
        assertEquals(setCompletedTest.getIsCompleted(), false);
    }

    @Test
    public void testGetTags() throws Exception {

        String result = "";
        Task tagTest = task1;

        for(String tag : tagTest.getTags()) {
            result += "[" + tag + "]";
        }


        assertEquals(result, String.format("[%1$s][%2$s][%3$s]", tags.get(0), tags.get(1), tags.get(2)));

    }

    @Test
    public void testGetTaskType() throws Exception {

        assertEquals(task1.getTaskType(), ParsedCommand.TaskType.FLOATING_TASK);
        assertEquals(task2.getTaskType(), ParsedCommand.TaskType.DEADLINE_TASK);
        assertEquals(task3.getTaskType(), ParsedCommand.TaskType.EVENT);
    }

    @Test
    public void testCompareTo() throws Exception {
        Collections.sort(list,Task.compareByDate);

        assertEquals(0, list.get(2).compareTo(task3));
        assertEquals(0, list.get(3).compareTo(task4));
        assertEquals(0, list.get(1).compareTo(task2));
        assertEquals(0, list.get(4).compareTo(task5));
        assertEquals(0, list.get(0).compareTo(task1));
    }
}
```
###### test\UpdateTest.java
``` java
public class UpdateTest {
    @Before
    public void initialize() {
        File dataFile = new File("Data.txt");
        dataFile.renameTo(new File("temp.txt"));
        File testFile = new File("Test_Data.txt");
        testFile.renameTo(new File("Data.txt"));

    }

    @Test
    public void testExecute() throws Exception {
        Storage storage = new Storage();
        Model model = new Model(storage);
        Model correct = new Model();

        // test updating 1 field
        ParsedCommand command = MyParser.parseCommand("Edit 30 new name ");
        Update update = new Update(command,storage,model);

        update.execute();
        correct.setConsoleMessage("find firestone updated");

        boolean result = AddTest.consoleMessageChecker(correct, model);
        assertEquals(true, result);

        update.undo();

        // test updating 2 field
        // test updating 3 field
        // test updating 4 field
        // test updating 5 field
        // test updating into event
        // test updating into deadline task
        // test changing event into deadline task
    }

    @Test
    public void testUndo() throws Exception {
        // test updating 1 field
        // test updating 2 field
        // test updating 3 field
        // test updating 4 field
        // test updating 5 field
        // test updating into event
        // test updating into deadline task
        // test changing event into deadline task
    }

    @Test
    public void testUpdateTask() throws Exception {
        Task toUpdate = new Task();
        Task correct = new Task();
        correct.setId(1);
        toUpdate.setId(1);
        String title = null;
        String description = null;
        ArrayList<String> tags = null;
        Boolean isCompleted = null;
        Calendar firstDate = null;
        Calendar secondDate = null;


        // test trivial case
        Update command = new Update();
        Task updated = command.updateTask(title,description,tags,isCompleted,firstDate,secondDate,toUpdate);
        assertEquals(true, taskChecker(updated, toUpdate));

        // test updating name
        title = "short";
        correct.setName(title);
        updated = command.updateTask(title,description,tags,isCompleted,firstDate,secondDate,toUpdate);
        assertEquals(true, taskChecker(correct, updated));
        title = "super duper long title";
        correct.setName(title);
        updated = command.updateTask(title,description,tags,isCompleted,firstDate,secondDate,toUpdate);
        assertEquals(true, taskChecker(correct, updated));
        title = "t1t1es w1th numb3r5";
        correct.setName(title);
        updated = command.updateTask(title,description,tags,isCompleted,firstDate,secondDate,toUpdate);
        assertEquals(true, taskChecker(correct, updated));

        // test updating description
        description = "short";
        correct.setDescription(description);
        updated = command.updateTask(title,description,tags,isCompleted,firstDate,secondDate,toUpdate);
        assertEquals(true, taskChecker(correct, updated));
        description = "super duper long description";
        correct.setDescription(description);
        updated = command.updateTask(title,description,tags,isCompleted,firstDate,secondDate,toUpdate);
        assertEquals(true, taskChecker(correct, updated));
        description = "d3scr1pt10n w1th numb3r5";
        correct.setDescription(description);
        updated = command.updateTask(title,description,tags,isCompleted,firstDate,secondDate,toUpdate);
        assertEquals(true, taskChecker(correct, updated));

        // test updating tags
        tags = new ArrayList<>();
        tags.add("Test 1 tag");
        correct.setTags(tags);
        updated = command.updateTask(title,description,tags,isCompleted,firstDate,secondDate,toUpdate);
        assertEquals(true, taskChecker(correct, updated));
        tags.add("Test 2 tags");
        correct.setTags(tags);
        updated = command.updateTask(title,description,tags,isCompleted,firstDate,secondDate,toUpdate);
        assertEquals(true, taskChecker(correct, updated));
        tags.clear(); // test no tags
        correct.setTags(tags);
        updated = command.updateTask(title,description,tags,isCompleted,firstDate,secondDate,toUpdate);
        assertEquals(true, taskChecker(correct, updated));

        // test updating isCompleted
        isCompleted = true;
        correct.setIsCompleted(isCompleted);
        updated = command.updateTask(title,description,tags,isCompleted,firstDate,secondDate,toUpdate);
        assertEquals(true, taskChecker(correct, updated));
        isCompleted = false;
        correct.setIsCompleted(isCompleted);
        updated = command.updateTask(title,description,tags,isCompleted,firstDate,secondDate,toUpdate);
        assertEquals(true, taskChecker(correct, updated));

        // test firstDate
        firstDate = Calendar.getInstance(); // test today
        DeadlineTask dlCorrect = new DeadlineTask();
        dlCorrect.setId(1);
        dlCorrect.setName(title);
        dlCorrect.setDescription(description);
        dlCorrect.setTags(tags);
        dlCorrect.setIsCompleted(isCompleted);
        dlCorrect.setEnd(firstDate);
        updated = command.updateTask(title,description,tags,isCompleted,firstDate,secondDate,toUpdate);
        assertEquals(true, taskChecker(dlCorrect, updated));
        firstDate = Calendar.getInstance(); // test past date
        firstDate.set(1876,1,1,1,1,1);
        dlCorrect.setEnd(firstDate);
        updated = command.updateTask(title,description,tags,isCompleted,firstDate,secondDate,toUpdate);
        assertEquals(true, taskChecker(dlCorrect, updated));
        firstDate = Calendar.getInstance(); // test future date
        firstDate.set(5000,12,30,23,59,59);
        dlCorrect.setEnd(firstDate);
        updated = command.updateTask(title,description,tags,isCompleted,firstDate,secondDate,toUpdate);
        assertEquals(true, taskChecker(dlCorrect, updated));

        // test second date
        secondDate = Calendar.getInstance(); // test today
        Event eventCorrect = new Event();
        eventCorrect.setId(1);
        eventCorrect.setName(title);
        eventCorrect.setDescription(description);
        eventCorrect.setTags(tags);
        eventCorrect.setIsCompleted(isCompleted);
        eventCorrect.setStart(firstDate);
        eventCorrect.setEnd(secondDate);
        updated = command.updateTask(title,description,tags,isCompleted,firstDate,secondDate,toUpdate);
        assertEquals(true, taskChecker(eventCorrect, updated));
        firstDate = Calendar.getInstance(); // test past date
        firstDate.set(1876,1,1,1,1,1);
        eventCorrect.setEnd(firstDate);
        updated = command.updateTask(title,description,tags,isCompleted,firstDate,secondDate,toUpdate);
        assertEquals(true, taskChecker(eventCorrect, updated));
        firstDate = Calendar.getInstance(); // test future date
        firstDate.set(5000,12,30,23,59,59);
        eventCorrect.setEnd(firstDate);
        updated = command.updateTask(title,description,tags,isCompleted,firstDate,secondDate,toUpdate);
        assertEquals(true, taskChecker(eventCorrect, updated));
    }

    public boolean taskChecker(Task task1, Task task2) {
        if(task1.getId() != task2.getId()) {
            System.out.println("id not same");
            return false;
        } else {
            if (task1.getName() != null && task2.getName() !=null) {
                if (!task1.getName().equals(task2.getName())) {
                    System.out.println("name not same");
                    return false;
                }
            } else if (task1.getName() == null && task2.getName() == null) {
                // do nothing
            } else {
                System.out.println("name not same");
                return false;
            }
            if (task1.getDescription() != null && task2.getDescription() != null) {
                if (!task1.getDescription().equals(task2.getDescription())) {
                    System.out.println("description not same");
                    return false;
                }
            } else if (task1.getDescription() == null && task2.getDescription() == null) {
                // do nothing
            } else {
                System.out.println("description not same");
                return false;
            }
            if (task1.getIsCompleted() != task2.getIsCompleted()) {
                System.out.println("isCompleted not same");
                return false;
            }
            if (task1.getTags() != null || task2.getTags() != null) {
                if (task1.getTags() == null & task2.getTags() == null) {
                    // if both == null, ignore
                } else if (task1.getTags() != null && task2.getTags() != null) {
                    if (task1.getTags().size() != task2.getTags().size()) {
                        System.out.println("tags not same");
                        return false;
                    } else {
                        int i = 0;
                        for (String tag : task1.getTags()) {
                            if (!tag.equals(task2.getTags().get(i++))) {
                                System.out.println("tags not same");
                                return false;
                            }
                        }
                    }
                } else {
                    // Either task1 or task2 is null while the other isn't
                    System.out.println("tags not same");
                    return false;
                }
            }
            if (task1.getTaskType() == null && task2.getTaskType() == null) {
                // do nothing
            } else if (task1.getTaskType() != null && task2.getTaskType() != null) {
                System.out.println("taskType not same");
                return task1.getTaskType().equals(task2.getTaskType());
            }
        }
        return true;
    }

    @Test
    public void testCheckValid() throws Exception {
        // test invalid id
        ParsedCommand command = MyParser.parseCommand("Edit 500 new name");
        assertEquals(false, Update.checkValid(command, new Model()));
        // test valid id
        command = MyParser.parseCommand("Edit 1 new name");
        assertEquals(true,Update.checkValid(command,new Model()));
    }

    @After
    public void reset() {
        File dataFile = new File("Data.txt");
        dataFile.renameTo(new File("Test_Data.txt"));
        File testFile = new File("temp.txt");
        testFile.renameTo(new File("Data.txt"));
    }
}
```
